      SUBROUTINE AddComment(xcomm,iextra)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
C Routine to add new comments (xcomm) to the comments (comm) that already exist
C The iextra value is an upper estimate of the number of characters in xcomm 

      I1=2                   !singels
      IF(ITYPE.GT.1)I1=1     !matrix
c      write(6,*)'xcomm,iextra foer :',xcomm//'*',iextra

C Removing blanks in the comment to be added (xcomm)
      ix=iextra       
      DO i=1,iextra
C Finding number of blanks
        nblank=0
        DO k=i,ix
          IF(xcomm(k:k).NE.' '.OR.xcomm(k:k).NE.'')GO TO 1
          nblank=nblank+1
        ENDDO
1       CONTINUE
        IF(nblank.GT.0)THEN
          DO j=i+nblank,ix
            xcomm(j-nblank:j-nblank)=xcomm(j:j)
          ENDDO
          ix=ix-nblank
        ENDIF
      ENDDO
      

C Finding size of present comment array. Looking from back
      ifill=0
      DO i=60,1,-1
        IF(comm(I1,IDEST)(i:i).NE.' '.OR.comm(I1,IDEST)(i:i).NE.'')GO TO 2
      ENDDO
      GO TO 3
   2  ifill=i
       
   3  ishift=(ifill+ix)-60
      IF(ishift.LT.0)ishift=0
      IF(ishift.GT.0)THEN
        DO i=1+ishift,60
          comm(I1,IDEST)(i-ishift:i-ishift)=comm(I1,IDEST)(i:i)
        ENDDO
      ENDIF      
      DO i=1+ifill-ishift,60
        comm(I1,IDEST)(i:i)=''
      ENDDO

C Checking if we have to add (will not repeat last command if equal)
      mm=ifill-ishift
      IF(mm-ix+1.GE.1)THEN
        IF(comm(I1,IDEST)(mm-ix+1:mm).EQ.xcomm(m+1:m+ix))GO TO 99  !not repeating
      ENDIF
      IF(mm+1.LT.1.OR.mm+ix.GT.60)GO TO 99
      DO i=1,ix
        comm(I1,IDEST)(mm+i:mm+i)=xcomm(i:i)
      ENDDO

c      write(6,*)'xcomm,iextra etter:',xcomm//'*',ix
c      write(6,*)'comment ble etter :',comm(I1,IDEST)//'*'

 99   xcomm(1:60)=''
      RETURN
      END

      SUBROUTINE ADDDELPK(MODE,NPEAK,READY)

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      REAL          AREAS(15),DAREAS(15),CENTS(15)
      COMMON /AREA/ AREAS,DAREAS,CENTS

      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT

      REAL           FINEST(5), SWPARS(3)
      INTEGER        INFIX(3), INFIXRW, INFIXW
      COMMON /INEST/ FINEST,INFIX,SWPARS,INFIXRW,INFIXW

      LOGICAL      READY
      CHARACTER*40 ANS
      COMMON /LUS/ IR,IW,IP,IG

      itry=0

      IF ((.NOT.READY) .OR. NPKS.LE.0) THEN
         WRITE(IW,*) 'Cannot - no fit defined.'
         RETURN
      ENDIF

      IF (MODE.EQ.1) THEN

C                  AP; add peak to fit....
         IF (NPKS.GE.15) THEN
            WRITE(IW,*) 'Cannot - too many peaks.'
            RETURN
         ENDIF

C            ask for peak position....
30       N=NPKS+1
         IF (.NOT.DISP) GO TO 50
         WRITE(IW,*) ' New peak position?  (hit T to type, A to abort)'
         CALL RETIC(X,Y,ANS)
         IF (ANS(1:1).EQ.'A' .OR. ANS(1:1).EQ.'a') RETURN
         IF (ANS(1:1).NE.'T' .AND. ANS(1:1).NE.'t') GO TO 60
C            ....hit t for type....
c50       CALL ASK(15HPeak position=?,15,ANS,K)
50       CALL CASK('Peak position = ?',ANS,K)

         CALL FFIN(ANS,K,PPOS(N),RJ1,RJ2,*50)
         GO TO 70
60       PPOS(N)=X-0.5
70       IF (IFIX(PPOS(N)).LT.MCH(1)) GO TO 80
         IF (IFIX(PPOS(N)).LT.MCH(2)) GO TO 90
80       WRITE(IW,*) 'Peaks must be within limits - try again'
                  itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF
         GO TO 30
90       IF (DISP) CALL DSPMKR(N+2)

         NPKS=NPKS+1
         NPARS=NPARS+3
         AREAS(NPKS)=0.0
         DAREAS(NPKS)=0.0
         CENTS(NPKS)=PPOS(NPKS)
         DO 120 I=NPARS-2,NPARS
            ERRS(I)=0.0
            IFIXED(I)=1
120      CONTINUE
         IFIXED(NPARS-1)=INFIXW
         NFP=NFP+1-INFIXW

         ILO=MCH(1)+1
         IHI=MCH(2)+1
         X0=(IHI+ILO)/2
         PARS(NPARS-2)=PPOS(NPKS)
         PARS(NPARS-1)=SQRT( SWPARS(1)
     +                     + SWPARS(2)*PPOS(NPKS)
     +                     + SWPARS(3)*PPOS(NPKS)*PPOS(NPKS) )
         X=PPOS(NPKS)-X0+1.0
         Y=PARS(1)+PARS(2)*X+PARS(3)*X*X
         IPP=PPOS(NPKS)+1.5
         PARS(NPARS)=rSPEC(IDEST,IPP-1)-Y

         IF (INFIXW.EQ.1.AND.IRELW.EQ.0) THEN
c             CALL ASKYN(38HReset all non-fixed peak widths? (Y/N)
c     +                 ,38,*140)
             CALL CASKYN('Reset all non-fixed peak widths? (Y/N)',
     +                    IALT_RET)
             IF (IALT_RET.EQ.1) GO TO 140
             DO 130 I=1,NPKS-1
                J=3*I+5
                IF (IFIXED(J).EQ.1) PARS(J) =
     +                  SQRT( SWPARS(1)
     +                     + SWPARS(2)*PPOS(I)
     +                     + SWPARS(3)*PPOS(I)*PPOS(I) )
130          CONTINUE
         ENDIF

140      IF (CENTS(NPKS).GE.CENTS(NPKS-1)) GO TO 1000
c         CALL ASKYN(40HRe-order peaks in order of energy? (Y/N)
c     +             ,40,*1000)
         CALL CASKYN('Re-order peaks in order of energy? (Y/N)',
     +               IALT_RET)
         IF (IALT_RET.EQ.1) GO TO 1000

         DO 180 I=1,NPKS-1
            DO 170 J=I+1,NPKS
               IF (CENTS(I).GT.CENTS(J)) THEN
                  S=PPOS(I)
                  PPOS(I)=PPOS(J)
                  PPOS(J)=S
                  S=AREAS(I)
                  AREAS(I)=AREAS(J)
                  AREAS(J)=S
                  S=DAREAS(I)
                  DAREAS(I)=DAREAS(J)
                  DAREAS(J)=S
                  S=CENTS(I)
                  CENTS(I)=CENTS(J)
                  CENTS(J)=S
                  DO 150 K=3*I+4,3*I+6
                     L=3*(J-I)+K
                     S=PARS(K)
                     PARS(K)=PARS(L)
                     PARS(L)=S
                     S=ERRS(K)
                     ERRS(K)=ERRS(L)
                     ERRS(L)=S
                     JS=IFIXED(K)
                     IFIXED(K)=IFIXED(L)
                     IFIXED(L)=JS
150               CONTINUE
               ENDIF
170         CONTINUE
180      CONTINUE

      ELSE

C                  DP; delete peak from fit....
         IF (NPKS.LE.1) THEN
            WRITE(IW,*) 'Cannot - too few peaks.'
            RETURN
         ENDIF
230      IF (NPEAK.LE.0.OR.NPEAK.GT.NPKS) THEN
c240         CALL ASK(32HNumber of peak to be deleted = ?,32,ANS,NC)
240         CALL CASK('Number of peak to be deleted = ?',ANS,NC)
            IF (NC.EQ.0) RETURN
c            CALL ININ(ANS,NC,NPEAK,J,J2,*240)
            CALL ININ(ANS,NC,NPEAK,J,J2,IALT_RET)
            IF (IALT_RET.EQ.1) GO TO 240
            GO TO 230
         ENDIF

         NPARS=NPARS-3
         J=3*NPEAK+4
         NFP=NFP-3+IFIXED(J)+IFIXED(J+1)+IFIXED(J+2)
         IF (NPEAK.NE.NPKS) THEN
            DO 260 I=NPEAK,NPKS-1
               PPOS(I)=PPOS(I+1)
               AREAS(I)=AREAS(I+1)
               DAREAS(I)=DAREAS(I+1)
               CENTS(I)=CENTS(I+1)
260         CONTINUE
            DO 280 I=J,NPARS
               PARS(I)=PARS(I+3)
               ERRS(I)=ERRS(I+3)
               IFIXED(I)=IFIXED(I+3)
280         CONTINUE
         ENDIF
         NPKS=NPKS-1
      ENDIF

1000  RETURN
      END

      SUBROUTINE ADDWIN(WINMOD,*)

C          add window(s) to look-up file or slice input file....

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      LOGICAL         DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      REAL SPEC(8192)
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      CHARACTER*40 ANS

      INTEGER WINMOD
C         WINMOD = 0 : no mode defined....
C         WINMOD = 1 : look-up file mode....
C         WINMOD = 2 : slice file mode....

      INTEGER*2 LOOKTAB(8192)
      INTEGER   NCLOOK,LOOKMIN,LOOKMAX
      COMMON /LOOK/ NCLOOK,LOOKMIN,LOOKMAX,LOOKTAB

      COMMON /LUS/ IR,IW,IP,IG

      DO i=1,maxch+1
        SPEC(i)=rSPEC(IDEST,i-1)
      ENDDO


      IF (WINMOD.EQ.0) THEN
         WRITE(IW,*) 'Bad command: No window file open...'
         RETURN 1
      ELSEIF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet displayed...'
         RETURN 1
      ENDIF

      WRITE (IW,*) 'Hit X to exit...'

C           get limits for integration, background....

100   CALL RETIC(X,Y,ANS)
      IF (ANS(1:1).EQ.'X'.OR.ANS(1:1).EQ.'x') GO TO 900
      ILO=X
      Y1=Y
      CALL RETIC(X,Y,ANS)
      IF (ANS(1:1).EQ.'X'.OR.ANS(1:1).EQ.'x') GO TO 900
      IHI=X
      Y2=Y
      IF (ILO.GT.IHI) THEN
         IHI=ILO
         ILO=X
         Y2=Y1
         Y1=Y
      ENDIF
      IF (WINMOD.EQ.1.AND.ILO.GE.NCLOOK) THEN
         WRITE (IW,120) NCLOOK
120      FORMAT(' Cannot - lower limit exceeds dimension of look-up',
     +          ' table (',I4,')')
         GO TO 100
      ENDIF

C           display limits....

      ISAVE=MCH(1)
      MCH(1)=ILO
      CALL DSPMKR(1)
      MCH(1)=IHI
      CALL DSPMKR(1)
      MCH(1)=ISAVE

      SUM=0.0
      AREA=0.0
      CENT=0.0
      FNC=IHI-ILO
      IF (FNC.EQ.0.0) FNC = 1.0

      IF (WINMOD.EQ.2) THEN

C           slice mode : background to be subtracted....
C           display background....

         CALL INITG(NX,NY)
         X=FLOAT(ILO)+0.5
         CALL PSPOT(X,Y1)
         X=FLOAT(IHI)+0.5
         CALL VECT(X,Y2)
         CALL FINIG

         DO 150 I=ILO,IHI
            SUM = SUM + SPEC(I+1)
            COU = SPEC(I+1) - (Y1+(Y2-Y1)*FLOAT(I-ILO)/FNC)
            AREA = AREA + COU
            CENT = CENT + COU*FLOAT(I-ILO)
150      CONTINUE

         IF (AREA.EQ.0.0) THEN
            CENT = 0.0
            GO TO 200
         ENDIF

         CENT = CENT/AREA + FLOAT(ILO)
         AREA = AREA/SUM
         DC = 0.0
         CALL ENERGY(CENT,DC,EG,DEG,*200)

C          write out results....

         WRITE (IW,190,ERR=180) ILO,IHI,AREA,EG
180      WRITE (13,190,ERR=100) ILO,IHI,AREA,EG
190      FORMAT('  Chs',I5,' to',I5,'   P/T =',F8.4,'   Energy =',F9.3)
         GO TO 100

C          no energy calibration defined or zero area....

200      WRITE (IW,230,ERR=220) ILO,IHI,AREA,CENT
220      WRITE (13,230,ERR=100) ILO,IHI,AREA,CENT
230      FORMAT('  Chs',I5,' to',I5,'   P/T =',F8.4,'    Cent. =',F9.3)

      ELSE

C           look-up mode : no background to be subtracted....

         DO 310 I=ILO,IHI
            AREA=AREA+SPEC(I+1)
            CENT=CENT+SPEC(I+1)*FLOAT(I-ILO)
310      CONTINUE

         IF (AREA.EQ.0.0) THEN
            CENT = 0.0
            GO TO 350
         ENDIF

         CENT = CENT/AREA + FLOAT(ILO)
         DC = 0.0
         CALL ENERGY(CENT,DC,EG,DEG,*350)

C          write out results....

         WRITE (IW,330,ERR=400) ILO,IHI,EG
330      FORMAT(' Chs',I5,' to',I5,'   Energy =',F9.3)
         GO TO 400

C          no energy calibration defined or zero area....

350      WRITE (IW,360,ERR=400) ILO,IHI,CENT
360      FORMAT(' Chs',I5,' to',I5,'    Cent. =',F9.3)

C          ask for look-up value....

400      CALL ASK(32H  Look-up value = ? (A to abort),32,ANS,NC)
         IF (NC.EQ.0) GO TO 400
         IF (ANS(1:1).EQ.'A'.OR.ANS(1:1).EQ.'a') GO TO 100
         CALL ININ(ANS,NC,LUV,J1,J2,*400)
         IF (LUV.LT.LOOKMIN) LOOKMIN=LUV
         IF (LUV.GT.LOOKMAX) LOOKMAX=LUV
         IF (IHI.GE.NCLOOK) IHI=NCLOOK-1
         DO 450 I=ILO+1,IHI+1
            LOOKTAB(I)=LUV
450      CONTINUE

      ENDIF
      GO TO 100

900   RETURN
      END

C=======================================================================

      SUBROUTINE ASK(MESAG,NCM,ANS,NCA)

C         mesag: question to be asked (integer array)
C         ncm:   number of characters in question (integer)
C         ans:   answer recieved (character*40)
C         nca:   number of characters received in answer (integer)
C         mca:   max. number of characters asked for in answer (integer)

C patched by Andreas Schiller Sep. 10, 2003
C Reason: more standard repetitive format

      BYTE         MESAG(80)
      INTEGER      NCM, NCA
C  grabchar is a C function which returns the ascii value of the pressed key, 
C        (this value is grabbed - the return key does not have to be hit)

      INTEGER   GRABCHAR
      EXTERNAL  GRABCHAR

      LOGICAL        CFLOG
      COMMON /CFLOG/ CFLOG
      DATA           CFLOG /.FALSE./
      INTEGER        ICF   /4/

      CHARACTER*40 ANS
      COMMON /LUS/ IR,IW,IP,IG

C new variable added here, A.S.
      CHARACTER*11 F1STR


      IMCA=40
      GO TO 10

           ENTRY ASK2(MESAG,NCM,ANS,NCA,MCA)

      IMCA=MCA

C         output prompt message....

C changed the next three lines, A.S.
      WRITE(F1STR,20)NCM
10    IF (NCM.GT.0) WRITE(IW,FMT=F1STR) (MESAG(I),I=1,NCM)
20    FORMAT('(',I5.5,'A1,$)')
      IF (IR.NE.5 .AND. NCM.GT.3) WRITE(IW,*) CHAR(13)

C         read response....
      IF (IMCA.EQ.0) RETURN

      ANS=' '
      IF (IR.NE.5) THEN
         READ(IR,50,ERR=998,END=999) ANS
50       FORMAT(A40)
         NCA=IMCA
      ELSE
         IF (IMCA.EQ.1) THEN
            JCHAR = GRABCHAR()
            ANS(1:1) = CHAR(JCHAR)
            NCA = 1
         ELSE
            READ(IR,'(A40)') ANS
            NCA = 40
         ENDIF
      ENDIF

      IF (NCA.GT.IMCA) NCA=IMCA
      IF (NCA.LE.0) GO TO 70

C            replace <CR> with a space....
      IF (ANS(NCA:NCA).EQ.CHAR(13) .OR.
     +    ANS(NCA:NCA).EQ.CHAR(10)) THEN
         ANS(NCA:NCA)=' '
         NCA=NCA-1
         IF (NCA.LE.0) GO TO 70
      ELSEIF (IR.EQ.5 .AND. IMCA.EQ.1) THEN
C           since no <CR> or <LF> echoed, force new line....
         WRITE(IW,*) CHAR(13)
      ENDIF

C           remove trailing blanks....
      DO 60 I=NCA,1,-1
         IF (ANS(I:I).NE.' ') GO TO 70
         NCA=NCA-1
60    CONTINUE

C          if log command file open, copy response to lu ICF....
70    IF (CFLOG) WRITE(ICF,'(A)') ANS(1:NCA)

      RETURN

998   WRITE(IW,*) 'Command file not completed; read error on file.'
999   IR=5
      ANS = 'CF END'
      NCA = 9
      RETURN

      END

C======================================================================

      SUBROUTINE ASKYN(MESAG,NCM,*)

C         mesag:    question to be asked (integer array)
C         ncm:      number of characters in question (integer)
C         return 1: answer = N/n/0/<return>
C         return:   answer = Y/y/1

      INTEGER*4    MESAG(20)
      INTEGER      NCM, NCA
      CHARACTER*40 ANS


10    CALL ASK2(MESAG,NCM,ANS,NCA,1)
      IF (NCA.EQ.0
     +   .OR.ANS(1:1).EQ.'N'
     +   .OR.ANS(1:1).EQ.'n'
     +   .OR.ANS(1:1).EQ.'0') RETURN 1
      IF (ANS(1:1).EQ.'Y'
     +   .OR.ANS(1:1).EQ.'y'
     +   .OR.ANS(1:1).EQ.'1') RETURN
      GO TO 10
      END
      SUBROUTINE CASK(MESAG,ANS,NCA)

C         mesag: question to be asked (character string)
C         ans:   answer recieved (character*40)
C         nca:   number of characters received in answer (integer)
C         mca:   max. number of characters asked for in answer (integer)

      CHARACTER*(*) MESAG
      CHARACTER*40  ANS
      INTEGER       NCM, NCA
      CHARACTER*80  CMESAG
      INTEGER*4     IMESAG(20)
      EQUIVALENCE  (CMESAG,IMESAG)


      IMCA=40
      GO TO 10

           ENTRY CASK2(MESAG,ANS,NCA,MCA)

      IMCA=MCA
10    NCM = LEN(MESAG)
      IF (NCM.GT.80) NCM = 80
      CMESAG(1:NCM) = MESAG(1:NCM)
      CALL ASK2(IMESAG,NCM,ANS,NCA,IMCA)
      RETURN
      END

C======================================================================

      SUBROUTINE CASKYN(MESAG,*)

C         mesag:    question to be asked (character string)
C         return 1: answer = N/n/0/<return>
C         return:   answer = Y/y/1

      CHARACTER*(*) MESAG
      CHARACTER*40  ANS
      INTEGER       NCA


10    CALL CASK2(MESAG,ANS,NCA,1)
      IF (NCA.EQ.0
     +   .OR.ANS(1:1).EQ.'N'
     +   .OR.ANS(1:1).EQ.'n'
     +   .OR.ANS(1:1).EQ.'0') RETURN 1
      IF (ANS(1:1).EQ.'Y'
     +   .OR.ANS(1:1).EQ.'y'
     +   .OR.ANS(1:1).EQ.'1') RETURN
      GO TO 10
      END
      SUBROUTINE CHANGECOL
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)
      CHARACTER ANS*60, TEX*2
 
      iblack=20

      ictype=MAX0(ictype,1)       !Present type of color combinations
      icmd=1
      WRITE(6,1)icmd
 1    FORMAT('Choose color composition for 3D-plot.. (1)',
     +     /,'Interchange certain colors............ (2)',
     +     /,'Reset all colors to default values.... (3)',
     +     /,'Return to mama........................ (4) <',I1,'>:',$)
      CALL READI(5,icmd)
      IF(icmd.LT.1.OR.icmd.GT.3)Istatus=1
      IF(Istatus.NE.0)RETURN

      IF(icmd.EQ.1)THEN
        CALL ERASE
        CALL INITG(NX,NY)                    !Finding window size (nx,ny) 
        CALL LIMG(NX,LOX,NY,LOY)             !Informing screen window
        mx1=0      
        my1=(NY/2)+90
        myl=my1
        myh=myl+10
        DO it=1,10                           !10 types Color combinations
          CALL ColComp(it)
          mxl=mx1+10
          DO ic=1,14
            mxh=mxl+20
            CALL SETCOLOR(Colorc(ic-1))
            DO j=myl,myh              
              CALL KTRAS(mxl,j,0)     
              CALL KTRAS(mxh,j,1)
            ENDDO
            mxl=mxl+20
          ENDDO
          CALL SETCOLOR(iblack)
          CALL KTRAS(mxl+20,myl,0)
          WRITE(TEX,8)it
 8        FORMAT(I2)
          CALL PUTG(TEX,8,1)
          myl=myl-15
          myh=myl+10
        ENDDO
        CALL FINIG
        ians=ictype
        WRITE(6,7)ians
 7      FORMAT('Choose color composition (1-10) for 3D-plot <',I2,'>:',$)
        CALL READI(5,ians)
        IF(ians.LT.1.OR.iians.GT.10)Istatus=1
        IF(Istatus.NE.0)RETURN
        ictype=ians
        CALL ColComp(ictype)
      ENDIF

      IF(icmd.EQ.2)THEN
        CALL ERASE
        CALL INITG(NX,NY)                    !Finding window size (nx,ny) 
        CALL LIMG(NX,LOX,NY,LOY)             !Informing screen window
        mx1=5      
        my1=NY/2
        myl=my1
        myh=myl+10
        mxl=mx1
        DO ic=1,20
          mxh=mxl+18
          CALL SETCOLOR(COLORMAP(ic))
          DO j=myl,myh              
            CALL KTRAS(mxl,j,0)     
            CALL KTRAS(mxh,j,1)
          ENDDO
          CALL SETCOLOR(iblack)
          CALL KTRAS(mxl+6,myl-20,0)
          WRITE(TEX,2)ic
  2       FORMAT(I2)
          CALL PUTG(TEX,8,1)
          mxl=mxl+20
        ENDDO
        CALL FINIG
        WRITE(IW,4) (COLORMAP(I),I=1,20)
  4     FORMAT(  'Present Colors:',20(I3))
        CALL CASK('New Colors:      ',ANS,NC)
        IHI = -1
        DO IMAP=1,20
          LO = IHI + 2
          IF (LO.GT.NC) RETURN
          DO I=LO,NC                         !Find first non-blank character
            IF (ANS(I:I).NE.' ') GO TO 5
          ENDDO
          RETURN
  5       LO = I
          IF (ANS(LO:LO).EQ.',') THEN        !Comma only; no value entered
            IHI = LO - 1
            GO TO 99
          ENDIF
          DO I=LO,NC                         !Find upper delimiter (blank or comma)
            IF (ANS(I:I).EQ.' '.OR.ANS(I:I).EQ.',') GO TO 6
          ENDDO
          I = NC + 1
  6       IHI = I - 1
          CALL ININ(ANS(LO:IHI),IHI-LO+1,IDATA,J1,J2,*99) !Decode value
          COLORMAP(IMAP) = MOD(IDATA-1,20)+1
        ENDDO
  99    RETURN
      ENDIF

      IF(icmd.EQ.3)THEN
        DO ic=1,20
          COLORMAP(ic)=ic
        ENDDO
        ictype=1
        CALL ColComp(ictype)
      ENDIF

      CALL SETCOLOR(iblack)                      !Reset foreground to black
      RETURN
      END


      SUBROUTINE ColComp(ictype)
      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)

      IF(ictype.LT.1.or.ictype.gt.10)RETURN

C Following 20 colors are defined in minig_x_c.c
C The color brown is put in foreground by CALL SETCOLOR(7), and so on
c      1  = BLUE
c      2  = DEEP SKY BLUE
c      3  = LIGHT SKY BLUE
c      4  = SEA GREEN
c      5  = MEDIUM SEA GREEN
c      6  = GREEN
c      7  = BROWN
c      8  = CHOCOLATE
c      9  = SANDY BROWN
c      10 = RED
c      11 = CORAL
c      12 = ORANGE
c      13 = YELLOW3
c      14 = YELLOW2
c      15 = YELLOW
c      16 = PEACH PUFF
c      17 = PAPAYA WHIP
c      18 = OLD LACE
c      19 = WHITE
c      20 = BLACK


C Numbers taken from COLORMAP gives as default the same number: COLORMAP(7)=7
C However, these values can be changed by the user. Absolute white/black is stored
C in Color(18) and Color(19) - and can not be changed
      Colorc(18) =19              !white     (6 upper colors, not used in 3D-plot)
      Colorc(19) =20              !black
      Colorc(14) =COLORMAP(1 )    !blue
      Colorc(15) =COLORMAP(19)    !white
      Colorc(16) =COLORMAP(2 )    !deep sky blue
      Colorc(17) =COLORMAP(3 )    !light sky blue

      IF(ictype.EQ.1)THEN                     !the default
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(2 )    !deep sky blue
        Colorc(3) =COLORMAP(3 )    !light sky blue

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(5 )    !medium sea green
        Colorc(6) =COLORMAP(6 )    !green

        Colorc(7)=COLORMAP(13)     !yellow3
        Colorc(8)=COLORMAP(15)     !yellow
        Colorc(9) =COLORMAP(12)    !orange

        Colorc(10) =COLORMAP(8 )    !chocolate
        Colorc(11) =COLORMAP(11)    !coral
        Colorc(12) =COLORMAP(10)    !red
        Colorc(13) =COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.2)THEN                     !start with sand
        Colorc(0) =COLORMAP(16)    !peach puff
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(17)    !papaya whip
        Colorc(3) =COLORMAP(18)    !old lace

        Colorc(4) =COLORMAP(7 )    !brown
        Colorc(5) =COLORMAP(8 )    !chocolate
        Colorc(6) =COLORMAP(9 )    !sandy brown

        Colorc(7) =COLORMAP(10)    !red
        Colorc(8) =COLORMAP(11)    !coral
        Colorc(9) =COLORMAP(12)    !orange

        Colorc(10)=COLORMAP(13)    !yellow3
        Colorc(11)=COLORMAP(14)    !yellow2
        Colorc(12)=COLORMAP(15)    !yellow
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.3)THEN                     !interchange red and yellow
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(2 )    !deep sky blue
        Colorc(3) =COLORMAP(3 )    !light sky blue

        Colorc(4) =COLORMAP(7 )    !brown
        Colorc(5) =COLORMAP(8 )    !chocolate
        Colorc(6) =COLORMAP(9 )    !sandy brown

        Colorc(7) =COLORMAP(13)    !yellow3
        Colorc(8) =COLORMAP(14)    !yellow2
        Colorc(9) =COLORMAP(15)    !yellow

        Colorc(10)=COLORMAP(10)    !red
        Colorc(11)=COLORMAP(11)    !coral
        Colorc(12)=COLORMAP(12)    !orange
        Colorc(13)=COLORMAP(16)    !peach puff
      ENDIF

      IF(ictype.EQ.4)THEN                     !end with white
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(2 )    !deep sky blue
        Colorc(3) =COLORMAP(3 )    !light sky blue

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(5 )    !medium sea green
        Colorc(6) =COLORMAP(6 )    !green

        Colorc(7) =COLORMAP(10)    !red
        Colorc(8) =COLORMAP(11)    !coral
        Colorc(9) =COLORMAP(12)    !orange

        Colorc(10)=COLORMAP(13)    !yellow3
        Colorc(11)=COLORMAP(14)    !yellow2
        Colorc(12)=COLORMAP(19)    !yellow
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.5)THEN                     !for black/white
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(7 )    !brown
        Colorc(3) =COLORMAP(10)    !red

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(6 )    !green
        Colorc(6) =COLORMAP(8 )    !chocolate

        Colorc(7) =COLORMAP(2 )    !deep sky blue
        Colorc(8) =COLORMAP(3 )    !light sky blue
        Colorc(9) =COLORMAP(12)    !orange

        Colorc(10)=COLORMAP(13)    !yellow3
        Colorc(11)=COLORMAP(14)    !yellow2
        Colorc(12)=COLORMAP(18)    !old lace
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.6)THEN                     !sandy colors
        Colorc(0) =COLORMAP(7 )    !brown
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(8 )    !chocolate
        Colorc(3) =COLORMAP(9 )    !sandy brown

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(5 )    !medium sea green
        Colorc(6) =COLORMAP(6 )    !green

        Colorc(7) =COLORMAP(13)    !yellow3
        Colorc(8) =COLORMAP(14)    !yellow2
        Colorc(9) =COLORMAP(15)    !yellow

        Colorc(10)=COLORMAP(16)    !peach puff
        Colorc(11)=COLORMAP(17)    !papaya whip
        Colorc(12)=COLORMAP(18)    !old lace
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.7)THEN                     !blue colors
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(2 )    !deep sky blue
        Colorc(3) =COLORMAP(3 )    !light sky blue

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(5 )    !medium sea green
        Colorc(6) =COLORMAP(6 )    !green

        Colorc(7) =COLORMAP(7 )    !brown
        Colorc(8) =COLORMAP(8 )    !chocolate
        Colorc(9) =COLORMAP(9 )    !sandy brown

        Colorc(10)=COLORMAP(10)    !red
        Colorc(11)=COLORMAP(11)    !coral
        Colorc(12)=COLORMAP(12)    !orange
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.8)THEN                     !hot colors
        Colorc(0) =COLORMAP(4 )    !sea green
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(5 )    !medium sea green
        Colorc(3) =COLORMAP(6 )    !green

        Colorc(4) =COLORMAP(7 )    !brown
        Colorc(5) =COLORMAP(8 )    !chocolate
        Colorc(6) =COLORMAP(9 )    !sandy brown

        Colorc(7) =COLORMAP(10)    !red
        Colorc(8) =COLORMAP(11)    !coral
        Colorc(9) =COLORMAP(12)    !orange

        Colorc(10)=COLORMAP(13)    !yellow3
        Colorc(11)=COLORMAP(14)    !yellow2
        Colorc(12)=COLORMAP(15)    !yellow
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.9)THEN                     !cold colors
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(2 )    !deep sky blue
        Colorc(3) =COLORMAP(3 )    !light sky blue

        Colorc(4) =COLORMAP(4 )    !sea green
        Colorc(5) =COLORMAP(5 )    !medium sea green
        Colorc(6) =COLORMAP(6 )    !green

        Colorc(7) =COLORMAP(7 )    !brown
        Colorc(8) =COLORMAP(8 )    !chocolate
        Colorc(9) =COLORMAP(9 )    !sandy brown

        Colorc(10)=COLORMAP(13)    !yellow3
        Colorc(11)=COLORMAP(14)    !yellow2
        Colorc(12)=COLORMAP(15)    !yellow
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      IF(ictype.EQ.10)THEN                    !strong color variations
        Colorc(0) =COLORMAP(1 )    !blue
        Colorc(1) =COLORMAP(19)    !white
        Colorc(2) =COLORMAP(6 )    !green
        Colorc(3) =COLORMAP(7 )    !brown

        Colorc(4) =COLORMAP(10)    !red
        Colorc(5) =COLORMAP(15)    !yellow
        Colorc(6) =COLORMAP(2 )    !deep sky blue

        Colorc(7) =COLORMAP(3 )    !light sky blue
        Colorc(8) =COLORMAP(4 )    !sea green
        Colorc(9) =COLORMAP(5 )    !medium sea green

        Colorc(10)=COLORMAP(8 )    !chocolate
        Colorc(11)=COLORMAP(9 )    !sandy brown
        Colorc(12)=COLORMAP(11)    !coral
        Colorc(13)=COLORMAP(19)    !white
      ENDIF

      CALL FINIG
      RETURN
      END

C=======================================================================

      SUBROUTINE CHNGMARK(IDATA)

C        Allows the user to change the fitting limits and/or 
C        the peak positions and to optionally reset the free parameters 
C        to their initial estimates.
C
C        INPUT:            - the marker number     - IDATA .
C        OUTPUT: Changes:  - the marker[s]         - MCH, and/or 
C                          - the peak position[s]  - PPOS.
C        CALLed by GFEXEC.
C        CALLs function GETMKRCHNL

C        local variables....
      INTEGER        MN
      REAL           GETMKRCHNL

C        common blocks....

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT

      COMMON /LUS/ IR,IW,IP,IG


      MN = IDATA
C        MN is the Marker Number....
C        MCH(MN),    (MN = 1,2) are the lower and upper bounds
C                                 of the fitting region....
C        PPOS(MN-2), (MN = 3,4,5..,NPKS+2) are the peak positions....

      IF (MN.LE.0 .OR. MN.GT.NPKS+2) THEN
c           the data passed does not correspond to a marker
c           or there was no data passed....
c         CALL ASKYN(20HChange limits? (Y/N),20,*30)
         CALL CASKYN('Change limits? (Y/N)',IALT_RET)
         IF (IALT_RET.EQ.1) GO TO 30
         DO 20 MN = 1, 2
            MCH(MN) = NINT(GETMKRCHNL(MN))
            IF (DISP) CALL DSPMKR(MN)
20       CONTINUE
c30       CALL ASKYN(28HChange peak positions? (Y/N),28,*100)
30       CALL CASKYN('Change peak positions? (Y/N)',IALT_RET)
         IF (IALT_RET.EQ.1) GO TO 100
         DO 40 MN = 3, NPKS + 2
            PPOS(MN-2) = GETMKRCHNL(MN)
            IF (DISP) CALL DSPMKR(MN)
40       CONTINUE
      ELSE
c           if the user knows what s/he wants to change, do it, &return....
         IF (MN.LE.2) THEN
            WRITE (IW,*) '     New marker position? (type T for type)'
            MCH(MN) = GETMKRCHNL(MN)
         ELSEIF (MN.GT.2) THEN
            WRITE (IW,*) '     New peak position? (type T for type)'
            PPOS(MN-2) = GETMKRCHNL(MN)
         ENDIF
         IF (DISP) CALL DSPMKR(MN)
      ENDIF

c100   CALL ASKYN(44HReset free pars. to initial estimates? (Y/N),44,
c     +                                                           *110)
100   CALL CASKYN('Reset free pars. to initial estimates? (Y/N)',
     +            IALT_RET)
      IF (IALT_RET.EQ.1) GO TO 110
      CALL PARSET(0)
110   RETURN
      END
      SUBROUTINE CLEANUP
C Displays icons in graphic window, with red boarder around active (=IDEST) spectrum
C Tests parameters from last command
  
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT

      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      REAL*8       GAIN(6)                !GF2
      INTEGER      ICAL,NTERMS            !GF2
      COMMON/CALIB/GAIN,ICAL,NTERMS       !GF2

      INTEGER COLORMAP(20),Colorc(0:19)
      REAL Limit(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      COMMON/memory/Lastdest,Lasttype,LastXDIM,LastYDIM,LastMAXCH,calLast(2,2,2,3)
      

C Tests first if something went wrong. 
C Then return to GFEXEC subroutine
C                   Istatus=0 :OK
C                   Istatus=1 :wrong type of input parameter
C                   Istatus=2 :unphysical input parameter
C                   Istatus=3 :illegal answer
C                   Istatus=-7:flags that green button is active

C Setting up colors that are not to be changed
      igreen     =4
      ilightgreen=6
      isand      =9
      ired       =10
      iwhite     =19
      iblack     =20

      Iactive=0                    ! passiv green button
      IF(Istatus.EQ.-7)THEN
        Iactive=1                  !green button is active
        Istatus=0
      ENDIF
       
      IF(IDEST.LT.1.OR.IDEST.GT.2)THEN
        WRITE(6,*)'Detected illegal value for destination',
     1' spectrum. Corrected to IDEST=2'
        IDEST=2
      ENDIF

      IF(ITYPE.LT.1.OR.ITYPE.GT.3)THEN
        WRITE(6,*)'Detected illegal value for spectrum',
     1' type. Corrected to ITYPE=3'
        ITYPE=3
      ENDIF

      IF(Istatus.NE.0)WRITE(6,*)CHAR(7)
      IF(Istatus.EQ.1)THEN
        WRITE(6,*)'wrong type of input parameter'
        Istatus=0
        IDEST=Lastdest
        ITYPE=Lasttype
        XDIM=LastXDIM
        YDIM=LastYDIM
        MAXCH=LastMAXCH
        DO i=1,2
          DO j=1,2
            DO k=1,2
              DO l=1,3
                cal(i,j,k,l)=calLast(i,j,k,l)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        RETURN
      ENDIF
      
      IF(Istatus.EQ.2)THEN
        WRITE(6,*)'unphysical input parameter'
        Istatus=0
        IDEST=Lastdest
        ITYPE=Lasttype
        XDIM=LastXDIM
        YDIM=LastYDIM
        MAXCH=LastMAXCH
        DO i=1,2
          DO j=1,2
            DO k=1,2
              DO l=1,3
                cal(i,j,k,l)=calLast(i,j,k,l)
              ENDDO
            ENDDO
          ENDDO
        ENDDO
        RETURN
      ENDIF
      
      IF(Istatus.EQ.3)THEN
        WRITE(6,*)'illegal answer'
        Istatus=0
        IDEST=Lastdest
        ITYPE=Lasttype
        RETURN
      ENDIF

      Istatus=0

C Tests if dimensions are OK
      IF(ITYPE.GT.1)THEN              !Matrix
        IF(XDIM.GT.4096)XDIM=4096
        IF(YDIM.GT.512 )YDIM=512
        Idim(1,IDEST,1)=XDIM
        Idim(1,IDEST,2)=YDIM
      ENDIF

      IF(ITYPE.EQ.1)THEN              !Singles spectrum
        IF(MAXCH.LE.0   )MAXCH=1
        IF(MAXCH.GT.8191)MAXCH=8191
        Idim(2,IDEST,1)=MAXCH+1
      ENDIF


C If the matr./spc. is changed we resets to new display markers
      Lastdest=IDEST !Remember the last IDEST and ITYPE 
      Lasttype=ITYPE
      LastXDIM=XDIM
      LastYDIM=YDIM
      LastMAXCH=MAXCH
      DO i=1,2
        DO j=1,2
          DO k=1,2
            DO l=1,3
              calLast(i,j,k,l)=cal(i,j,k,l)
            ENDDO
          ENDDO
        ENDDO
      ENDDO


C Test if crazy calibration of a2, and resets to zero
      IF(ITYPE.GT.1)THEN
        IF(cal(1,IDEST,1,3).GT.1.E+14)cal(1,IDEST,1,3)=0.
        IF(cal(1,IDEST,2,3).GT.1.E+14)cal(1,IDEST,2,3)=0.
      ELSE
        IF(cal(2,IDEST,1,3).GT.1.E+14)cal(2,IDEST,1,3)=0.
      ENDIF
C Test if a0=a1=a2=0, put a1=1.
      IF(ITYPE.GT.1)THEN
        xcal=cal(1,IDEST,1,1)+cal(1,IDEST,1,2)+cal(1,IDEST,1,3)
        IF(xcal.EQ.0.)cal(1,IDEST,1,2)=1.
        ycal=cal(1,IDEST,2,1)+cal(1,IDEST,2,2)+cal(1,IDEST,2,3)
        IF(ycal.EQ.0.)cal(1,IDEST,2,2)=1.
      ELSE
        xcal=cal(2,IDEST,1,1)+cal(2,IDEST,1,2)+cal(2,IDEST,1,3)
        IF(xcal.EQ.0.)cal(2,IDEST,1,2)=1.
      ENDIF

C Put into display-spectrum if singles spectrum
      IF(ITYPE.EQ.1)THEN
        GAIN(1)=cal(2,IDEST,1,1)
        GAIN(2)=cal(2,IDEST,1,2)
        GAIN(3)=cal(2,IDEST,1,3)
        ICAL=1
        NTERMS=3       
      ENDIF

C Setting up colors for 2-dim landscape
      nCol=14

      c1    = 0.001
      ctop  = 10000.
      f1    = log(c1)
      ftop  = log(ctop)
      df    = ABS(ftop-f1)/FLOAT(nCol-3)
      DO i=1,nCol-2
        fi=f1+df*FLOAT(i-1)
        Limit(i)=exp(fi)
      ENDDO       
      Limit(0)=-Limit(1)


C Making the drawing in left upper corner:
C  I-----I I-----I                             my1  my11 
C  I     I I     I I--------I I--------I       my2
C  I-----I I-----I I--------I I--------I       my3
C   area    area     area       area           my4
C
C mx1   mx2 mx3 mx4 mx5    mx6 mx7   mx8 mx9 mx10


      CALL INITG(nx,ny)             !Pixel size of window
      is=18

      mx1=2
      mx2=mx1+2*is
      mx3=mx2+4
      mx4=mx3+2*is
      mx5=mx4+4
      mx6=mx5+3*is
      mx7=mx6+4
      mx8=mx7+3*is
      mx10=nx-4
      mx9=mx10-13

      my1=ny+42
      my2=my1-0.7*is
      my3=my2-0.3*is
      my11=my1-4


C Curser click exit point on green button
      ic1=igreen
      ic2=ilightgreen
      ic3=ilightgreen                  !passive green button
      IF(Iactive.EQ.1)THEN
        ic1=iblack
        ic2=igreen
        ic3=ilightgreen                !active green button
      ENDIF

      CALL SETCOLOR(ic2)
      DO j=my3+1,my11-3
        CALL KTRAS(mx9+4,j,0)
        CALL KTRAS(mx10+1,j,1)
      ENDDO

      CALL SETCOLOR(ic1)
      CALL KTRAS(mx9+2 ,my3   ,0)           !    -------    my11-2
      CALL KTRAS(mx10+2,my3   ,1)           !    |green |
      CALL KTRAS(mx10+2,my11-1,1)           !    |      |
                                            !    -------    my3+1
      CALL KTRAS(mx9+1 ,my3 -1,0)           !  mx9+3   mx10
      CALL KTRAS(mx10+3,my3 -1,1)              
      CALL KTRAS(mx10+3,my11  ,1)

      CALL SETCOLOR(ic3)
      CALL KTRAS(mx9+2 ,my3   ,0)            
      CALL KTRAS(mx9+2 ,my11-1,1)          
      CALL KTRAS(mx10+2,my11-1,1)  

      CALL KTRAS(mx9+1 ,my3 -1,0)
      CALL KTRAS(mx9+1 ,my11  ,1)
      CALL KTRAS(mx10+3,my11  ,1)

C Drawing the four matr./spec. icons
      LOY=0
      LOX=0

      CALL LIMG(NX,LOX,NY,LOY) !Informing screen window
    
C First matrix drawn
      fracX=FLOAT((Idim(1,1,1)-1))/FLOAT(mx2-mx1)
      fracY=FLOAT((Idim(1,1,2)-1))/FLOAT(my1-my3)
      y=-1.
      DO j=my3,my1        !Looping through all pixels NX*NY
        lOld=0
        CALL SETCOLOR(Colorc(lOld))        
        y=y+1.
        jj=y*fracY+0.5
        CALL KTRAS(mx1,j,0)      !Going to pixel (mx1,j)
        x=-1.
        DO i=mx1,mx2
          x=x+1.
          ii=x*fracX+0.5
          IF(ii.GT.4095.OR.jj.GT.511)THEN
             write(6,*)'Warning from cleanup.f: ii,jj=',ii,jj
          ELSE
            xx=rMAT(1,ii,jj)
          ENDIF
          DO l=0,nCol-2
            IF(xx.LT.Limit(l))GO TO 11
          ENDDO
          l=nCol-1
          IF(ii.GE.Idim(1,1,1).AND.jj.GE.Idim(1,1,2))lOld=0
   11     IF(l.NE.lOld)THEN
            CALL SETCOLOR(Colorc(lOld))
            CALL KTRAS(i,j,1)     !Drawing line to pixel (i,j)
            lOld=l
          ENDIF
        ENDDO
        xx=rMAT(1,Idim(1,1,1)-1,jj)   !Ensures to draw line to edge
        DO l=0,nCol-2
          IF(xx.LT.Limit(l))GO TO 12
        ENDDO
        l=nCol-2
  12    CALL SETCOLOR(Colorc(lOld))                
        CALL KTRAS(mx2,j,1)      
      ENDDO

      ICOL=isand                     !Drawing frame
      IF(IDEST.EQ.1.AND.ITYPE.GT.1)ICOL=ired
      CALL SETCOLOR(ICOL)
      CALL KTRAS(mx1-1,my1+1,0)
      CALL KTRAS(mx2+1,my1+1,1)
      CALL KTRAS(mx2+1,my3-1,1)
      CALL KTRAS(mx1-1,my3-1,1)
      CALL KTRAS(mx1-1,my1+1,1)
      CALL KTRAS(mx1,my1,0)
      CALL KTRAS(mx2,my1,1)
      CALL KTRAS(mx2,my3,1)
      CALL KTRAS(mx1,my3,1)
      CALL KTRAS(mx1,my1,1)

C Showing the markers if active spectrum
      IF(ICOL.EQ.ired)THEN
        CALL SETCOLOR(iblack) 
        mmx1=mx1+((LDX)/fracX)+0.5 
        mmx2=mx1+((HDX)/fracX)+0.5
        mmy1=my3+((LDY)/fracY)+0.5
        mmy2=my3+((HDY)/fracY)+0.5
        IF(mmx1.GT.mx2.OR.mmy1.GT.my1)GO TO 21
        IF(mmx2.GT.mx2)mmx2=mx2+2
        IF(mmy2.GT.my1)mmy2=my1+2
        IF(mmx1.eq.mx1.and.mmx2.eq.mx2.and.mmy1.eq.my3.and.mmy2.eq.my1)THEN
          GO TO 21
        ELSE
          CALL KTRAS(mmx1,mmy1,0)
          CALL KTRAS(mmx1,mmy2,1)
          IF(mmy2.gt.my1)THEN
            CALL KTRAS(mmx2,mmy2,0)
          ELSE
            CALL KTRAS(mmx2,mmy2,1)
          ENDIF
          IF(mmx2.gt.mx2)THEN
            CALL KTRAS(mmx2,mmy1,0)
          ELSE
            CALL KTRAS(mmx2,mmy1,1)
          ENDIF
          CALL KTRAS(mmx1,mmy1,1)
        ENDIF
      ENDIF
 21   CONTINUE


C Second matrix drawn
      fracX=FLOAT((Idim(1,2,1)-1))/FLOAT(mx4-mx3)
      fracY=FLOAT((Idim(1,2,2)-1))/FLOAT(my1-my3)
      y=-1.
      DO j=my3,my1
        lOld=0
        CALL SETCOLOR(Colorc(lOld))                  
        y=y+1.
        jj=y*fracY+0.5
        CALL KTRAS(mx3,j,0)   
        x=-1.
        DO i=mx3,mx4
          x=x+1.
          ii=x*fracX+0.5
          xx=rMAT(2,ii,jj)
          DO l=0,nCol-2
            IF(xx.LT.Limit(l))GO TO 13
          ENDDO
          l=nCol-1
          IF(ii.GE.Idim(1,2,1).AND.jj.GE.Idim(1,2,2))lOld=0
   13     IF(l.NE.lOld)THEN
            CALL SETCOLOR(Colorc(lOld))
            CALL KTRAS(i,j,1)
            lOld=l
          ENDIF
        ENDDO         
        xx=rMAT(2,Idim(1,2,1)-1,jj)  !Ensures to draw line to edge
        DO l=0,nCol-2
          IF(xx.LT.Limit(l))GO TO 14
        ENDDO
        l=nCol-1
  14    CALL SETCOLOR(Colorc(lOld))                
        CALL KTRAS(mx4,j,1)      
      ENDDO

      ICOL=isand                !Drawing frame
      IF(IDEST.EQ.2.AND.ITYPE.GT.1)ICOL=ired
      CALL SETCOLOR(ICOL)
      CALL KTRAS(mx3-1,my1+1,0)
      CALL KTRAS(mx4+1,my1+1,1)
      CALL KTRAS(mx4+1,my3-1,1)
      CALL KTRAS(mx3-1,my3-1,1)
      CALL KTRAS(mx3-1,my1+1,1)
      CALL KTRAS(mx3,my1,0)
      CALL KTRAS(mx4,my1,1)
      CALL KTRAS(mx4,my3,1)
      CALL KTRAS(mx3,my3,1)
      CALL KTRAS(mx3,my1,1)

C Showing the markers if active spectrum
      IF(ICOL.EQ.ired)THEN
        CALL SETCOLOR(iblack)
        mmx1=mx3+((LDX)/fracX)+0.5 
        mmx2=mx3+((HDX)/fracX)+0.5
        mmy1=my3+((LDY)/fracY)+0.5
        mmy2=my3+((HDY)/fracY)+0.5
        IF(mmx1.GT.mx4.OR.mmy1.GT.my1)GO TO 22
        IF(mmx2.GT.mx4)mmx2=mx4+2
        IF(mmy2.GT.my1)mmy2=my1+2
        IF(mmx1.eq.mx3.and.mmx2.eq.mx4.and.mmy1.eq.my3.and.mmy2.eq.my1)THEN
          GO TO 22
        ELSE
          CALL KTRAS(mmx1,mmy1,0)
          CALL KTRAS(mmx1,mmy2,1)
          IF(mmy2.gt.my1)THEN
             CALL KTRAS(mmx2,mmy2,0)
          ELSE
            CALL KTRAS(mmx2,mmy2,1)
          ENDIF
          IF(mmx2.gt.mx4)THEN
            CALL KTRAS(mmx2,mmy1,0)
          ELSE
            CALL KTRAS(mmx2,mmy1,1)
          ENDIF
          CALL KTRAS(mmx1,mmy1,1)
        ENDIF
      ENDIF
 22   CONTINUE

C First spectrum
      fracX=FLOAT((Idim(2,1,1)-1))/FLOAT(mx6-mx5)
      DO j=my3,my2
        lOld=0
        CALL SETCOLOR(Colorc(lOld))       
        CALL KTRAS(mx5,j,0)  
        x=-1.
        DO i=mx5,mx6
          x=x+1.
          ii=x*fracX+0.5
          xx=rSPEC(1,ii)
          DO l=0,ncol-2
            IF(xx.LT.Limit(l))GO TO 15
          ENDDO
          l=nCol-1          
          IF(ii.GE.Idim(2,1,1)-1)lOld=0
   15     IF(l.NE.lOld)THEN
            CALL SETCOLOR(Colorc(lOld))
            CALL KTRAS(i,j,1)
            lOld=l
          ENDIF     
        ENDDO
        xx=rSPEC(1,Idim(2,1,1)-1)   !Ensures to draw line to edge
        DO l=0,nCol-2
          IF(xx.LT.Limit(l))GO TO 16
        ENDDO
        l=nCol-1
  16    CALL SETCOLOR(Colorc(lOld))                      
        CALL KTRAS(mx6,j,1)
      ENDDO
C Take away old black markers
      CALL SETCOLOR(iwhite)
      DO i=my3+8,my2+3
        CALL KTRAS(mx5-2,i,0)
        CALL KTRAS(mx6+3,i,1)
      ENDDO
C Frame around icon
      ICOL=isand      
      IF(IDEST.EQ.1.AND.ITYPE.EQ.1)ICOL=ired
      CALL SETCOLOR(ICOL)
      CALL KTRAS(mx5-1,my2+1,0)
      CALL KTRAS(mx6+1,my2+1,1)
      CALL KTRAS(mx6+1,my3-1,1)
      CALL KTRAS(mx5-1,my3-1,1)
      CALL KTRAS(mx5-1,my2+1,1)
      CALL KTRAS(mx5,my2,0)
      CALL KTRAS(mx6,my2,1)
      CALL KTRAS(mx6,my3,1)
      CALL KTRAS(mx5,my3,1)
      CALL KTRAS(mx5,my2,1)

C Showing the markers if active spectrum
      IF(ICOL.EQ.ired)THEN
        CALL SETCOLOR(iblack)
        mmx1=mx5+((LOCH)/fracX)+0.5 
        mmx2=mx5+((HICH)/fracX)+0.5
        mmy1=my2+5
        mmy2=my3+6
        IF(mmx1.gt.mx6.and.mmx2.gt.mx6)THEN
          GO TO 23
        ENDIF
        IF(mmx1.eq.mx5.and.mmx2.eq.mx6)THEN
          GO TO 23
        ELSE
          CALL KTRAS(mmx1,mmy2,0)
          CALL KTRAS(mmx1,mmy1,1)
          IF(mmx2.gt.mx6)THEN
            mmx2=mx6+2
            CALL KTRAS(mmx2,mmy1,1)
          ELSE
            CALL KTRAS(mmx2,mmy1,1)
            CALL KTRAS(mmx2,mmy2,1)
          ENDIF
        ENDIF
      ENDIF
  23  CONTINUE


C Second spectrum 
      fracX=FLOAT((Idim(2,2,1)-1))/FLOAT(mx8-mx7)
      DO j=my3,my2
        lOld=0
        CALL SETCOLOR(Colorc(lOld))                 
        CALL KTRAS(mx7,j,0)    
        x=-1
        DO i=mx7,mx8
          x=x+1.
          ii=x*fracX+0.5
          xx=rSPEC(2,ii)
          DO l=0,ncol-2
            IF(xx.LT.Limit(l))GO TO 17
          ENDDO
          l=nCol-1
          IF(ii.GE.Idim(2,2,1)-1)lOld=0
   17     IF(l.NE.lOld)THEN
            CALL SETCOLOR(Colorc(lOld))
            CALL KTRAS(i,j,1)
            lOld=l
          ENDIF
        ENDDO 
        xx=rSPEC(2,Idim(2,2,1)-1)   !Ensures to draw line to edge
        DO l=0,nCol-2
          IF(xx.LT.Limit(l))GO TO 18
        ENDDO
        l=nCol-1
  18    CALL SETCOLOR(Colorc(lOld))                      
        CALL KTRAS(mx8,j,1)   
      ENDDO
C Take away old black markers
      CALL SETCOLOR(iwhite)
      DO i=my3+8,my2+3
        CALL KTRAS(mx7-3,i,0)
        CALL KTRAS(mx8+2,i,1)
      ENDDO
C Frame around icon
      ICOL=isand          
      IF(IDEST.EQ.2.AND.ITYPE.EQ.1)ICOL=ired
      CALL SETCOLOR(ICOL)
      CALL KTRAS(mx7-1,my2+1,0)
      CALL KTRAS(mx8+1,my2+1,1)
      CALL KTRAS(mx8+1,my3-1,1)
      CALL KTRAS(mx7-1,my3-1,1)
      CALL KTRAS(mx7-1,my2+1,1)
      CALL KTRAS(mx7,my2,0)
      CALL KTRAS(mx8,my2,1)
      CALL KTRAS(mx8,my3,1)
      CALL KTRAS(mx7,my3,1)
      CALL KTRAS(mx7,my2,1)

C Showing the markers if active spectrum
      IF(ICOL.EQ.ired)THEN
        CALL SETCOLOR(iblack) 
        mmx1=mx7+((LOCH)/fracX)+0.5 
        mmx2=mx7+((HICH)/fracX)+0.5
        mmy1=my2+5
        mmy2=my3+6
        IF(mmx1.gt.mx8.and.mmx2.gt.mx8)THEN
          GO TO 24
        ENDIF
        IF(mmx1.eq.mx7.and.mmx2.eq.mx8)THEN
          GO TO 24
        ELSE
          CALL KTRAS(mmx1,mmy2,0)
          CALL KTRAS(mmx1,mmy1,1)
          IF(mmx2.gt.mx8)THEN
            mmx2=mx8+2
            CALL KTRAS(mmx2,mmy1,1)
          ELSE
            CALL KTRAS(mmx2,mmy1,1)
            CALL KTRAS(mmx2,mmy2,1)
          ENDIF
        ENDIF
      ENDIF
  24  CONTINUE

C Drawing black line below the icons

      CALL SETCOLOR(iblack)
      CALL KTRAS(mx10+5,my3-3,0)
      CALL KTRAS(mx1 -2,my3-3,1)
      CALL FINIG
      DISP = .TRUE.
      RETURN

      END

C=======================================================================

      SUBROUTINE COMFIL(ANS,K)

      CHARACTER*40 ANS
      INTEGER      K

      LOGICAL        CFLOG
      COMMON /CFLOG/ CFLOG

      LOGICAL        CFOPEN /.FALSE./
      INTEGER        ICF /4/, ICON /5/

      COMMON /LUS/ IR,IW,IP,IG


      ANS(1:2) = '  '
      IF (K.GE.3) GO TO 15

C         ask for command file name....
10    IR = ICON
      CALL CASK('Command file name = ? (default .EXT = .cmd)',ANS,K)
      IF (K.EQ.0) RETURN

15    CALL SETEXT(ANS,'.cmd',J)

      IF (ANS(1:3).EQ.'END' .OR. ANS(1:3).EQ.'end') THEN
C           ....close command file, lu IR = console....
         CFOPEN = .FALSE.
         CFLOG = .FALSE.
         IR = ICON
         CLOSE(ICF,ERR=900)

      ELSEIF (ANS(1:3).EQ.'CON' .OR. ANS(1:3).EQ.'con') THEN
         IF (CFOPEN) THEN
            IR = ICF
         ELSE
            WRITE(IW,*) 'Command file not open.'
         ENDIF

      ELSEIF (ANS(1:3).EQ.'CHK' .OR. ANS(1:3).EQ.'chk') THEN
         IF (CFOPEN) THEN
            IR = ICON
            CALL CASKYN('Proceed? (Y/N)',*900)
            IR = ICF
         ELSEIF (.NOT.CFLOG) THEN
            WRITE(IW,*) 'Command file not open.'
         ENDIF

      ELSEIF (ANS(1:3).EQ.'ERA' .OR. ANS(1:3).EQ.'era') THEN
         CALL ERASE
c         CALL TXTMOD

      ELSEIF (ANS(1:3).EQ.'LOG' .OR. ANS(1:3).EQ.'log') THEN
         IF (CFOPEN.OR.CFLOG) CLOSE(ICF,ERR=50)
50       CFOPEN = .FALSE.
         CFLOG = .FALSE.
         IR = ICON
         CALL CASK(
     +        'File name for command logging = ? (default .EXT = .cmd)',
     +        ANS,K)
         IF (K.EQ.0) RETURN

         CALL SETEXT(ANS,'.cmd',J)
         IF (ANS(1:3).EQ.'END' .OR. ANS(1:3).EQ.'end' .OR.
     +       ANS(1:3).EQ.'CON' .OR. ANS(1:3).EQ.'con' .OR.
     +       ANS(1:3).EQ.'CHK' .OR. ANS(1:3).EQ.'chk' .OR.
     +       ANS(1:3).EQ.'ERA' .OR. ANS(1:3).EQ.'era' .OR.
     +       ANS(1:3).EQ.'LOG' .OR. ANS(1:3).EQ.'log') THEN
            WRITE(IW,*) '*** That is an illegal command file name. ***'
            GO TO 50
         ENDIF

C          ....open log command file for output....
C          ....all input from lu IR to be copied to lu ICF....
         OPEN(ICF,FILE=ANS,STATUS='NEW',ERR=990)
         CFLOG = .TRUE.

      ELSE
C         CF filename....
C          ....open command file for input on lu IR....
         IF (CFOPEN.OR.CFLOG) CLOSE(ICF,ERR=80)
80       CFLOG = .FALSE.
         OPEN(ICF,FILE=ANS,STATUS='OLD',ERR=920)
         CFOPEN = .TRUE.
         IR = ICF
      ENDIF

900   RETURN

920   WRITE(IW,*) 'File does not exist.'
      CFOPEN = .FALSE.
      CLOSE(ICF,ERR=10)
      GO TO 10

990   WRITE(IW,*) '*** Could not open new command file. ***'
      RETURN
      END
      SUBROUTINE CURSE(IDATA)
C This program looks like a mess - and is a mess, but it works!!!

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      CHARACTER*40 ANS
      DATA DX/0.0/
      COMMON /LUS/ IR,IW,IP,IG

      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/OL/I3,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

C Assume you point at an icon
C  I-----I I-----I                          my1   
C  I     I I     I I--------I I--------I    my2
C  I-----I I-----I I--------I I--------I    my3
C   area    area     area       area        my4
C
C mx1   mx2 mx3 mx4 mx5    mx6 mx7    mx8 

      IDESTold=IDEST
      ITYPEold=ITYPE
      Istatus=-7     !to flag that green button is active
      CALL CLEANUP

      CALL INITG(nx,ny)             !Pixel size of window
      is=18

      mx1=2
      mx2=mx1+2*is
      mx3=mx2+4
      mx4=mx3+2*is
      mx5=mx4+4
      mx6=mx5+3*is
      mx7=mx6+4
      mx8=mx7+3*is
      mx10=nx-1
      mx9=mx10-13

      my1=ny+42
      my2=my1-0.7*is
      my3=my2-0.3*is
      my33=my3-4    !An extra -4 because we never get iy > spec. area

      IF(ITYPE.GT.1)WRITE(IW,1)
      IF(ITYPE.EQ.1)WRITE(IW,2)
 1    FORMAT('Type X or click on green button to exit')
 2    FORMAT('Type X or click on green button to exit'
     +     /,'Type T to give channel number')

C First case if typing e.g. CR 120
      IF(ITYPE.EQ.1.AND.IDATA.GT.0)THEN
        IF(IDATA.GE.0.AND.IDATA.LE.8191)THEN
          GO TO 75
        ENDIF
      ENDIF

C Loop with curser
999   CALL RETIC(X,Y,ANS)
      CALL CVXY(X,Y,ix,iy,1)
      IF(ANS(1:1).EQ.'X'.OR.ANS(1:1).EQ.'x') RETURN
      IF(ix.GE.mx9.AND.ix.LE.mx10.AND.iy.GE.my33) RETURN
      IF(ANS(1:1).EQ.'T'.OR.ANS(1:1).EQ.'t')THEN
c65      CALL ASK(21HGive channel number: ,21,ANS,NC)
65       CALL CASK('Give channel number: ',ANS,NC)
        IF (NC.EQ.0) GO TO 999
        CALL ININ(ANS,NC,IDATA,J1,J2,*65)
        ANS(1:1)=' '
      ENDIF
       
      IF(ix.GE.0.AND.iy.GE.my33.AND.ix.LE.mx8+2)THEN 
        IF(ix.GE.mx1-2.AND.ix.LE.mx2+2)THEN
          IDEST=1
          ITYPE=3
          XDIM=Idim(1,IDEST,1)
          YDIM=Idim(1,IDEST,2)
          Istatus=-7     !to flag that green button is active
          CALL SetMarker(-1,-1,-1)
          CALL CLEANUP
          CALL TOUCH
        ENDIF
        IF(ix.GE.mx3-2.AND.ix.LE.mx4+2)THEN
          IDEST=2
          ITYPE=3
          XDIM=Idim(1,IDEST,1)
          YDIM=Idim(1,IDEST,2)
          Istatus=-7     !to flag that green button is active
          CALL SetMarker(-1,-1,-1)
          CALL CLEANUP
          CALL TOUCH
        ENDIF
        IF(ix.GE.mx5-2.AND.ix.LE.mx6+2)THEN
          IDEST=1
          ITYPE=1
          MAXCH=Idim(2,IDEST,1)-1
          Istatus=-7     !to flag that green button is active
          CALL SetMarker(-1,-1,-1)
          CALL CLEANUP
          CALL TOUCH
        ENDIF
        IF(ix.GE.mx7-2.AND.ix.LE.mx8+2)THEN
          IDEST=2
          ITYPE=1
          MAXCH=Idim(2,IDEST,1)-1
          Istatus=-7     !to flag that green button is active
          CALL SetMarker(-1,-1,-1)
          CALL CLEANUP
          CALL TOUCH
        ENDIF
        GO TO 999
      ENDIF

C If it is an outlay spectrum or multiple spectrum, we return
      IF(Idistype.GT.2)THEN
        WRITE(6,69)
69      FORMAT('No information on number of counts for outlay (OL)'
     +     /,'or multiple display of many spectra and matrices.'
     +     /,'Please, display (DS) only one single spectrum or matrix')
        Istatus=1
        RETURN
      ENDIF

C Case if one has pointed on matrix/spectrum icon, goes back to original
      IF(IDEST.NE.IDESTold.OR.ITYPE.NE.ITYPEold)THEN
        IF(ITYPE.GT.1)THEN
          XDIM=Idim(1,IDEST,1)
          YDIM=Idim(1,IDEST,2)
        ELSE
          MAXCH=Idim(2,IDEST,1)-1
        ENDIF
        Istatus=-7     !to flag that green button is active
        CALL CLEANUP
      ENDIF

C Assume you point at a matrix
      IF(ITYPE.GT.1)THEN
        IF(IDATA.NE.0)RETURN
        iix=X
        iiy=Y
        Iregion=1            ! =1 means (x,y) within legal limits
        IF(iix.GE.0.AND.iix.LE.4095)THEN
      Ex=cal(1,IDEST,1,1)+cal(1,IDEST,1,2)*iix+cal(1,IDEST,1,3)*iix*iix     
          WRITE(6,70)iix,Ex
70        FORMAT('x= ',I4,', energy = ',F10.3,' keV')
        ELSE
          Iregion=0
        ENDIF
        IF(iiy.GE.0.AND.iiy.LE.511)THEN
      Ey=cal(1,IDEST,2,1)+cal(1,IDEST,2,2)*iiy+cal(1,IDEST,2,3)*iiy*iiy     
          WRITE(6,71)iiy,Ey
71        FORMAT('y= ',I4,', energy = ',F10.3,' keV')
        ELSE
          Iregion=0 
        ENDIF
        IF(Iregion.EQ.1)WRITE(6,72)rMAT(IDEST,iix,iiy)
72      FORMAT('Number of counts= ',E13.6)
        GO TO 999
      ENDIF

C Assume you point at a spectrum
      IF(ITYPE.EQ.1.AND.IDATA.EQ.0)THEN
        iix=X
        IF(iix.GE.0.AND.iix.LE.8191)THEN
      Ex=cal(2,IDEST,1,1)+cal(2,IDEST,1,2)*iix+cal(2,IDEST,1,3)*iix*iix     
          WRITE(6,73)iix,rSPEC(IDEST,iix),Y,Ex
73        FORMAT('Ch =',I5,'  Counts =',E13.6,'  Y =',E13.6,'  Energy =',F9.2,' keV')
        ENDIF
        GO TO 999
      ENDIF

C Assume you have given the channel number by typing
75    IF(ITYPE.EQ.1.AND.IDATA.GT.0)THEN
        IF(IDATA.GE.0.AND.IDATA.LE.8191)THEN
          iix=IDATA
          ISAVE=MCH(1)
          MCH(1)=IDATA
          CALL DSPMKR(1)
          MCH(1)=ISAVE
      Ex=cal(2,IDEST,1,1)+cal(2,IDEST,1,2)*iix+cal(2,IDEST,1,3)*iix*iix     
          WRITE(6,74)iix,rSPEC(IDEST,iix),Ex
74        FORMAT('Ch =',I5,'  Counts =',E13.6,'  Energy =',F9.2,' keV')
        ENDIF
        IDATA=0
        GO TO 999
      ENDIF
      Istatus=0
      RETURN
      END


C=======================================================================

      SUBROUTINE DOFIT(IDATA,READY)

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      LOGICAL READY
c      CHARACTER*40 ANS

C          get limits etc. and/or do fit....

      IF (IDATA.GT.0) THEN
C          get limits, peak positions and fixed parameters....
         NPKS=IDATA
         CALL GFSET
         IF (NPKS.LE.0) THEN
            READY = .FALSE.
            RETURN
         ENDIF
         READY=.TRUE.
      ELSEIF (IDATA.LT.0) THEN
C          reset initial parameter estimates....
         CALL PARSET(0)
      ENDIF

c130   CALL ASK(37H Max. no. of iterations=?(rtn for 50),37,ANS,K)
      MAXITS=100
c      IF (K.NE.0) THEN
c         CALL ININ(ANS,K,MAXITS,J1,J2,*130)
c         IF (MAXITS.LE.0) RETURN
c      ENDIF

C          do fit....

      CALL FITTER(MAXITS,IALT_RET)
 
      IF (IALT_RET.EQ.1) GO TO 160
      IF (IALT_RET.EQ.2) GO TO 150

C          display fit and difference and list parameters....

      CALL GFFIN(0)

      RETURN
150   CALL GFFIN(1)

160   RETURN
      END
      SUBROUTINE DSPFIT

      INTEGER       MCH(2),lo,hi
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      
      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      REAL         SAVE(8192)
      COMMON /SAV/ SAVE

      REAL B(51)
      LO=MCH(1)
      HI=MCH(2)
      IF (LO.LT.LOCH) LO=LOCH
      IF (HI.GT.HICH) HI=HICH
      LO=LO+1
      IF (HI.LE.LO) RETURN
      HI=HI+1
      IF(HI.GT.8192)HI=8192                        !Magne
C          display background....
      CALL EVAL(PARS,IFIXED(4),Y,NPKS,-9)
      CALL EVAL(PARS,LO,Y,NPKS,-1)
      SAVE(LO)=Y
      X1=FLOAT(LO)-0.5

      CALL INITG(NX,NY)
      CALL PSPOT(X1,Y)
      DO 20 I=LO+1,HI
         X1=X1+1.0
         CALL EVAL(PARS,I,Y,NPKS,-1)
         SAVE(I)=Y
         CALL VECT(X1,Y)
20    CONTINUE

C          display fit....

      CALL EVAL(PARS,LO,Y,NPKS,0)
      X1=FLOAT(LO)-0.5
      CALL PSPOT(X1,Y)
      DO 30 I=LO+1,HI
         X1=X1+1.0
         CALL EVAL(PARS,I,Y,NPKS,0)
         CALL VECT(X1,Y)
                  
30    CONTINUE

C          display difference....

      Y1=(Y+(LOCNT))/2.0
      X1=FLOAT(LO)-0.5
      CALL EVAL(PARS,LO,Y,NPKS,0)
      Y=rSPEC(IDEST,LO-1)-Y+Y1
      CALL PSPOT(X1,Y)
      DO 40 I=LO+1,HI
         X1=X1+1.0
         CALL EVAL(PARS,I,Y,NPKS,0)
         Y=rSPEC(IDEST,I-1)-Y+Y1
         CALL VECT(X1,Y)
40    CONTINUE

C          display each peak seperately....

      IF (NPKS.EQ.1) GO TO 90
      DO 45 I=1,6
45       B(I)=0.0
      B(4)=PARS(4)
      B(5)=PARS(5)
      DO 80 J=1,NPKS
         DO 50 I=4,6
50          B(I+3)=PARS(3*J+I)
         CALL EVAL(B,IFIXED(4),Y,1,-9)
         ILO=B(7)-3.0*B(8)
         IHI=B(7)+3.0*B(8)
         IF (ILO.LT.LO) ILO=LO
         IF (IHI.GT.HI) IHI=HI
         CALL EVAL(B,ILO,Y,1,0)
         X1=FLOAT(ILO)-0.5
             if(ILO.GT.8192)ILO=8192
         CALL PSPOT(X1,Y+SAVE(ILO))
         DO 60 I=ILO+1,IHI
            X1=X1+1.0
            CALL EVAL(B,I,Y,1,0)
            CALL VECT(X1,Y+SAVE(I))
60       CONTINUE
80    CONTINUE
90    CALL FINIG
      RETURN
      END
      SUBROUTINE DSPMA(I1,I2,I3)
C Routine to display 2-dimensional spectra (matrices)
C M.Guttormsen, November 1993, June 1998
C patched by Andreas Schiller, Sep. 10 2003
C reason: more standard repetitive format

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      INTEGER XDIM,YDIM
      CHARACTER APP*4, TEX*8
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3
      COMMON/REMEMBER/mlimit(0:19)
      COMMON/OL/I3new,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      CHARACTER*28 HEADING
      INTEGER COLORMAP(20),Colorc(0:19)
      REAL Limit(0:19), mlimit
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      
      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      
C two new variables A.S.
      CHARACTER*6 F1STR
      CHARACTER*4 F2STR

      iwhite=19
      iblack=20
      I3new=I3
      IF(Idistype.NE.-3)Idistype=0   !assume only one matrix to display
                                     !=-3 is exception first time
C Testing that I's have right values
      IF(I1.LT.1.AND.I2.NE.0) Istatus=1
      IF(I2.GT.0.AND.I1.GT.I2)Istatus=1
      IF((I1.GT.2.AND.I2.EQ.0).OR.I3.GT.2)Istatus=1
      IF(Istatus.NE.0)THEN
        WRITE(6,*)'I1,I2,I3,IDEST,ITYPE',I1,I2,I3,IDEST,ITYPE
        RETURN
      ENDIF

C Testing if full scale values should be used      
      IF((I1.EQ.1.AND.I2.EQ.0).OR.I3.EQ.1)THEN
        CALL SetMarker(1,1,1)       
      ENDIF

C Testing if autoscale should be used      
      IF((I1.EQ.2.AND.I2.EQ.0).OR.I3.EQ.2)THEN
        CALL SetMarker(2,2,2)
      ENDIF

C Setting up 14 colors for 3D-plot
      nCol=14
      
C Logaritmic display
      IF(HDZ.GE.0.)THEN   !sign of HDZ used to determine log or manual plot 
        c1    = ABS(LDZ)
        ctop  = ABS(HDZ)
        f1    = log(c1)
        ftop  = log(ctop)
        df    = ABS(ftop-f1)/FLOAT(nCol-3)
        DO i=1,nCol-2
          fi=f1+df*FLOAT(i-1)
          Limit(i)=exp(fi)
        ENDDO       
        Limit(0)=-Limit(1)

      ELSE                     !ask for manual level-values as input

        WRITE(6,1)
 1      FORMAT(/'Type level-values for 2-dimensional plot.',/,
     +          'Each value must be > 0 and end with RETURN.',/,       
     +          'Type 0 and RETURN to terminate the input.',/,   
     +          'Example:',/,       
     +          '100',/,    
     +          '200',/,       
     +          '400',/,    
     +          '0',/,
     +          '(Maximum 16 levels)',/)
C Reading in levels-values:
        DO i=1,20
          Limit(i)=100*i
          IF(i.EQ.1)Limit(i)=1
          IF(mlimit(0).NE.0)Limit(i)=mlimit(i)
          WRITE(IW,29)Limit(i)
 29       FORMAT('Type level-value (0 for stop): <',E8.2,'>:',$)
          CALL READF(5,Limit(i))
          IF(Istatus.NE.0.OR.Limit(i).LE.0)THEN
            Istatus=0
            GO TO 97
          ENDIF
        ENDDO
 97     Limit(0)=-Limit(1)
        ncol=i
        DO i=0,20
          mlimit(i)=Limit(i)   !just to remember for next time as default
          IF(i.GT.ncol-1)mlimit(i) = 0.
        ENDDO
      ENDIF

      CALL INITG(NX,NY)          ! Finding window size (nx,ny)

C Setting up color pallett of 'ncol' colors 
C Pixel basis is 'is'
C Left lower pixel-origo is (mx,my)
C Checks first if all colors have place 
      is   =10
      IF(ncol.GE.2)THEN    !Draw pallett - if more than 2 colors
        mx1  =nx-20-(ncol-1)*is-ncol*is !15 -> 20
        ihigh=3
        my1  =ny+43-ihigh 
        DO l=0,ncol-1
          CALL SETCOLOR(Colorc(l))
          mxx=mx1+l*2*is
          DO j=my1,my1+ihigh                !Box in case of color
            CALL KTRAS(mxx,j,0)            
            CALL KTRAS(mxx+is,j,1)     
          ENDDO  
          IF(Colorc(l).EQ.19)THEN            !Box in case of white color  
            CALL SETCOLOR(iblack)   
            CALL KTRAS(mxx   ,my1      ,0)
            CALL KTRAS(mxx+is,my1      ,1)
            CALL KTRAS(mxx+is,my1+ihigh,1)
            CALL KTRAS(mxx   ,my1+ihigh,1)
            CALL KTRAS(mxx   ,my1      ,1)
          ENDIF
          IF(l.LT.ncol-1)THEN               !Writing limits with numbers
            CALL SETCOLOR(iblack)
            IF(l/2*2.EQ.l)THEN              !Staggering output
              idown=12
            ELSE
              idown=21
            ENDIF
            xLim=Limit(l)
            ndecimal=ABS(log10(ABS(xLim)))
            IF(ndecimal.GT.3)ndecimal=3
C changed some of the following lines to make standard repetitive formats
C added the next two lines A.S.
            WRITE(F1STR,161)ndecimal+5,ndecimal+2
            WRITE(F2STR,162)ndecimal+2
            IF(ABS(xLim).LT.0.0001.AND.xLim.LT.0.)THEN
               CALL KTRAS(mxx+is-20,my1-idown,0) ! somewhat extra to the left
               WRITE(TEX,160)xLim
            ELSEIF(xLim.LT.0.0)THEN
               CALL KTRAS(mxx+is-20,my1-idown,0) ! somewhat extra to the left
C changed the following line A.S.
               WRITE(TEX,FMT=F1STR)xLim
            ELSEIF(ABS(xLim).LT.0.00001)THEN
               CALL KTRAS(mxx+is-10,my1-idown,0) ! somewhat extra to the left
               WRITE(TEX,160)xLim
            ELSEIF(ABS(xLim).LT.0.001)THEN
               CALL KTRAS(mxx+is-5,my1-idown,0) ! somewhat extra to the left
C changed the following line A.S.
               WRITE(TEX,FMT=F1STR)xLim
            ELSEIF(ABS(xLim).LT.10.)THEN
               CALL KTRAS(mxx+is,my1-idown,0)
C changed the following line A.S.
               WRITE(TEX,FMT=F1STR)xLim
            ELSEIF(ABS(xLIM).LT.9999999)THEN
               Lim=xLim+0.5
               mcorr=0
               IF(Lim.GT.999)mcorr=6
               CALL KTRAS(mxx+is-mcorr,my1-idown,0)
C changed the following line A.S.
               WRITE(TEX,FMT=F2STR)Lim
            ENDIF
  160       FORMAT(E8.2)
C changed the following two lines A.S.
 161        FORMAT('(F',I1.1,'.',I1.1,')')
 162        FORMAT('(I',I1.1,')')
            CALL PUTG(TEX,8,1)
          ENDIF
        ENDDO 
       ENDIF

C Want to display matrix no. I1 out of I2
C Parting up the screen in i.e. inx*iny spectra,
C and finding origo for I1
      inx=1
      iny=1
      LOY=0
      LOX=0
      IF(I1.GT.0.AND.I2.GT.0) THEN
        IF(I1.GT.I2)I1=I2
        Idistype=3
        IF(I2.GT. 1.AND.I2.LE. 2)THEN !2*1 spectra
          inx=2
          iny=1
        ENDIF
        IF(I2.GT. 2.AND.I2.LE. 4)THEN !2*2 spectra
          inx=2
          iny=2
        ENDIF
        IF(I2.GT. 4.AND.I2.LE. 6)THEN !3*2 spectra
          inx=3
          iny=2
        ENDIF
        IF(I2.GT. 6.AND.I2.LE. 9)THEN !3*3 spectra
          inx=3
          iny=3
        ENDIF
        IF(I2.GT. 9.AND.I2.LE.12)THEN !4*3 spectra
          inx=4
          iny=3
        ENDIF
        IF(I2.GT.12.AND.I2.LE.16)THEN !4*4 spectra
          inx=4
          iny=4
        ENDIF
        IF(I2.GT.16.AND.I2.LE.20)THEN !5*4 spectra
          inx=5
          iny=4
        ENDIF
        IF(I2.GT.20.AND.I2.LE.25)THEN !5*5 spectra
          inx=5
          iny=5
        ENDIF
        IF(I2.GT.25.AND.I2.LE.30)THEN !6*5 spectra
          inx=6
          iny=5
        ENDIF
        IF(I2.GT.30.AND.I2.LE.36)THEN !6*6 spectra
          inx=6
          iny=6
        ENDIF
        
        IF(I2.GT.36)THEN
          WRITE(6,*)'Sorry, max. number of matrices is 36'
          Istatus=2
          GO TO 999
        ENDIF

        NX0=NX
        NY0=NY
        NX=NX/inx           !Number of x-pixels pr. spectrum
        NY=NY/iny           !Number of y-pixels pr. spectrum
        
C Drawing grid and frame for inx*iny spectra
        CALL SETCOLOR(iblack)
        DO i=0,inx
          CALL KTRAS(i*NX,20    ,0)
          CALL KTRAS(i*NX,NY0+18,1)
        ENDDO
        DO i=0,iny-1
          CALL KTRAS(0  ,i*NY+20,0)
          CALL KTRAS(NX0,i*NY+20,1)
        ENDDO

        LOY=NY*((I1-1)/inx) !Pixelstart in y-direction
        II1=I1
        DO WHILE (II1.GT.inx)
          II1=II1-inx
        ENDDO
        LOX=NX*(II1-1)      !Pixelstart in x-direction
      ENDIF

      CALL LIMG(NX,LOX,NY,LOY) !Informing screen window

C Gets window parameters for use for F77 routines through
C COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      CALL GETGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)  

C Assures that everything is OK
      IF((LDX. LT.0).OR.(LDX. GT.HDX). OR.(HDX. GT.4095).
     +OR.(LDY.LT.0).OR.(LDY.GT.HDY).OR.(HDY.GT.511))THEN
      write(6,*)'LDX,HDX,LDY,HDY',LDX,HDX,LDY,HDY
        Istatus=1
        GO TO 999
      ENDIF

      X0=LDX
      DX=HDX-LDX+1
      Y0=LDY
      DY=HDY-LDY+1

      kkk=1
      IF(IYAXIS.LT.0)kkk=-1
 
      CALL SETCOLOR(iblack)
      CALL TRAX(DX,X0,DY,Y0,kkk)
      fracX=FLOAT(HDX-LDX+1)/FLOAT(NX+1)
      fracY=FLOAT(HDY-LDY+1)/FLOAT(NY+1)
      MX1=LOX
      MX2=MX1+NX-1
      MY1=LOY+20
      MY2=MY1+NY-1
      
      IF(Idistype.EQ.-3)GO TO 33 !Very first display when starting mama

C In order to make the drawing of the matrix efficient,
C it is drawn in 3 ways depending on:
C 1. chX < chY and chX < pixelX: loop chX, loop pixelY
C 2. chY < chX and chY < pixelY: loop chY, loop pixelX
C 3. ch > pixels in both x an y direction: loop pixels
C These things are tested with respect to fracX and fracY

C Case 1
      IF(fracX.LT.fracY.AND.fracX.LT.1.)THEN
        DO j=MY1,MY2 
          lOld=0
          jj=LDY+(j-MY1)*fracY
          IF(jj.GT.HDY)jj=HDY
          CALL KTRAS(MX1,j,0)      !Going to pixel (MX1,j)
          DO ii=LDX,HDX            !Looping X-channels
            xx=rMAT(IDEST,ii,jj)
            DO l=0,nCol-2
              IF(xx.LT.Limit(l))GO TO 11
            ENDDO
            l=nCoL-1
   11       IF(l.NE.lOld)THEN
              CALL SETCOLOR(Colorc(lOld))
              i=MX1+((ii-LDX)/fracX)+0.5 !Calculating pixel for x
              CALL KTRAS(i,j,1)
              lOld=l
            ENDIF        
          ENDDO
          xx=rMAT(IDEST,HDX,jj)   !Ensures to draw line to edge
          DO l=0,nCol-2
            IF(xx.LT.Limit(l))GO TO 12
          ENDDO
          l=nCol-1
  12      CALL SETCOLOR(Colorc(lOld))                
          CALL KTRAS(MX2,j,1)
        ENDDO

        GO TO 33
      ENDIF

C Case 2
      IF(fracY.LT.fracX.AND.fracY.LT.1.)THEN
        DO i=MX1,MX2
          lOld=0
          ii=LDX+(i-MX1)*fracX
          IF(ii.GT.HDX)ii=HDX
          CALL KTRAS(i,MY1,0)      !Going to pixel (i,MY1)
          DO jj=LDY,HDY
            xx=rMAT(IDEST,ii,jj)
            DO l=0,nCol-2
              IF(xx.LT.Limit(l))GO TO 13
            ENDDO
            l=nCoL-1
   13       IF(l.NE.lOld)THEN
              CALL SETCOLOR(Colorc(lOld))
              j=MY1+((jj-LDY)/fracY)+0.5 !Calculating pixel for y
              CALL KTRAS(i,j,1)
              lOld=l
            ENDIF        
          ENDDO
          xx=rMAT(IDEST,ii,HDY)   !Ensures to draw line to edge
          DO l=0,nCol-2
            IF(xx.LT.Limit(l))GO TO 14
          ENDDO
          l=nCol-1
  14      CALL SETCOLOR(Colorc(lOld))                
          CALL KTRAS(i,MY2,1)
        ENDDO

        GO TO 33
      ENDIF

C Case 3, no other way than looping through all pixels NX*NY
      y=LDY-fracY
      DO j=MY1,MY2            
        lOld=0
        y=y+fracY
        jj=y+0.5
        CALL KTRAS(MX1,j,0)      !Going to pixel (MY1,j)
        x=LDX-fracX
        DO i=MX1,MX2
          x=x+fracX
          ii=x+0.5
          xx=rMAT(IDEST,ii,jj)
          DO l=0,nCol-2
            IF(xx.LT.Limit(l))GO TO 15
          ENDDO
          l=nCoL-1
   15     IF(l.NE.lOld)THEN
            CALL SETCOLOR(Colorc(lOld))
            CALL KTRAS(i,j,1)
            lOld=l
          ENDIF        
        ENDDO
        xx=rMAT(IDEST,HDX,jj)   !Ensures to draw line to edge
        DO l=0,nCol-2
          IF(xx.LT.Limit(l))GO TO 16
        ENDDO
        l=nCol-1
  16    CALL SETCOLOR(Colorc(lOld))                
        CALL KTRAS(MX2,j,1)
      ENDDO

C Making axes and headings
  33  CALL SETCOLOR(iblack)
      CALL TRAX(DX,X0,DY,Y0,kkk)
      CALL DATETIME(HEADING)
C Finding date text to write   
      n1=0
      n2=0   
      n3=0
      ic=0
      DO i=1,17
         IF(HEADING(i:i).EQ.'-'.OR.HEADING(i:i).EQ.' '.OR.HEADING(i:i).EQ.':')THEN
            ic=ic+1
            IF(ic.EQ.2)n1=i
            IF(ic.EQ.3)n2=i
            IF(ic.EQ.4)n3=i
         ENDIF
      ENDDO
      numb=n1+(n3-n2)+1
      IF(itext.EQ.1)THEN
        CALL MSPOT(MX2-60,LOY+NY+5)
        CALL PUTG(fname(1,IDEST)(1:8),8,1)
        CALL MSPOT(MX2-60,LOY+NY-6)
        CALL PUTG(HEADING(1:n1-1)//HEADING(n2+1:n3+3),numb,1)
      ENDIF
      DISP = .TRUE.

      IF(itext.EQ.0)GO TO 999
C Putting on unit on axis
      CALL INITG(NX,NY)
C Units on x-axis
      CALL MSPOT(NX-8,1)
      CALL PUTG(UNITx,3,8)
C Units on y-axis
      CALL SETCOLOR(iwhite)                  ! Clear area to write in
      DO j=NY+5,NY+14
        CALL KTRAS(6,j,0)            
        CALL KTRAS(6+21,j,1)     
      ENDDO  
      CALL SETCOLOR(iblack)
      CALL MSPOT(7,NY+3)
      CALL PUTG(UNITy,3,2)
999   CALL FINIG
      RETURN
      END

      SUBROUTINE DSPMKR(K)

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      
      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS
      
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      CHARACTER*15  MCHAR
      DATA          MCHAR /'123456789ABCDEF'/
      
      CALL INITG(NX,NY)
      I=K
      IF (K.EQ.99) I=1
20    IF (I.GT.2) THEN
         X=PPOS(I-2)+0.5
         ICH=X
      ELSE
         ICH=MCH(I)
      ENDIF

      IF (ICH.GE.LOCH.AND.ICH.LE.HICH) THEN
         IF (I.GT.2) THEN
            Y=rSPEC(IDEST,ICH)
            CALL CVXY(X,Y,IX,IY,1)
            CALL CVXY(X1,Y,IX,IY-10,2)
            CALL SYMBG(9,X,Y,7,90.0)
            CALL MSPOT(IX,IY-10)
            CALL IVECT(IX,IY-30)
            CALL MSPOT(IX,IY-45)
            CALL PUTG(MCHAR(I-2:I-2),1,5)
         ELSE
            X=FLOAT(ICH)+0.5
            Y=LOCNT
            CALL PSPOT(X,Y)
            CALL VECT(X,rSPEC(IDEST,ICH))
         ENDIF
      ENDIF

      I=I+1
      IF (K.EQ.99.AND.I.LE.NPKS+2) GO TO 20
      CALL FINIG      
      RETURN
      END
      SUBROUTINE DSPSP(I1,I2,I3,*)

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)

      CHARACTER*28 HEADING
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3
      COMMON/OL/I3new,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM

      iblack=20
      I3new=I3
      Idistype=0                 !assume only one spectrum to be displayed
      LOY=0
      CALL INITG(NX,NY)
      IF (I1.GT.0 .AND. I2.GT.0) THEN
         Idistype=1
         IF (I1.GT.I2) I1=I2
         NY=NY/I2
         LOY=NY*(I1-1)
      ENDIF

      ICOL = COLORMAP(1)       !blue

      CALL LIMG(NX,0,NY,LOY)
      
C Gets window parameters for use for F77 routines through
C COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      CALL GETGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)  
 
      CALL Setmarker(0,0,0)
      IF((I1.EQ.1.AND.I2.EQ.0).OR.I3.EQ.1)THEN
        CALL SetMarker(1,1,2)                         !Full scale display
      ENDIF
      IF((I1.EQ.2.AND.I2.EQ.0).OR.I3.EQ.2)THEN
        CALL SetMarker(2,2,2)                         !Autoscaling
      ENDIF
       
      NCC =(HICH-LOCH)/NX+1
      NCHS=(HICH-LOCH+1)

      X0=LOCH
      DX=NCHS
      Y0=LOCNT
      DY0=HICNT-LOCNT
c      IF(DY0.LE.0.)DY0 = 1.
      DY=1.05*DY0

      CALL SETCOLOR(iblack)
      CALL TRAX(DX,X0,DY,Y0,IYAXIS)

      CALL SETCOLOR(ICOL)
      X=LOCH
      IF (NCC.EQ.1) THEN
        CALL PSPOT(X,rSPEC(IDEST,LOCH))
        DO 40 I=LOCH+1,HICH+1
           CALL VECT(X,rSPEC(IDEST,I-1))
           X=X+1.0
           CALL VECT(X,rSPEC(IDEST,I-1))
   40   CONTINUE
      ELSE
        Y=0.
        DO 50 I=1,NCC
   50      Y=Y+rSPEC(IDEST,LOCH+I-1)
        FNCC=FLOAT(NCC)
        Y=Y/FNCC
        CALL PSPOT(X,Y)
        DO 55 ICH=LOCH,LOCH+(NCHS/NCC-1)*NCC,NCC
           Y=0.
           DO 60 I=1,NCC
   60         Y=Y+rSPEC(IDEST,ICH+I-1)
           Y=Y/FNCC
           CALL VECT(X,Y)
           X=X+FNCC
           CALL VECT(X,Y)
   55   CONTINUE
      ENDIF
      CALL SETCOLOR(iblack)
      CALL DATETIME(HEADING)
C Finding date text to write   
      n1=0
      n2=0   
      n3=0
      ic=0
      DO i=1,17
         IF(HEADING(i:i).EQ.'-'.OR.HEADING(i:i).EQ.' '.OR.HEADING(i:i).EQ.':')THEN
            ic=ic+1
            IF(ic.EQ.2)n1=i
            IF(ic.EQ.3)n2=i
            IF(ic.EQ.4)n3=i
         ENDIF
      ENDDO
      numb=n1+(n3-n2)+1
      IF(itext.EQ.1)THEN
        CALL MSPOT(NX-60,LOY+NY+5)
        CALL PUTG(fname(2,IDEST)(1:8),8,1)
        CALL MSPOT(NX-60,LOY+NY-6)
        CALL PUTG(HEADING(1:n1-1)//HEADING(n2+1:n3+3),numb,1)
      ENDIF
      CALL FINIG
      DISP = .TRUE.


C Putting on unit on axis
      CALL INITG(NX,NY)
C Units on x-axis
      CALL MSPOT(NX-8,1)
      CALL PUTG(UNITx,3,8)

      RETURN

999   CALL FINIG
      RETURN 1
      END


C=======================================================================

      SUBROUTINE ENERGY(X,DX,EG,DEG,*)

      REAL*8         GAIN(6)
      INTEGER        ICAL, NTERMS
      COMMON /CALIB/ GAIN, ICAL, NTERMS


      IF (ICAL.EQ.0) RETURN 1
      DEG=0.0
      EG=GAIN(NTERMS)
      DO 15 JJ=NTERMS-1,1,-1
         DEG=FLOAT(JJ)*GAIN(JJ+1)+DEG*X
         EG=GAIN(JJ)+EG*X
15    CONTINUE
      DEG=DEG*DX
      RETURN
      END
      SUBROUTINE ENVIRONMENT

      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/OL/I3,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3,UNIT*3
      COMMON/sdod/ntelesc
      
      WRITE(6,4)
   4  FORMAT(/,'The y-axis for ESP, DESP, EDESP and THICKSP',/,
     +         'should be set according to # of telescopes',/,
     +         'in the SIRIUS or OFFLINE sorting routines.')
      n=ntelesc
      WRITE(6,1)n
   1  FORMAT(  'Number of telescopes (8, 9, ...64)    <',I2,'>:',$)
      CALL READI(5,n)
      IF(Istatus.NE.0)RETURN
      ntelesc=n
      IF(ntelesc.LT.1 )ntelesc=8
      IF(ntelesc.GT.64)ntelesc=64
      
      UNIT=UNITx0
      WRITE(6,2)UNIT
   2  FORMAT(  'Units or name on x-axis ( < 4 char)  <',A3,'>:',$)
      CALL READA(5,UNIT)
      IF(Istatus.NE.0)RETURN
      UNITx0=UNIT

      UNIT=UNITy0
      WRITE(6,3)UNIT
   3  FORMAT(  'Units or name on y-axis ( < 4 char)  <',A3,'>:',$)
      CALL READA(5,UNIT) 
      IF(Istatus.NE.0)RETURN
      UNITy0=UNIT

      RETURN
      END
        
      

C=======================================================================

      SUBROUTINE EVAL(PARS,II,FIT,NPKS,MODE)

C       this eval is for use with 'GF2' version V....
C          D. C. Radford     July 1985

      REAL    PARS(51),Y(15),Y1(15),Y2(15)
      LOGICAL NOTAIL

      REAL           DERIVS(51)
      COMMON /DERIV/ DERIVS

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS
      
      ix0=0                         !this repaired why fit did not work on MacXOs
      IF(NPKS.GT.15)THEN
        WRITE(6,*)'Too many peaks'
        RETURN
      ENDIF
C       calculate the fit using present values of the pars....

      IF (MODE.EQ.-9) THEN

C         mode = -9 ; initialise, i.e calculate  IX0,NOTAIL,Y,Y1,Y2....

         IX0=(MCH(1)+MCH(2)+2)/2
         NOTAIL=.TRUE.
         IF (II.EQ.0 .AND. PARS(4).EQ.0.0) RETURN
         NOTAIL=.FALSE.
         DO 10 I=1,NPKS
            Y(I)=PARS(3*I+5)/(3.33021838*PARS(5))
            Y1(I)=ERFC(Y(I))
            IF (Y1(I).EQ.0.0) THEN
               NOTAIL=.TRUE.
            ELSE
               Y2(I)=EXP(-Y(I)*Y(I))*1.12837917/Y1(I)
            ENDIF
10       CONTINUE
         RETURN
      ENDIF

      X=II-IX0
                       
      FIT=PARS(1)+PARS(2)*X+PARS(3)*X*X
      IF (MODE.GE.1) THEN
         DERIVS(2)=X
         DERIVS(3)=X*X
         DERIVS(4)=0.
         DERIVS(5)=0.
         DERIVS(6)=0.
      ENDIF
      X1=II-1
      
      DO 50 I=1,NPKS
         WIDTH=PARS(3*I+5)/2.35482
         H=PARS(3*I+6)
         X=X1-PARS(3*I+4)
         
         W=X/(1.41421356*WIDTH)
         IF (ABS(W).GT.4.0) THEN
            U1=0.0
            U3=0.0
            IF (X.LT.0.0) U3=2.0
         ELSE
            U1=EXP(-W*W)
            U3=ERFC(W)
         ENDIF

         IF (MODE.EQ.-1) THEN
C               mode = -1; calculate background only....
            FIT=FIT+H*PARS(6)*U3/200.0
            GO TO 50
         ENDIF

         IF (NOTAIL) THEN
C               notail = true; pur gaussians only....
            U=U1+PARS(6)*U3/200.0
            FIT=FIT+H*U
C             calculate derivs only for mode.ge.1....
            IF (MODE.GE.1) THEN
               DERIVS(6)=DERIVS(6)+H*U3/200.0
               A=U1*(W+PARS(6)/354.49077)*2.0
               DERIVS(3*I+4)=H*A/(1.41421356*WIDTH)
               DERIVS(3*I+5)=H*W*A/WIDTH
               DERIVS(3*I+6)=U
            ENDIF
            GO TO 50
         ENDIF

         R=PARS(4)/100.0
         R1=1.0-R
         BETA=PARS(5)
         Z=W+Y(I)
         IF (ABS(X/BETA).GT.12.0) THEN
            U5=0.0
            U6=0.0
            U7=0.0
         ELSE
            U7=EXP(X/BETA)/Y1(I)
            IF (ABS(Z).GT.4.0) THEN
               U5=0.0
               IF (Z.LT.0.0) U5=2.0
               U6=0.0
            ELSE
               U5=ERFC(Z)
               U6=EXP(-Z*Z)*1.12837917
            ENDIF
         ENDIF
         U2=U7*U5

         U=R1*U1+R*U2+PARS(6)*U3/200.0
         FIT=FIT+H*U

C          calculate derivs only for mode.ge.1....
         IF (MODE.GE.1) THEN
            U8=U5*Y2(I)
            DERIVS(4)=DERIVS(4)+H*(U2-U1)/100.0
            DERIVS(5)=DERIVS(5)+R*H*U7*(Y(I)*(U6-U8)-U5*X/BETA)/BETA
            DERIVS(6)=DERIVS(6)+H*U3/200.0
            A=U1*(R1*W+PARS(6)/354.49077)*2.0
            DERIVS(3*I+4)=H*(A+R*U7*(U6-2.0*U5*Y(I)))/(1.41421356*WIDTH)
            DERIVS(3*I+5)=H*(W*A+R*U7*(U6*(W-Y(I))+U8*Y(I)))/WIDTH
            DERIVS(3*I+6)=U
         ENDIF

50    CONTINUE
      
      RETURN
      END
C======================================================================

      SUBROUTINE FFIN(CIN,NC,OUT1,OUT2,OUT3,*)

C           free format floating point input routine....
C           up to three real numbers (OUT1, OUT2, OUT3) decoded from CIN....
C           input fields separated by commas or spaces....
C           CIN = input character string          (input, up to char*80)....
C           NC  = no. of valid characters in CIN  (input, integer)....
C           OUT1, OUT2, OUT3 = decoded numbers    (output, real)....
C           RETURN 1: invalid character in CIN....
C                    D.C. Radford   July 1985

      CHARACTER*(*) CIN
      INTEGER       NC
      REAL          OUT1, OUT2, OUT3, OUT(3)
      CHARACTER*81  IN


      IN(1:NC)=CIN(1:NC)
      DO 10 N=1,3
10       OUT(N)=0.0
      IF (NC.LT.1) GO TO 150
      ILO=1
      DO 100 N=1,3
15       IF (IN(ILO:ILO).EQ.' ') THEN
            ILO=ILO+1
            IF (ILO.GT.NC) GO TO 150
            GO TO 15
         ENDIF
         DO 20 I=ILO,NC
20          IF (IN(I:I).EQ.' ' .OR. IN(I:I).EQ.',') GO TO 30
         I=NC+1
30       IN(I:I)=','
         IHI=I-1
         IF (IHI.LT.ILO) GO TO 60
         ITEST=0
         DO 40 I=ILO,IHI
            IF ((IN(I:I).LT.'0' .OR. IN(I:I).GT.'9')
     +          .AND. IN(I:I).NE.'-') THEN
               IF (IN(I:I).NE.'.') GO TO 200
               IF (ITEST.NE.0) GO TO 200
               ITEST=1
            ENDIF
40       CONTINUE
         READ(IN(ILO:IHI),50) OUT(N)
50       FORMAT(F40.0)
60       ILO=IHI+2
         IF (ILO.GT.NC) GO TO 150
100   CONTINUE
150   OUT1=OUT(1)
      OUT2=OUT(2)
      OUT3=OUT(3)
      RETURN
200   OUT1=OUT(1)
      OUT2=OUT(2)
      OUT3=OUT(3)
      RETURN 1
      END
      SUBROUTINE FIGEGA
C Calculates first generation gamma-ray distributions from
C various excitation energies. A full description is found
C in M. Guttormsen et al., NIM A255(1987)518
  
      CHARACTER APP*4, ans*1
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/response1/R(0:511,0:511),RDIM,A0,A1,FWHM
      REAL    SPECi(0:4095),SPECf(0:4095)
      REAL    F(0:4095),G(0:4095),Gtot(0:4095),FG(0:4095)
      REAL    Weight(0:511),Sing(0:511),Mult(0:511),FGold(0:511)
      REAL    Rold(0:511,0:511)
      INTEGER XDIM, YDIM, RDIM
      INTEGER XDIMf, YDIMf, XDIMw, YDIMw
      INTEGER ExpWeight,AreaCorr,StaTot,ReadStatus
      REAL    Nexp,MASta,MATot,MESta,METot
      INTEGER DUMMY

      WRITE(6,*)'The original gamma-matrix should be stored in'
      WRITE(6,*)'the source matrix and the extracted 1.gen. matrix'
      WRITE(6,*)'will appear in the destination spectrum. The last'
      WRITE(6,*)'weighting functions used can be accessed from the'
      WRITE(6,*)'response matrix using the command GR'
      WRITE(6,*)' '

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(Istatus.NE.0)RETURN

C Zeroing spectra
      DO j=0,511
        FGold(j)  = 0.          !First gen. from last iteration 
        Weight(j) = 0.          !Weighting function used
      ENDDO
      DO j=0,511
        DO i=0,511
          R(i,j)    = 0.        !Weighting matrix for all Ex(initial)
          Rold(i,j) = 0.        !The matrix from last iteration
        ENDDO
      ENDDO
      DO i=0,4095
        SPECi(i)  = 0.          !Helping-spectra for streching etc.
        SPECf(i)  = 0.
      ENDDO
      DO j=0,511
        Sing(j) = 0.            !Singles particle strength
        Mult(j) = 0.            !Gamma-ray multiplicities
        sum = 0.
        DO i=0,4095
          rMAT(IDEST,i,j) = 0.  !Destination for extracted first gen. matrix 
          sum = sum + rMAT(ISP,i,j)
        ENDDO
        IF(sum.GT.0.)Sing(j) = 1000.  
        IF(sum.GT.0.)Mult(j) = 2.    
      ENDDO

      XDIMf=Idim(1,ISP,1)    !Index f is for the starting matrix fg = f-g
      YDIMf=Idim(1,ISP,2)    !(later we have index w for weihting-function)

      Ngates     = 0      !Number of excitation bins
      Icontinue  = 1      !Iterate once more
      RDIM       = 512    !Just to give flag that R(i,j) is used
      Iter       = 1      !Number of iterations
      ExH        = 8500.  !Highest excitation energy
      ExpWeight  = 0      !Default not to weight with exp. spectra
      a          = 16.0   !Fermi level density parameter a (1/MeV)
      Nexp       = 4.2    !Exponent for gamma energy
      Norm       = 1      !Default normalization with singles method
      StaTot     = 1      !Choose statistical multiplicity
      ThresSta   = 430.   !with threshold > 430 keV
      ThresTot   = 150.   !Lower exp. threshold for gammas
      ThresRatio = 0.3    !Upper limit = AMIN1(Eg* ThresRatio,ThresSta)
      ExEntry0   = 300.   !Average entry point in ground band
      AreaCorr   = 1      !Correct for areas versus multiplicity
      ReadStatus = 0      !Has not read figegain.dat

      OPEN(23,FILE='figegain.dat',STATUS='old',ERR=777)
      READ(23,*,ERR=666)ExH,Ax0,Ax1,Ay0,Ay1,Ngates
      READ(23,*,ERR=666)ExpWeight,A,Nexp
      READ(23,*,ERR=666)AxW0,AxW1,AyW0,AyW1
      READ(23,*,ERR=666)Norm,StaTot
      READ(23,*,ERR=666)ThresSta,AreaCorr
      READ(23,*,ERR=666)(Sing(i),i=0,Ngates-1)
      READ(23,*,ERR=666)(Mult(i),i=0,Ngates-1)
      ReadStatus=1                  !The most important parameters went OK to read
      READ(23,*,ERR=666)ThresTot,ThresRatio,ExH,ExEntry0 !parameters of new version
      GO TO 777
 666  WRITE(6,*)'Warning: Something wrong with your figegain.dat file'
 777  CLOSE(23)

      bx=cal(1,ISP,1,1)+cal(1,ISP,1,2)+cal(1,ISP,1,3)
      by=cal(1,ISP,2,1)+cal(1,ISP,2,2)+cal(1,ISP,2,3)
      cx=Ax0+Ax1
      cy=Ay0+Ay1
      IF(bx+by.EQ.2.)THEN     
        IF(Ax1+Ay1.EQ.2.)THEN
          Ax0=11.          !In case nothing exist
          Ax1=20.
          Ay0=9660.
          Ay1=-120.
        ENDIF
      ELSE
        Ax0=cal(1,ISP,1,1) !Adobt spectrum calibration
        Ax1=cal(1,ISP,1,2)
        Ay0=cal(1,ISP,2,1)
        Ay1=cal(1,ISP,2,2)
      ENDIF

C If we use another calibration than given in figegain, then these
C data are not valid any more
      IF(cx+cy.NE.bx+by)ReadStatus=0

C Reading various parameters
      WRITE(6,10)
  10  FORMAT(/,'Calibration for gamma-energies:')
      WRITE(6,12)Ax0
  12  FORMAT('Cal. coeff. a0 (keV) on x-axis   <',F8.1,'>:',$)
      CALL READF(5,Ax0)
      WRITE(6,14)Ax1
  14  FORMAT('Cal. coeff. a1 (keV/ch) on x-axis<',F8.1,'>:',$)
      CALL READF(5,Ax1)
      IF(Istatus.NE.0)RETURN
      WRITE(6,16)
  16  FORMAT(/,'Calibration for excitation energies:')
      WRITE(6,18)Ay0
  18  FORMAT('Cal. coeff. a0 (keV) on y-axis   <',F8.1,'>:',$)
      CALL READF(5,Ay0)
      WRITE(6,20)Ay1
  20  FORMAT('Cal. coeff. a1 (keV/ch) on y-axis<',F8.1,'>:',$)
      CALL READF(5,Ay1)
      IF(Istatus.NE.0)RETURN

      Exmax=AMAX1(Ay0+Ay1*0,Ay0+Ay1*(YDIMf-1.))
      IF(ExH.GT.Exmax)THEN
        ExH = Exmax
        ReadStatus = 0  !wrong figegain.dat, should be replaced
      ENDIF
      WRITE(6,22)ExH
  22  FORMAT(/'Excitation energy of highest gate (keV)  <',F8.1,'>:',$)
      CALL READF(5,ExH)                  
      IyH=INT(((ExH-Ay0)/Ay1)+0.5)
      IyL=INT(((0.0-Ay0)/Ay1)+0.5)
      IF(IyH.LT.0)  IyH=0
      IF(IyH.GT.511)IyH=511
      IF(IyL.LT.0)  IyL=0
      IF(IyL.GT.511)IyL=511

      WRITE(6,30)ThresTot
 30   FORMAT('Experimental lower gamma thresholds (keV)  <',F6.0,'>:',$)
      CALL READF(5,ThresTot)
      WRITE(6,32)ThresSta
 32   FORMAT('Upper threshold for nonstat. gammas (keV)  <',F6.0,'>:',$)
      CALL READF(5,ThresSta)
      WRITE(6,36)ThresTot,ThresSta,ThresRatio
 36   FORMAT(/,'It is recommended to use a sliding upper threshold when the',
     +       /,'excitation energy is lower than 1 - 2 MeV. This is performed',
     +       /,'by defining a ratio R, giving Thres=Ex*R with a lower and'
     +       /,'higher limit of',F5.0, ' and',F5.0, ' keV. Use R = 0.2 - 0.3.',
     +     /,/,'Give ratio R           (no sliding = 100.) <',F6.2,'>:',$)
      CALL READF(5,ThresRatio)
      WRITE(6,38)ExEntry0
 38   FORMAT('Average entry point in ground band (keV)   <',F6.0,'>:',$)
      CALL READF(5,ExEntry0)
      LS1=INT(((ThresSta-Ax0)/Ax1)+0.5) ! lower threshold for stat. gammas
      LT1=INT(((ThresTot-Ax0)/Ax1)+0.5) ! lower threshold for total gammas
      IF(LS1.LT.0)LS1=0
      IF(LT1.LT.0)LT1=0
      ExH=Ay0+Ay1*IyH
      ExL=Ay0+Ay1*IyL
      WRITE(6,40)ExH,ExL,IyH,IyL
 40   FORMAT(/,'First geneneration spectra extracted for',
     +       /,'excitation energies between ',F6.0,'-',F6.0,' keV',
     +       /,'corresponding to y-channels ',I5  ,' -',I5  )
      IyStep=+1               !Normally high exc. is low channel
      IF(IyH.GT.IyL)IyStep=-1
      Ngates=IABS(IyH-IyL)+1
     
      WRITE(6,42)
 42   FORMAT(/,'You may read weighting functions from disk')
      ans='y'
      IF(ExpWeight.EQ.0)ans='n'
      WRITE(6,44)ans
 44   FORMAT('Weighting by exp. 1.gen.-spectra from disk (y/n)<',A1,'>:',$)
      CALL READA1(5,ans)
      ExpWeight = 1
      IF(ans.EQ.'n'.OR.ans.EQ.'N')ExpWeight=0
      IF(Istatus.NE.0)RETURN

      IF(ExpWeight.EQ.1) THEN
        WRITE(6,46)
 46     FORMAT(/'Read experimental spectra for weighting. Be careful to choose',
     +        /,'the destination spectrum (1 or 2), where your original ALFNA ',
     +        /,'source matrix DO NOT resides.',/)
        ITYPE=3
        CALL READFILE       !NB, read into rMAT(IDEST), but will be cleared later on
        CALL ERASE
        DUMMY=1
        CALL DSPMA(DUMMY,1,1)
        CALL CLEANUP
        XDIMw=Idim(1,IDEST,1) !Index w is for the weighting function
        YDIMw=Idim(1,IDEST,2) 

        AxW0=cal(1,IDEST,1,1) !Adobt spectrum calibration
        AxW1=cal(1,IDEST,1,2)
        AyW0=cal(1,IDEST,2,1)
        AyW1=cal(1,IDEST,2,2)

        IF(AxW1.EQ.1.OR.AxW1.EQ.0.)THEN
          AxW0=Ax0            !Calibration for weighting spectra
          AxW1=Ax1
        ENDIF
        IF(AyW1.EQ.1.OR.AyW1.EQ.0.)THEN
          AyW0=Ay0
          AyW1=Ay1
        ENDIF
 
        WRITE(6,50)
 50     FORMAT(/,'Give calibration for weighting spectra:',
     1         /,'Calibration for gamma-energies:')
        WRITE(6,12)AxW0
        CALL READF(5,AxW0)
        WRITE(6,14)AxW1
        CALL READF(5,AxW1)

        WRITE(6,52)
 52     FORMAT(/,'Calibration for excitation energies:')
        WRITE(6,18)AyW0
        CALL READF(5,AyW0)
        WRITE(6,20)AyW1
        CALL READF(5,AyW1)

C Compress or stretch spectra in both directions
        DO j=0,YDIMw-1      
          DO i=0,XDIMw-1
            SPECi(i)=rMAT(IDEST,i,j)     !In x-direction
          ENDDO
          CALL ELASTIC(SPECi,SPECf,AxW0,AxW1,0.,ABS(Ay1),XDIMw,512)
          DO i=0,511
            R(i,j)=SPECf(i)
          ENDDO
        ENDDO
        A0=0.       !Saving the calibration in x-direction for responsematrix R(i,j)
        A1=ABS(Ay1)

        DO i=0,4095
           SPECi(i)  = 0. 
        ENDDO
        DO i=0,511       
          DO j=0,YDIMw-1
            SPECi(j)=R(i,j)             !In y-direction
          ENDDO
          CALL ELASTIC(SPECi,SPECf,AyW0,AyW1,Ay0,Ay1,YDIMw,512)
          DO j=0,511
            R(i,j)=SPECf(j)
          ENDDO       
        ENDDO
        DO j=0,511
          DO i=0,4095                   
            rMAT(IDEST,i,j)=0           !Clearing MAT again
          ENDDO
        ENDDO
             
      ELSE             ! or we choose Fermi estimate (calibration is OK)
       
        WRITE(6,60)
 60     FORMAT(/,'Assumes Fermi gas distribution')
        WRITE(6,62)a
 62     FORMAT('Level density parameter a (1/MeV!!)         <',F5.2,'>:',$)
        CALL READF(5,a)
        WRITE(6,64)Nexp
 64     FORMAT('Exponent n for Eg**n                        <',F5.2,'>:',$)
        IF(Istatus.NE.0)RETURN
        CALL READF(5,Nexp)
        DO j=IyH,IyL,IyStep
          Exi=Ay0+Ay1*j
          jjmax=((Exi+200.-0.)/ABS(Ay1))+0.5 !assuming 200 keV extra
          DO jj=0,MIN0(jjmax,511)
            Egam=ABS(Ay1)*jj
            IF(jj.EQ.0)THEN
              Egam=ABS(Ay1)*0.25 !In order to get something in ch 0
            ENDIF
            Exf=Exi-Egam
            IF(Exf.GE.0)THEN
              IF(Egam.LT.50.)Egam=50.
              IF(Exf.LT.300.)Exf=300.
              Egam=Egam/1000.      !Going to MeV not to get too
              Exf=Exf/1000.        !large numbers for RESP
              IF(jj.LT.512.AND.j.LT.512)THEN
                R(jj,j)=((Egam**Nexp)*EXP(2.*SQRT(a*Exf)))/(Exf**2.)
              ENDIF
            ENDIF
          ENDDO
        ENDDO 
      ENDIF

      WRITE(6,66)Norm
 66   FORMAT(/'Singles (1) or multiplicity (2) normalization   <',I1,'>:',$)
      CALL READI(5,Norm)
      IF(Istatus.NE.0)RETURN

      IF(Norm.EQ.2)THEN
        WRITE(6,68)StaTot
 68     FORMAT('Statistical (1) or total (2) multiplicity       <',I1,'>:',$)
        CALL READI(5,StaTot)
        IF(Istatus.NE.0)RETURN
      ENDIF

      ans='y'
      WRITE(6,70)ans
 70   FORMAT('Areacorrection for 1st generationspectra (y/n)  <',A1,'>:',$)
      CALL READA1(5,ans)
      IF(Istatus.NE.0)RETURN
      IF(ans.EQ.'y'.OR.ans.EQ.'Y')AreaCorr=1
      IF(ans.EQ.'n'.OR.ans.EQ.'N')AreaCorr=0

C Setting up reasonable multiplicities
      ans='n'
      IF(ReadStatus.EQ.0)ans='y'
      WRITE(6,72)ans
 72   FORMAT(/'Estimate new default multiplicities M(Ex) (y/n)',
     +      /,'WARNING: If answer = y, the multiplicities',
     +      /,'in the file figegain.dat will be overwritten    <',A1,'>:',$)
      CALL READA1(5,ans)
      IF(Istatus.NE.0)RETURN
      IF(ans.EQ.'y'.OR.ans.EQ.'Y')THEN
        DO j=0,Ngates-1
          Mult(j)=0.
        ENDDO
        jj=IyH
        DO j=0,Ngates-1
          xm=0.
          CenS=0.
          sum=0.
          Exj=Ay0+Ay1*jj
          LF2=INT(((Exj+200.-Ax0)/Ax1)+0.5)               
          IF(LF2.GT.XDIMf-1)LF2=XDIMf-1
          L1=MAX0(0,INT(((SLIDE(Exj,ThresTot,ThresSta,ThresRatio)-Ax0)/Ax1)+0.5))
          IF(StaTot.EQ.2)L1=LT1
          DO i=L1,LF2
            CenS=CenS+FLOAT(i)*rMAT(ISP,i,jj)
            sum =sum + rMAT(ISP,i,jj)
          ENDDO
          IF(sum.GT.0.)CenS=CenS/sum
          IF(CenS.GT.0)THEN
            CenS=Ax0+CenS*Ax1
            ExEntry=AMIN1(ExEntry0,Exj-200.)
            IF(ExEntry.LT.0.)ExEntry=0.
            xm=(Exj-ExEntry)/CenS
          ENDIF
          IF(xm.LT.0)xm=0.
          Mult(j)=xm
          jj=jj+IyStep
        ENDDO
      ENDIF

      IF(Norm.EQ.2) THEN
        WRITE(6,74)
 74     FORMAT(/' Multiplicity in each gate: ')
        WRITE(6,76)
 76     FORMAT(' -----------------------------------')
        Exx=ExH
        DO i=0,Ngates-1
          iCh=((Exx-Ay0)/Ay1)+0.5
          WRITE(6,78)iCh,Exx,Mult(i)
 78       FORMAT(' Y-ch=',I4,' Ex= ',F7.1,' keV <',F6.3,'>:',$)
          CALL READF(5,Mult(i))
          IF(Istatus.NE.0)RETURN
          Exx=Exx-ABS(Ay1)
        ENDDO
        WRITE(6,*)CHAR(7)                        ! Bell
        WRITE(6,76)
      ENDIF

      IF(Norm.EQ.1) THEN
        WRITE(6,80)
 80     FORMAT(/' Area of slices in singles: ')
        WRITE(6,76)
        Exx=ExH
        DO i=0,Ngates-1
          iCh=((Exx-Ay0)/Ay1)+0.5
          WRITE(6,82)iCh,Exx,Sing(i)
 82       FORMAT(' Y-ch=',I4,' Ex= ',F7.1,' keV <',F8.1,'>:',$)
          CALL READF(5,Sing(i))
          IF(Istatus.NE.0)RETURN
          Exx=Exx-ABS(Ay1)
        ENDDO
        WRITE(6,*)CHAR(7)
        WRITE(6,76)
      ENDIF
      IF(Istatus.NE.0)RETURN

C Writes to disk, so that it is easier to re-run the program
      OPEN(23,FILE='figegain.dat',ERR=888)
      WRITE(23,*)ExH,Ax0,Ax1,Ay0,Ay1,Ngates
      WRITE(23,*)ExpWeight,A,Nexp
      WRITE(23,*)AxW0,AxW1,AyW0,AyW1
      WRITE(23,*)Norm,StaTot
      WRITE(23,*)ThresSta,AreaCorr
      WRITE(23,*)(Sing(i),i=0,Ngates-1)
      WRITE(23,*)(Mult(i),i=0,Ngates-1)
      WRITE(23,*)ThresTot,ThresRatio,ExH,ExEntry0
      CLOSE(23)
888   CONTINUE

100   FORMAT('----------------------------------------------')

C Writting out parameters
      OPEN(UNIT=21,FILE='figegaout.dat',ERR=1001)
      GO TO 1002
1001  ifile=0
      GO TO 1111
1002  ifile=1
      WRITE(21,*)'Parameters used:'
      WRITE(21,40)ExH,ExL,IyH,IyL
      WRITE(21,102)Ngates
102   FORMAT(' Number of spectra=',I5)
      WRITE(21,104)Ax0,Ax1,Ay0,Ay1
104   FORMAT(' Ax0 =',F8.1,' Ax1 =',F8.1,' Ay0 =',F8.1,' Ay1 =',F8.1)
      WRITE(21,106)AxW0,AxW1,AyW0,AyW1
106   FORMAT(' AxW0=',F8.1,' AxW1=',F8.1,' AyW0=',F8.1,' AyW1=',F8.1)
      WRITE(21,108)ExpWeight,a,Nexp
108   FORMAT(' Weighting:',I2,' Level density parameter a=',F4.1,' Exponent n=',F3.1)
      WRITE(21,110)Norm,StaTot,AreaCorr
110   FORMAT(' Normalization=',I2,' Stat/Tot=',I2,' Areacorr.=',I2)
      WRITE(21,112)ThresTot,LT1,ThresSta,LS1, ThresRatio
112   FORMAT(' Experimental lower gamma threshold:     ',F6.1,' keV (ch=',I4,')',
     +     /,' Upper threshold for statistical gammas: ',F6.1,' keV (ch=',I4,')',
     +     /,' Sliding threshold given by Ex*R, with R = ',F4.2)
      WRITE(21,114)ExEntry0
114   FORMAT(' Average energy entry point in ground band ExEntry =',F6.0,' keV')
      WRITE(21,*)'Multiplicities: MA = Af/Afg and ME = (Ex-ExEntry)/<Eg>'
      WRITE(6,*)' '
      
C****************************************************************
C                        Fasten seatbelts                       *
C                                                               *
C****************************************************************

 1111 CONTINUE
      WRITE(6,116)Iter
      IF(ifile.EQ.1)WRITE(21,116)Iter
 116  FORMAT(/,'Iteration number: ',I3)
      IF(ifile.EQ.1)WRITE(21,121) 
      DO j=IyH,IyL,IyStep
        Ij=ABS(j-IyH)        !The index for Mult and Sing
        Exj=Ay0+Ay1*j        !The exc. energy for uppermost spectrum
        LW2=ABS(j-IyL)                
        DO i=0,XDIMf-1
          SPECi(i)=0.
          F(i)=rMAT(ISP,i,j) !The uppermost spectrum
          FG(i)=0.
          Gtot(i)=0.
        ENDDO
        DO jj=0,YDIMf-1
          IF(Iter.LT.4)THEN
            Weight(jj)=R(jj,j)
          ELSE
            Weight(jj)=Rold(jj,j)+R(jj,j)      !New, to prevent oscillations
          ENDIF
          IF(Weight(jj).LT.0.)Weight(jj)=0.    !New, to prevent negative weights
          Rold(jj,j)=R(jj,j)
        ENDDO
        DUMMY=0
        CALL INTEG(Weight,sumW,DUMMY,LW2)
        DO jj=0, LW2
          IF(sumW.GT.0.)THEN                   !Normalizing to 1.0
            Weight(jj)=Weight(jj)/sumW
          ELSE
            Weight(jj)=0.
          ENDIF
          IF(jj.GE.Ngates)Weight(jj)=0.
          R(jj,j)=Weight(jj)
        ENDDO
       
        LF2=INT(((Exj+200.-Ax0)/Ax1)+0.5)      !Taking 200keV extra                
        IF(LF2.GT.XDIMf-1)LF2=XDIMf-1
        LF1=MAX0(0,INT(((SLIDE(Exj,ThresTot,ThresSta,ThresRatio)-Ax0)/Ax1)+0.5))
        CALL INTEG(F,sumF,LF1,LF2)             !Integr. of F(i) between LF1->LF2
       
        JJ1=j
        JJ2=IyL
        Ijj=Ij-1                               !Index for Mult and Sing below
        iii=-1                                 !Index for Weight(iii)
c               if(jj1.EQ.55)write(6,*)j,jj1,jj2,Ij,mult(ij),Ijj,lf1,lf2
        DO jj=JJ1,JJ2,IyStep
          Ijj=Ijj+1
          iii=iii+1
          Exjj=Ay0+Ay1*jj                      !The exc. energy for G(i)
          LG2=INT(((Exjj+200.-Ax0)/Ax1)+0.5)
          IF(LG2.GT.XDIMf-1)LG2=XDIMf-1
          DO i=0,LG2
            G(i)=rMAT(ISP,i,jj)
          ENDDO
          LG1=MAX0(0,INT(((SLIDE(Exjj,ThresTot,ThresSta,ThresRatio)-Ax0)/Ax1)+0.5))
          CALL INTEG(G,sumG,LG1,LG2)
          fact=0.
          IF(Norm.EQ.1)THEN                    !Singles normalization
            x=Sing(Ijj)
            IF(x.GT.0.)fact=Weight(iii)*Sing(Ij)/x
          ELSE                                 !Multiplicity normalization
            x=Mult(Ij)*sumG
            IF(x.GT.0.)fact=Weight(iii)*Mult(Ijj)*sumF/x
c                 if(jj1.EQ.55)write(6,*)ijj,mult(ijj),lg1,lg2,iii,weight(iii)
          ENDIF
          DO i=0,LG2                           !Making Gtot(i), which shall
            Gtot(i)=Gtot(i)+fact*G(i)          !be subtracted from F(i)
          ENDDO
        ENDDO

C Calculates areacorrection alpha (see NIM A255 (1987) 518 eq.(7)) 
        alpha=1.0
        CALL INTEG(Gtot,sumGtot,LF1,LF2) !Same limits as for F(i)
        IF (AreaCorr.EQ.1.AND.sumGtot.GT.0) THEN
          alpha=(1.-(1./Mult(Ij)))*sumF/sumGtot
          IF(alpha.LT.0.85)alpha=0.85
          IF(alpha.GT.1.15)alpha=1.15
        ENDIF

C Performing the subtraction
        DO i=0, XDIMf-1
          FG(i) = F(i)-alpha*Gtot(i)
          rMAT(IDEST,i,j)=FG(i)          !Finished, storing in MAT
        ENDDO

C Prepairing for writting to figegaout.dat
C FG contains now the first generation spectrum for Ex=Exj
C Calculating statistical multiplicity from AF/AF-AG and (Ex-ExEntry)/Egamma
C in case of threshold of Thres keV
C Calculates centroides using:
        MASta=0.
        MATot=0.
        MESta=0.
        METot=0.
        CALL INTEG(F, sumFS, LF1,LF2)
        CALL INTEG(FG,sumFGS,LF1,LF2)
        CALL INTEG(F, sumFT, LT1,LF2)
        CALL INTEG(FG,sumFGT,LT1,LF2)
        IF(sumFGS.GT.0)MASta=sumFS/sumFGS   
        IF(sumFGT.GT.0)MATot=sumFT/sumFGT

        CenS=0.                         !Energy centroid of FG statistical
        DO i=LF1,LF2
          CenS=CenS+F(i)*FLOAT(i)
        ENDDO
        IF(sumFS.GT.0)CenS=CenS/sumFS
        IF(CenS.GT.0)THEN
          CenS=Ax0+CenS*Ax1
          ExEntry=AMIN1(ExEntry0,Exj-200.)
          IF(ExEntry.LT.0.)ExEntry=0.
          MESta=(Exj-ExEntry)/CenS
        ENDIF
        IF(MESta.LT.0)MESta=0.

        CenT=0.                          !Energy centroid of FG total
        DO i=LT1,LF2
          CenT=CenT+F(i)*FLOAT(i)
        ENDDO
        IF(sumFT.GT.0)CenT=CenT/sumFT
        IF(CenT.GT.0)THEN
          CenT=Ax0+CenT*Ax1
          ExEntry=AMIN1(ExEntry0,Exj-200.)
          IF(ExEntry.LT.0.)ExEntry=0.
          METot=(Exj-ExEntry)/CenT
        ENDIF
        IF(METot.LT.0)METot=0.

        CALL INTEG(F,   sumF,   LF1,LF2)
        CALL INTEG(Gtot,sumGtot,LF1,LF2)
        CALL INTEG(FG,  sumFG,  LF1,LF2)
        IF  = sumF     + 0.5
        IG  = sumGtot  + 0.5
        IFG = sumFG    + 0.5
        IS  = Sing(Ij) + 0.5
        dAA = 9999.99
        IF(FGold(j).GT.0.)dAA=100.*(sumFG - FGold(j)) / FGold(j)
        IF(ABS(dAA).GT.9999.99)dAA=9999.99
        WRITE(6,120)j,sumFG,dAA
120     FORMAT('Y-ch= ',I3,'  Area= ',F11.1,'  dA/A(%)= ',F8.2)
121     FORMAT('Y-ch  Ex     Af     Ag    Afg  Mult   Sing Alpha',
     +         ' MATot METot MASta MESta')
        IF(ifile.EQ.1)WRITE(21,122)j,Exj,IF,IG,IFG,Mult(Ij),IS,alpha,MATot,METot,MASta,MESta
122     FORMAT(I3,F6.0,3I7,F5.2,I7,5F6.2)
        FGold(j)=sumFG
      ENDDO
      XDIM  = XDIMf
      YDIM  = YDIMf
      ITYPE = 3
      CALL ERASE
      DUMMY=1
      CALL DSPMA(DUMMY,1,1)
      CALL CLEANUP
      cal(1,IDEST,1,1)=Ax0
      cal(1,IDEST,1,2)=Ax1
      cal(1,IDEST,1,3)=0
      cal(1,IDEST,2,1)=Ay0
      cal(1,IDEST,2,2)=Ay1
      cal(1,IDEST,2,3)=0

      WRITE(6,100)

      IF(Iter.EQ.1) WRITE(6,124)
 124    FORMAT(' You may now iterate on the last first-',/,
     +         ' generation spectra just obtained. Remember,the',/,
     +         ' input spectra must be of unfolded type.',/,
     +         ' WARNING! Your first-generation spectra just',/,
     +         ' obtained, will be overwritten by the new one',/,
     +         ' for each iteration.',//)


      WRITE(6,126)Icontinue
 126  FORMAT(/' Iterate (1) or stop (0)  <',I1,'>:',$)
      CALL READI(5,Icontinue)
     
      IF(Icontinue.EQ.1)THEN
C Reading in the 1.gen. spectra just obtain from rMAT(IDEST,i,j) to
C the new weighting matrix R(i,j). Then compress or stretch the
C spectra in x-directions (y-direction OK).
        Iter=Iter+1
        DO i=0,4095
          SPECi(i)  = 0. 
        ENDDO
        DO j=IyH,IyL,IyStep      
          DO i=0,XDIMf-1
            SPECi(i)=rMAT(IDEST,i,j)    !In x-direction
          ENDDO
          CALL ELASTIC(SPECi,SPECf,Ax0,Ax1,0.,ABS(Ay1),XDIMf,512)
          DO i=0,511
            R(i,j)=SPECf(i)             !R(i,j) now contain new weighting
          ENDDO
        ENDDO
        DO i = 0, 4095
          SPECi(i) = 0.
          DO j=0, 511
            rMAT(IDEST,i,j) = 0.        !Clearing MAT again
          ENDDO
        ENDDO
        GO TO 1111                      !New iteration starts

      ELSE

        CLOSE(21)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='FG:'
        fname(1,IDEST)(1:8)='FG'//fname(1,ISP)(1:6)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
        WRITE(6,128)Iter,IDEST
 128    FORMAT('Last iteration',I3, ' stored in matrix',I2,/,
     +         'Additional results written to figegaout.dat')
        RETURN
      ENDIF
 9999 WRITE(6,*) 'Problems to write on disk'
      END


      SUBROUTINE INTEG(Sp,sum,L1,L2)
C Integrates SPEC from L1 to L2 and return area
      DIMENSION Sp(0:L2)
      sum=0.0
      IF(L1.LT.0)L1=0
      IF(L1.GT.L2)RETURN
      DO i=L1,L2
        sum = sum + Sp(i)
      ENDDO
      RETURN
      END


      FUNCTION SLIDE(Ex,Thres1,Thres2,ThresRatio)
      SLIDE=ThresRatio*Ex
      IF(SLIDE.LT.Thres1)SLIDE=Thres1
      IF(SLIDE.GT.Thres2)SLIDE=Thres2
      RETURN
      END

C=======================================================================

      SUBROUTINE FITTER(MAXITS,IALT_RET)

C        this subroutine is a modified version of 'CURFIT', in Bevington....
C        ....see page 237....

C          designed for use with GF2, Version IV
C          D.C. Radford        March 1984

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60


      INTEGER         IWMODE
      CHARACTER*8     NWTSP
      REAL            WTSP(8192)
      COMMON /WTMODE/ IWMODE,NWTSP,WTSP

      REAL           DERIVS(51)
      COMMON /DERIV/ DERIVS

      REAL         BETA(51),DELTA(51),B(51),ERS(51),FIXED(51)
      INTEGER      NEXTP(51)
      LOGICAL      CONV,TEST,RWFIXED,RPFIXED
      REAL*8       ARRAY(51,51),ALPHA(51,51),DDAT,FLAMDA

      CHARACTER*12 WTC(3)
      CHARACTER*12 DATTIM

      COMMON /LUS/ IR,IW,IP,IG

      DATA         WTC /'fit.','data.','sp. '/


      IALT_RET=0
      ILO=MCH(1)+1
      IHI=MCH(2)+1
      NIP=NPARS-NFP
C            NIP=no. of independent (non-fixed) pars
C            NFP=no. of fixed pars
C            NPARS=total no. of pars = 3 * no.of peaks + 6
C            NDF=no. of degrees of freedom....

      IF (IWMODE.GT.0) WTC(3)(5:12) = NWTSP

      DO I=7,NPARS
         FIXED(I)=IFIXED(I)
      ENDDO

C           set up fixed relative widths....

      RWFIXED=.FALSE.
      IF (IRELW.LE.0) THEN
         NIW=0
         DO 20 J=8,NPARS-1,3
            IF (IFIXED(J).EQ.1) MIW=J
C                MIW=highest fitted (non-fixed) width par. no.....
            NIW=NIW+IFIXED(J)
20       CONTINUE
C                NIW=no. of fitted (non-fixed) widths....
         IF (NIW.GT.1) THEN
            DO J=8,MIW,3
               IFIXED(J)=0
            ENDDO
            RWFIXED=.TRUE.
            NIP=NIP-NIW+1
            NIP1=NIP
         ENDIF
      ENDIF

C           set up fixed relative positions....

      RPFIXED=.FALSE.
      IF (IRELPOS.LE.0) THEN
         NIPOS=0
         DO 40 J=7,NPARS-2,3
            IF (IFIXED(J).EQ.1) MIP=J
C                MIP=highest fitted (non-fixed) position par. no.....
            NIPOS=NIPOS+IFIXED(J)
40       CONTINUE
C                NIPOS=no. of fitted (non-fixed) positions....
         IF (NIPOS.GT.1) THEN
            DO J=7,MIP,3
               IFIXED(J)=0
            ENDDO
            RPFIXED=.TRUE.
            NIP=NIP-NIPOS+1
            NIP1=NIP-1
         ENDIF
      ENDIF

      NDF=IHI-ILO+1-NIP
      IF (NDF.LT.1) GO TO 510
      IF (NIP.LT.2) GO TO 530

C          set up array nextp, pointing to free pars....

      K=0
      DO 50 J=1,NPARS
         IF (IFIXED(J).EQ.0) GO TO 50
         K=K+1
         NEXTP(K)=J
50    CONTINUE
      IF (RWFIXED) THEN
         K=K+1
         NEXTP(K)=MIW
      ENDIF
      IF (RPFIXED) THEN
         K=K+1
         NEXTP(K)=MIP
      ENDIF
      IF (K.NE.NIP) GO TO 570

C           initialise for fitting....

      FLAMDA=0.001
      NITS=0
      TEST=.FALSE.
      DERIVS(1)=1.0
      DO 60 I=1,NPARS
         ERRS(I)=0.0
         B(I)=PARS(I)
60    CONTINUE

C        evaluate fit, alpha & beta matrices, & chisq....
70    DO 80 J=1,NIP
         BETA(J)=0.0
         DO 75 K=1,J
            ALPHA(J,K)=0.0
75       CONTINUE
80    CONTINUE

      CHISQ1=0.0
      CALL EVAL(PARS,IFIXED(4),FIT,NPKS,-9)
      DO 180 I=ILO,IHI
         CALL EVAL(PARS,I,FIT,NPKS,1)
         DIFF=rSPEC(IDEST,I-1)-FIT
         
C          weight with fit/data/weight sp. for iwmode=-1/0/1....
         IF (IWMODE.LT.0) THEN
            DAT=FIT
         ELSEIF (IWMODE.EQ.0) THEN
            DAT=rSPEC(IDEST,I-1)
         ELSE
            DAT=WTSP(I)
         ENDIF
         IF (DAT.LT.1.0) DAT=1.0
         DDAT=DBLE(DAT)
         CHISQ1=CHISQ1+DIFF*DIFF/DAT
         IF (RWFIXED) THEN
            DO 140 K=8,MIW-3,3
               DERIVS(MIW)=DERIVS(MIW)+FIXED(K)*DERIVS(K)
140         CONTINUE
         ENDIF
         IF (RPFIXED) THEN
            DO 150 K=7,MIP-3,3
               DERIVS(MIP)=DERIVS(MIP)+FIXED(K)*DERIVS(K)
150         CONTINUE
         ENDIF
         DO 170 L=1,NIP
            J=NEXTP(L)
            BETA(L)=BETA(L)+DIFF*DERIVS(J)/DAT
            DO 160 M=1,L
               ALPHA(L,M) = ALPHA(L,M)
     +            + DBLE(DERIVS(J))*DBLE(DERIVS(NEXTP(M)))/DDAT
160         CONTINUE
170      CONTINUE
180   CONTINUE
      CHISQ1=CHISQ1/FLOAT(NDF)
     
C        invert modified curvature matrix to find new parameters....

190   ARRAY(1,1)=1.0D0+FLAMDA
      DO 210 J=2,NIP
         DO 200 K=1,J-1
            IF (ALPHA(J,J)*ALPHA(K,K).EQ.0.0D0) GO TO 590
            ARRAY(J,K)=ALPHA(J,K)/DSQRT(ALPHA(J,J)*ALPHA(K,K))
            ARRAY(K,J)=ARRAY(J,K)
200      CONTINUE
         ARRAY(J,J)=1.0D0+FLAMDA
210   CONTINUE

      CALL MATINV(ARRAY,NIP,51)
      IF (TEST) GO TO 350
      DO 240 J=1,NIP
         IF (ALPHA(J,J)*ALPHA(J,J).EQ.0.0D0) GO TO 590
         DELTA(J)=0.0
         DO 230 K=1,NIP
            DELTA(J) = DELTA(J)+ BETA(K)*ARRAY(J,K)/DSQRT(ALPHA(J,J)*ALPHA(K,K))
230      CONTINUE
240   CONTINUE

C              calculate new par. values....

      DO 260 L=1,NIP
         J=NEXTP(L)
         B(J)=PARS(J)+DELTA(L)
260   CONTINUE

      IF (RWFIXED) THEN
         DO 270 J=8,MIW-3,3
            B(J)=PARS(J)+FIXED(J)*DELTA(NIP1)
270      CONTINUE
      ENDIF
      IF (RPFIXED) THEN
         DO 290 J=7,MIP-3,3
            B(J)=PARS(J)+FIXED(J)*DELTA(NIP)
290      CONTINUE
      ENDIF

C         if chisq increased, increase flamda and try again....

      CHISQ=0.0
      CALL EVAL(B,IFIXED(4),FIT,NPKS,-9)
      DO 340 I=ILO,IHI
         CALL EVAL(B,I,FIT,NPKS,0)
         DIFF=rSPEC(IDEST,I-1)-FIT
C          weight with fit/data/weight sp. for iwmode=-1/0/1....
         IF (IWMODE.LT.0) THEN
            DAT=FIT
         ELSEIF (IWMODE.EQ.0) THEN
            DAT=rSPEC(IDEST,I-1)
         ELSE
            DAT=WTSP(I)
         ENDIF
         IF (DAT.LT.1.0) DAT=1.0
         CHISQ=CHISQ+DIFF*DIFF/DAT
340   CONTINUE
      CHISQ=CHISQ/FLOAT(NDF)
      IF (CHISQ.GT.CHISQ1 .AND. FLAMDA.LT.2.0) THEN
         FLAMDA=FLAMDA*10.0
         GO TO 190
      ENDIF

C        evaluate parameters and errors....
C        test for convergence....

350   CONV=.TRUE.
      DO 360 J=1,NIP
         IF (ARRAY(J,J).LT.0.D0) ARRAY(J,J)=0.D0
         ERS(J)=DSQRT(ARRAY(J,J)/ALPHA(J,J))*SQRT(1.0+FLAMDA)
         IF (ABS(DELTA(J)).GE.(ERS(J)/100.)) CONV=.FALSE.
360   CONTINUE

      IF (.NOT.TEST) THEN
         DO J=1,NPARS
            PARS(J)=B(J)
         ENDDO
         FLAMDA=FLAMDA/10.0
         NITS=NITS+1
         IF ((.NOT.CONV) .AND. NITS.LT.MAXITS) GO TO 70

C             re-do matrix inversion with FLAMDA=0
C                  to calculate errors....

         FLAMDA=0.
         TEST=.TRUE.
         GO TO 190
      ENDIF

C          list data and exit....

      DO L=1,NIP
         ERRS(NEXTP(L))=ERS(L)
      ENDDO
      IF (RWFIXED) THEN
         DO 400 J=8,MIW,3
            IFIXED(J)=FIXED(J)
            ERRS(J)=FIXED(J)*ERS(NIP1)
400      CONTINUE
      ENDIF
      IF (RPFIXED) THEN
         DO 410 J=7,MIP,3
            IFIXED(J)=FIXED(J)
            ERRS(J)=FIXED(J)*ERS(NIP)
410      CONTINUE
      ENDIF

      WRITE(6,*)' '
      CALL DATETIME(DATTIM)
      WRITE(IW,420,ERR=430)fname(2,IDEST),DATTIM,MCH,NPKS,NIP,NDF,WTC(IWMODE+2)
420   FORMAT('File ',A,5X,A/
     +'Fitted chs',I5,' to',I5,I8,' Peaks'/I4,
     +' indept. pars',I7,' degrees of freedom weighted with ',3A4)


430   IF (RPFIXED.AND.RWFIXED) THEN
         WRITE(IW,*) 'Relative peak positions and widths fixed.'
      ELSEIF (RPFIXED) THEN
         WRITE(IW,*) 'Relative peak positions fixed.'
      ELSEIF (RWFIXED) THEN
         WRITE(IW,*) 'Relative widths fixed.'
      ENDIF

      IF (CONV) THEN
         WRITE(IW,440,ERR=450)NITS,CHISQ
440      FORMAT(1X,I3,' iterations,  Chisq/d.o.f.= ',F6.3)
450      RETURN
      ENDIF

      WRITE(IW,500,ERR=505)NITS,CHISQ
500   FORMAT(' Failed to converge after',I3,' iterations,  Chisq/',
     +'d.o.f.= ',F6.3/'    Warning - do not believe quoted errors.')
505   IALT_RET=2
      RETURN 

C       error messages....

510   WRITE(IW,*) 'No d.o.f.'
      GO TO 550
530   WRITE(IW,*) 'Too many fixed pars.'
550   IF (RWFIXED.OR.RPFIXED) THEN
         DO 560 I=7,NPARS
            IFIXED(I)=FIXED(I)
560      CONTINUE
      ENDIF
      IALT_RET=1
      RETURN 
570   WRITE(IW,*) 'NIP.NE.sum(IFIXED)'
      GO TO 550
590   WRITE(IW,*) 'Cannot - diag. element eq. to zero.'
      GO TO 550
      END

C=======================================================================

      SUBROUTINE FIX_PARA(PARAM,FIX_FLAG)
      
C     fixes or frees, depending on the value of FIX_FLAG, 
C     a parameter to an inputed value....
C     CALLED by FIXORFREE
      
      INTEGER PARAM
      LOGICAL FIX_FLAG
      
      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS
      
      LOGICAL         DISP
      INTEGER         LOCH,HICH,LOCNT,NCHS,NCNTS,IYAXIS,LOX,NUMX
      COMMON /DISPLA/ DISP,LOCH,HICH,LOCNT,NCHS,NCNTS,IYAXIS,LOX,NUMX
      
      CHARACTER*80 ANS
      COMMON /LUS/ IR,IW,IP,IG
      
      
      IF (FIX_FLAG) THEN
C                 fix parameter....
         IF (PARAM.LE.0) THEN
C                 no input or negative number so....
            RETURN
         ELSEIF (PARAM.EQ.101) THEN
            IRELPOS = 0
            WRITE (IW,*) 'Relative peak positions fixed.'
         ELSEIF (PARAM.EQ.102) THEN
            IRELW = 0
            WRITE (IW,*) 'Relative widths fixed.'
         ELSEIF (PARAM.GT.NPARS) THEN
            WRITE (IW,*) 'Parameter number too large, try again.'
         ELSEIF ((NFP+IFIXED(PARAM)).EQ.(NPARS-1)) THEN
            WRITE (IW,*) '     Cannot - too many fixed pars.'

         ELSE
            NFP = NFP + IFIXED(PARAM)
            IFIXED(PARAM) = 0
 60         CALL CASK('Value=?(rtn for present value)',ANS,NC)
            IF (NC.GT.0) THEN
               CALL FFIN(ANS,NC,VAL,RJ1,RJ2,IALT_RET)
               IF (IALT_RET.EQ.1) GO TO 60
               IF (VAL.EQ.0.0 .AND.
C                    ...    .AND. if PARAM is a width or beta....
     +             ((PARAM+1)/3)*3.EQ.PARAM+1 .AND. PARAM.NE.2) THEN
                  WRITE (IW,*) 'Value must be nonzero.'
                  GO TO 60
               ENDIF
            ELSE
               VAL = PARS(PARAM)
            ENDIF

            IF (PARAM.NE.4 .OR. VAL.NE.0.0) THEN
               PARS(PARAM) = VAL
            ELSEIF ((NFP+IFIXED(5)).EQ.(NPARS-1)) THEN
               WRITE (IW,*) '     Cannot - too many fixed pars.'
               GO TO 60
            ELSE
               NFP = NFP + IFIXED(5)
               IFIXED(5) = 0
               WRITE (IW,'(A,F10.3)') ' >>> Beta fixed at',PARS(5)
               PARS(PARAM) = VAL
            ENDIF
         ENDIF
      
      ELSE
C                 free parameter....

         IF (PARAM.GT.0) THEN
            IF (PARAM.EQ.101) THEN
               IRELPOS = 1
               WRITE (IW,*) 'Relative peak positions free to vary.'
            ELSEIF (PARAM.EQ.102) THEN
               IRELW = 1
               WRITE (IW,*) 'Relative widths free to vary.'
            ELSEIF (PARAM.GT.NPARS) THEN
               WRITE (IW,*) 'Parameter number too large, try again.'
            ELSE
               NFP = IFIXED(PARAM) + NFP - 1
               IFIXED(PARAM) = 1
            ENDIF
         ENDIF
         
      ENDIF
      RETURN
      END

C=======================================================================

      SUBROUTINE FIXORFREE(COMMAND,NC)

C        Fixs or frees the parameters, PARS or the Relative Widths
C        and/or Relative Peak positions.
C        INPUT:          COMMAND, NC
C        OUTPUT: changes IFIXED, IRELW, IRELPOS, PARS, NFP.
C        CALLed by GFEXEC and GFSET.

      INTEGER      NC
      CHARACTER*80 COMMAND, ANS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

C        local variables....
      LOGICAL        NEED_PARA, ERR_FLG, FIX
      CHARACTER*80   PNIN
      INTEGER        PARAM

      CHARACTER*4    FIXTAG(51)
      CHARACTER*3    PARC(51)

      COMMON /LUS/ IR,IW,IP,IG

      DATA           PARC
     +           /' A ',' B ',' C ',' R ','BTA','STP','P1 ','W1 ','H1 ',
     +            'P2 ','W2 ','H2 ','P3 ','W3 ','H3 ','P4 ','W4 ','H4 ',
     +            'P5 ','W5 ','H5 ','P6 ','W6 ','H6 ','P7 ','W7 ','H7 ',
     +            'P8 ','W8 ','H8 ','P9 ','W9 ','H9 ','PA ','WA ','HA ',
     +            'PB ','WB ','HB ','PC ','WC ','HC ','PD ','WD ','HD ',
     +            'PE ','WE ','HE ','PF ','WF ','HF '/


C            command = FT  FX  FR

      IF (COMMAND(1:2).EQ.'FT') THEN
C            asking for fixed parameter(s) to set up a fit...
         FIX = .TRUE.
      ELSEIF (COMMAND(1:2).EQ.'FX') THEN
         FIX = .TRUE.
      ELSEIF (COMMAND(1:2).EQ.'FR') THEN
         FIX = .FALSE. 
      ELSE
         WRITE(IW,*) 'FIXORFREE called with bad COMMAND, ',
     +        COMMAND
         CALL EXIT
      ENDIF 

10    IF (NC.GT.2) THEN
C           parameter specified in command line....

         NEED_PARA = .FALSE.
C           strip off two letter command....
         PNIN(1:78) = COMMAND(3:80)
         PNIN(79:80) = '  '
         ANS = PNIN
         NC = NC - 2

      ELSE
C           no parameter specified in command line....
C           list name and status of the parameters....

         NEED_PARA = .TRUE.
         DO 20 I = 1, NPARS
            IF (IFIXED(I).EQ.0) THEN
               FIXTAG(I) = '  * '
            ELSE
               WRITE (FIXTAG(I),'(1X,I2,1X)') I
            ENDIF
20       CONTINUE
         LO = 1
         IF (NPARS.GT.27) THEN
            WRITE (IW,'(2X,27A4)') (FIXTAG(I),I = LO,27)
            WRITE (IW,'(3X,27(A3,1X))') (PARC(I),I = LO,27)
            LO = 28
         ENDIF
         WRITE (IW,'(2X,27A4)') (FIXTAG(I),I = LO,NPARS)
         WRITE (IW,'(3X,27(A3,1X))') (PARC(I),I = LO,NPARS)
      ENDIF

      IF (FIX) THEN
C           fix parameter(s)....

         IF (NEED_PARA) WRITE (IW,*) 
     +           'Parameters to be fixed =? (one per line,RTN to end)'
30       IF (NEED_PARA) THEN
            CALL CASK('>',PNIN,NC)
            IF (NC.LT.1) RETURN
         ENDIF

         ANS = PNIN
C           pull N out of PNIN....
         CALL ININ_FLG(PNIN,NC,PARAM,J1,J2,ERR_FLG)
         IF (ERR_FLG) THEN
            CALL PARA2NUM(ANS,PARAM,ERR_FLG)
         ENDIF
         IF (ERR_FLG) THEN
            WRITE (IW,*) 'Parameter unknown, try again.'
            IF (.NOT. NEED_PARA) THEN
c                 pretend that ANS = 'FX       '....
               NC = 2
               GO TO 10
            ENDIF
            GO TO 30
         ENDIF
         CALL FIX_PARA(PARAM,FIX)

C           get next parameter to be fixed....
         IF (NEED_PARA) GO TO 30

      ELSE
C           free parameter(s)....

         IF (NEED_PARA)
     +        WRITE (IW,*) 'Parameter[s] to free =? (rtn to end)'
80       IF (NEED_PARA) THEN
            CALL CASK('>',PNIN,NC)
            IF (NC.LT.1) RETURN
         ENDIF
         LO = 1
100      DO 110 I = LO, NC
            IF ((PNIN(I:I).EQ.' ').OR.(PNIN(I:I).EQ.',')) GO TO 120
110      CONTINUE

C           since the user can free many parameters in one call
C           search for a parameter seperator....
C           then point I to next possible parameter....
120      IHI = I - 1
         IF (IHI.LT.LO) THEN
C              eg. if two spaces in a row, etc. ....
            LO=LO+1
            GO TO 100
         ENDIF
         MC = I - LO
         ANS(1:MC) = PNIN(LO:IHI)
         ANS(MC+1:MC+1) = ' '

         CALL ININ_FLG(PNIN(LO:IHI),MC,PARAM,J1,J2,ERR_FLG)
         IF (ERR_FLG) THEN
            CALL PARA2NUM(ANS,PARAM,ERR_FLG)
         ENDIF
         IF (ERR_FLG) THEN
C              error message depends on parameter location in string....
            IF ((NC.GT.2) .AND. (PNIN(IHI+2:IHI+6).NE.'    ')) THEN
C                 there is a list and the parameter is not at the end....
               WRITE (IW,'(3A)') ' Parameter ',PNIN(LO:IHI),
     +                           ' unknown, try again.'
               WRITE (IW,'(3A)') ' Only freed up to parameter ',
     +                           PNIN(LO:IHI),'.'
            ELSEIF ((NC.GT.2) .AND. (PNIN(IHI+2:IHI+6).EQ.'    ')) THEN
C                 there is a list and the parameter is at the end....
               WRITE (IW,*) 'Last parameter unknown, try again.'
            ELSE
               WRITE (IW,*) 'Parameter unknown, try again.'
            ENDIF
            IF (.NOT. NEED_PARA) THEN
C                 pretend that ANS = 'FR      '....
               NC = 2
               GO TO 10
            ENDIF
            GO TO 80
         ENDIF
         CALL FIX_PARA(PARAM,FIX)

         LO = IHI + 2

C           if not done list, loop again....
         IF (LO.LE.NC) GO TO 100
C           or get more parameters....
         IF (NEED_PARA) GO TO 80

      ENDIF
      RETURN
      END
      FUNCTION ENEL(EG,THETA)
C Calculates energy of an electron undergoing a collision by a gamma-
C ray which is scattered an angle theta. See Canberra catalog ed.7, p.2
      ENEL=EG
        IF(EG.GT.0.1)THEN
        ENEL=EG*(EG/511.)*(1.-COS(THETA))/
     1  (1.+(EG/511.)*(1.-COS(THETA)))
      ENDIF
      END

      SUBROUTINE ExpThres
      INTEGER RDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60, ANS*1
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      DIMENSION EgamD(10),EffD(10),x(10),y(10)
      DATA EgamD/30.,80.,122.,183.,244.,294.,344.,562.,779.,1000./
      DATA EffD/ 0.0,0.1,0.51,0.66,0.78,0.85,0.89,0.99,1.00,1.000/

      ID=10
      write(6,*)' '
      write(6,*)'The efficiency at low energy (< 1000 keV) have to be given.'
      write(6,*)'It depends on various experimental conditions as thresholds'
      write(6,*)'on ADCs, gamma-absorber (2 mm Cu), timing etc. The program'
      write(6,*)'always assumes Eff = 0.0 at Egam < 30 keV and Eff = 1.00 at'
      write(6,*)'Egam > 1000 keV. However, in between these energies you can'
      write(6,*)'define a new shape of the discrimination.'
      write(6,*)' '

C Want to save EffD values as default. Therefore, defines x and y to work with.
      DO i=1,ID
        x(i)=EgamD(i)
        y(i)=EffD(i)
      ENDDO

C Finding x as a function of channels with energy calibration a0 and a1
 9999   DO I=0,511
        E=a0+FLOAT(I)*a1
        I1=1                      !finding interpolation points (I1 and I2)
        DO ii=1,ID
          IF(E.GT.x(ii))I1=ii
        ENDDO
        I2=I1+1
        IF(I1.EQ.ID) THEN
          I1=ID-1
          I2=ID
        ENDIF
        EffExp(i)=y(I1)+(y(I2)-y(I1))*(E-x(I1))/(x(I2)-x(I1))
        IF(EffExp(i).LE.0.)EffExp(i)=0.
        IF(E.LT. 30.)EffExp(i)=0.
        IF(E.GE.1408.)EffExp(i)=1.                           
      ENDDO

C Displaying discriminator function
      CALL DrawStars

C Should function be changed?
      ANS='n'
      WRITE(6,1)ANS
   1  FORMAT(/'Do you want to change the discriminator threshold <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(Istatus.NE.0)RETURN
      IF(ANS.EQ.'y'.OR.ANS.EQ.'Y')THEN
        DO i=2,ID-1
          WRITE(6,2)x(i),y(i)
   2      FORMAT('Give efficiency at ',F6.1,' keV     <',F4.2,'>:',$)
          CALL READF(5,y(i))
          IF(Istatus.NE.0)RETURN
        ENDDO
        GO TO 9999
      ELSE

C Writting data to file:resp.dat
        Idev=27
        OPEN (Idev,FILE='resp.dat',ACCESS='APPEND',IOSTAT=IOS)
        IF(IOS.EQ.0)THEN
          WRITE(Idev,*)'Details on efficiency up to 1000 keV:'
          WRITE(Idev,22)
          WRITE(Idev,24)
22        FORMAT('    Egam  EffTot  EffExp  EffTot*EffExp')
24        FORMAT('=======================================')
25        FORMAT(   F8.1,  F8.3,    F8.3,     F8.3      )
          icha=((1000.-a0)/a1)+0.5
          iStep=1
          IF(icha.GT.100)iStep=icha/100
          DO i=0,icha,istep
            E=a0+FLOAT(i)*a1
            IF(E.GE.0)WRITE(Idev,25)E,EffTot(i),EffExp(i),EffTot(i)*EffExp(i)
          ENDDO
          CLOSE(Idev)
        ENDIF
      ENDIF
      RETURN
      END


      SUBROUTINE DrawStars
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      CHARACTER line*60,line1*64,line2*64

      ix=60
      iy=10

C Initializing the 2 lower lines
      line2='0.0|---------.---------.---------.---------.---------.---------.'
      line1='   0        100       200       300       400       500   E(keV)'
C Writing out curve of efficiency
      DO j=iy,1,-1
        DO i=1,ix
          line(i:i)=' '
        ENDDO
        eff=0.1*FLOAT(j)
        dist=100000
        DO i=1,ix
          E=FLOAT(i)*10.
          ie=(E-a0)/a1 +0.5
          IF(ie.LT.0)ie=0
          IF(ie.GT.511)ie=511
          IF(ABS(EffExp(ie)-eff).LE.0.04999)THEN
            line(i:i)='*'
          ENDIF
        ENDDO
        IF(j.EQ.2.OR.j.EQ.4.OR.j.EQ.6.OR.j.EQ.8)THEN
          write(6,10)eff,line(1:60)
        ELSE
          write(6,11)line(1:60)
        ENDIF
 10     FORMAT(F3.1,'|',A60)
 11     FORMAT(  '   |',A60)
        line(ii:ii)=' '        
      ENDDO
      WRITE(6,12)line2
      WRITE(6,12)line1
 12   FORMAT(A64)

      RETURN
      END


      FUNCTION Fluc(F,ChiLow,ChiHigh,a1)
C Calculates fluctuations in a spectrum F between ChiLow and ChiHigh
C by (F(i)-Faverage)/Faverage. The average is taken over fwhm=0.12
C at 662 keV, and so on (Oslo 4/3-1988 /M. Guttormsen)
      DIMENSION F(0:511)
      INTEGER ChiLow,ChiHigh
      Fluc=0.0
      nChannels=0
      i1=ChiLow
      Egam=(ChiLow+1)*a1
      iFW=0.12*(SQRT(662.*Egam))/a1
      IF(iFW.LT.2)iFW=2
      Egam=(ChiLow+iFW/2)*a1
      iFW=0.12*(SQRT(662.*Egam))/a1
      IF(iFW.LT.2)iFW=2
      i2=i1+iFW

      DO WHILE(i2.LE.ChiHigh)
        Sum=0
        DO I=i1,i2
          Sum=Sum+F(I)
        ENDDO
        Average=Sum/(i2-i1+1)
        IF(Average.LT.2.)Average=2.
        DO I=i1,i2
          nChannels=nChannels+1
          Fluc=Fluc+ABS(F(I)-Average)/Average
        ENDDO
        i1=i2+1
        Egam=(i1+iFW/2.)*a1
        iFW=0.12*(SQRT(662.*Egam))/a1
        IF(iFW.LT.2)iFW=2
        i2=i1+iFW
      ENDDO

      Fluc=Fluc/nChannels
      RETURN
      END


      SUBROUTINE Fold
      INTEGER XDIM,YDIM,RDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM

      IF(RDIM.EQ.0)THEN
        WRITE(6,*)'No response function present'
        WRITE(6,*)'Use the RM command to create one'
        Istatus=1
        RETURN
      ENDIF
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF

      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)
        WRITE(6,3)XDIM
 3      FORMAT(/'Dimension along x-axis <',I4,'>:',$)
        CALL READI(5,XDIM)
        WRITE(6,4)YDIM
 4      FORMAT( 'Dimension along y-axis <',I4,'>:',$)
        CALL READI(5,YDIM)
        IF(Istatus.NE.0)RETURN
        CALL FoldIt
        WRITE(6,5)a0,a1
 5      FORMAT('Calibration is a0=',F6.1,'keV, a1=',F7.2,'keV/ch')
        cal(1,IDEST,1,1)=a0
        cal(1,IDEST,1,2)=a1
        cal(1,IDEST,1,3)=0
        IF(a0+a1.NE.cal(1,ISP,1,1)+cal(1,ISP,1,2))THEN
          WRITE(6,*)'Warning, different energy calibration for'
          WRITE(6,*)'response matrix and source spectrum.' 
        ENDIF
      ELSE
        
        IMAXCH=Idim(2,ISP,1)
        IF(IMAXCH.GT.4096)IMAXCH=4096
        WRITE(6,7)IMAXCH
 7      FORMAT(/'Dimension of singles spectrum <',I4,'>:',$)
        CALL READI(5,IMAXCH)
        IF(Istatus.NE.0)RETURN
        MAXCH=IMAXCH-1
        CALL FoldIt
        WRITE(6,8)a0,a1
 8      FORMAT('Calibration is a0=',F6.1,'keV, a1=',F7.2,'keV/ch')
        cal(2,IDEST,1,1)=a0
        cal(2,IDEST,1,2)=a1
        cal(2,IDEST,1,3)=0
        IF(a0+a1.NE.cal(2,ISP,1,1)+cal(2,ISP,1,2))THEN
          WRITE(6,*)'Warning, different energy calibration for'
          WRITE(6,*)'response matrix and source spectrum.' 
        ENDIF
      ENDIF

C Updating comment in the heading of spectrum file
      IF(ITYPE.GT.1)THEN
        xcomm(1:3)='FO:'
        fname(1,IDEST)(1:8)='FO'//fname(1,ISP)(1:6)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
      ELSE
        xcomm(1:3)='FO:'
        fname(2,IDEST)(1:8)='FO'//fname(2,ISP)(1:6)
        comm(2,IDEST)=comm(2,ISP)
        CALL AddComment(xcomm,3)
      ENDIF        
   
      END


      SUBROUTINE FoldIt
C        U      Unfolded spectrum
C        F      Folded spectrum, F=R(I,J)*U
C        a0,a1  Calibration for spectrum to be folded
C        LEN    Length of spectrum

      CHARACTER APP*4,ANS
      INTEGER XDIM,YDIM,RDIM,UPPER(0:511)
      INTEGER LOW,HIGH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      
      DIMENSION U(0:511),F(0:511)

      ISP=1
      IF(IDEST.EQ.1)ISP=2

      ANS='y'
      WRITE(6,133)ANS
 133  FORMAT(/,'Include total NaI-eff.    (y/n) <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(Istatus.NE.0)RETURN
      IF(ANS.EQ.'y'.OR.ANS.EQ.'Y')THEN
        CALL ExpThres
      ENDIF


      EMIN=30.                         ! 30 keV is lower limit
      IF(ITYPE.GT.1)THEN
        LEN=XDIM
      ELSE
        LEN=MAXCH+1
      ENDIF
      IF(RDIM.LT.LEN)LEN=RDIM
      LOW=((EMIN-a0)/a1)+0.5
      IF(LOW.LT.0.OR.LOW.GE.LEN)LOW=0

C Zeroing destination spectrum
      IF(ITYPE.GT.1)THEN
        IYDIM=YDIM
        DO I=0,4095
          DO J=0,511
            rMAT(IDEST,I,J)=0
          ENDDO
        ENDDO
      ENDIF
      IF(ITYPE.EQ.1)THEN
        IYDIM=1
        IY2=0
        DO I=0,8191
          rSPEC(IDEST,I)=0
        ENDDO
      ENDIF

C Defining upper border for the unfolding and chisq-test
      Ix1=LEN-1
      Ix2=LEN-1
      Iy1=0
      Iy2=Iydim-1
  
      IF(ITYPE.GT.1)THEN                !matrix
        WRITE(6,*)'Give upper limits for the unfolding. The boarder is'
        WRITE(6,*)'given by interpolation between (x1,y1) and (x2,y2)'
        WRITE(6,*)' '
        WRITE(6,*)'    (x2,y2)  second point'
        WRITE(6,*)'xxxxxxx'
        WRITE(6,*)'xxxxxxxxx'
        WRITE(6,*)'xxxxxxxxxxx'
        WRITE(6,*)'xx matrix xxx'
        WRITE(6,*)'xxxxxxxxxxxxxxx'
        WRITE(6,*)'            (x1,y1)  first point'
        WRITE(6,*)' '

        WRITE(6,123)Ix1
 123    FORMAT(/'First point x1  <',I5,'>:',$)
        CALL READI(5,Ix1)
        WRITE(6,124)Iy1
 124    FORMAT( 'First point y1  <',I5,'>:',$)
        CALL READI(5,Iy1)
        WRITE(6,125)Ix2
 125    FORMAT( 'Second point x2 <',I5,'>:',$)
        CALL READI(5,Ix2)
        WRITE(6,126)Iy2
 126    FORMAT( 'Second point y2 <',I5,'>:',$)
        CALL READI(5,Iy2)
      ELSE                              !singles
        WRITE(6,12)Ix1
 12     FORMAT(/'Give upper channel for folding    <',I5,'>:',$)
        CALL READI(5,Ix1)
        Ix2=Ix1
      ENDIF
      IF(Istatus.NE.0)RETURN

      CF=0.
      Dx12=Ix2-Ix1
      Dy12=Iy2-Iy1
      IF(Iy2.NE.Iy1)CF=Dx12/Dy12
      DO J=0,Iydim-1
        upper(J)=Ix1-CF*(FLOAT(Iy1-J))+0.5
        IF(upper(J).LT.low  )upper(J)=low
        IF(upper(J).GT.LEN-1)upper(J)=LEN-1
      ENDDO

      DO J=0,IYDIM-1                 !MAIN LOOP
        HIGH=UPPER(J)

C Getting the unfolded spectrum into U(i) and correcting for the total
C NaI response function for the unfolded data
        DO I=0,LEN-1
          U(I)=0.
          F(I)=0.
        ENDDO
        DO I=LOW,HIGH
          IF(ANS.EQ.'y'.OR.ANS.EQ.'Y')THEN
            effi=EffTot(I)*EffExp(I)
            IF(ITYPE.GT.1)U(I)=rMAT(ISP,I,J)*effi
            IF(ITYPE.EQ.1)U(I)=rSPEC(ISP,I)*effi
          ELSE
            IF(ITYPE.GT.1)U(I)=rMAT(ISP,I,J)
            IF(ITYPE.EQ.1)U(I)=rSPEC(ISP,I)
          ENDIF
        ENDDO

C FOLDING : F(I)=R(I,J)*U(J)
        DO I=LOW,HIGH
C WE PUT THE INTEGRATION LIMIT BELOW I DUE TO DETECTOR RESOLUTION
          KLOW=I*0.8
          DO K=KLOW,HIGH
            F(I)=F(I)+R(I,K)*U(K)
          ENDDO
        ENDDO

C PUTTING THE FOLDED SPECTRUM INTO DESTINATION MATRIX OR SPECTRUM
        DO I=LOW,HIGH
          IF(ITYPE.GT.1)THEN
            rMAT(IDEST,I,J)=F(I)
          ELSE
            rSPEC(IDEST,I)=F(I)
          ENDIF        
        ENDDO
      ENDDO                             ! MAIN LOOP

      END


      FUNCTION GAUSS(E,EE,W)
C Calculates a Gaussian distribution with centroid at E and half-width W
      SIG=W/2.35
      A=-((EE-E)**2)/(2.*SIG**2)
      GAUSS= (1./(SIG*SQRT(2.*3.141592)))*EXP(A)
      END


      SUBROUTINE GaussNaI(x,y,l1,l2,factor,w0)
C Folding the NAI-detector with a Gauss distribution with sig=FWHM/2.35
C The response matrix is made with FWHMresp=0.5*FWHMexp. Thus, the resolution
C of the detector is FWHMexp=factor*FWHMresp, using factor =2 
C The w0 parameter is the resolution already present due to bin-width of channels
C It takes values between 1 and 2
      INTEGER RDIM
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      DIMENSION x(0:511),y(0:511)
      W=0
      DO i=0,511
        y(i)=0.
      ENDDO
      IF(w0.LT.0.OR.w0.GT.2)THEN
        write(6,*)'w0 = ',w0,' is out of range, changed to w0 = 1.0'
        w0=1.
      ENDIF
      w0=w0*ABS(a1)        !from channels to energy
      DO I=l1,l2
        E=a0+I*a1
        Wtot=Fwhm1(I)*(factor*FWHM/100.)*E
        xx=(Wtot*Wtot)-(w0*w0)
        IF(xx.GT.0         )W=SQRT(xx)
        IF(W .LT.ABS(a1)/5.)W=ABS(a1)/5.  

C Finding integration limits. Going 6*sigma to each side
        Kmin=((E-a0-(6.*W/2.35))/a1)+0.5
        Kmax=((E-a0+(6.*W/2.35))/a1)+0.5
        IF(Kmin.LT.l1)Kmin=l1
        IF(Kmax.LT.l1)Kmax=l1
        IF(Kmax.GT.l2)Kmax=l2
        yK=0                     !used as normalization (should be =1)
        DO K=Kmin,Kmax
          EE=a0+K*a1
          yK=yK+GAUSS(E,EE,W)*a1
        ENDDO
        IF(yK.LE.0)yK=10000000
        DO K=Kmin,Kmax
          EE=a0+K*a1
          y(K)=y(K)+((x(I)*GAUSS(E,EE,W)*a1)/yK)
        ENDDO
      ENDDO
      END


      SUBROUTINE GetResp
      INTEGER XDIM,YDIM,RDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM

      IF(RDIM.EQ.0)THEN
        WRITE(6,*)'No response function present'
        WRITE(6,*)'Use the RM command to create one'
        Istatus=1
        RETURN
      ENDIF
      IF(ITYPE.EQ.1)ITYPE=3
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2        !To prevent overwritting last spectrum
      IDEST=IDUM

      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1

      IF(Istatus.NE.0)RETURN
      DO I=0,4095
        IT=(I/400)*400
        IF(IT.EQ.I)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        DO J=0,511
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO

      DO I=0,RDIM-1
        IT=(I/200)*200
        IF(IT.EQ.I)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        DO J=0,RDIM-1
          rMAT(IDEST,I,J)=R(I,J)
        ENDDO
      ENDDO
      WRITE(6,*)
      cal(1,IDEST,1,1)=a0
      cal(1,IDEST,1,2)=a1
      cal(1,IDEST,1,3)=0.
      cal(1,IDEST,2,1)=a0
      cal(1,IDEST,2,2)=a1
      cal(1,IDEST,2,3)=0.

C Resets XDIM and YDIM to RDIM
      XDIM=RDIM
      YDIM=RDIM
      CALL Setmarker(1,1,1)

C Updating comment in the heading of spectrum file
      xcomm(1:4)='|GR:'
      fname(1,IDEST)='RespFunc'
      comm(1,IDEST)=''
      CALL AddComment(xcomm,4)

      END


      SUBROUTINE Resp
      INTEGER XDIM,YDIM,RDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response2/ETAB(14),FTAB(14),ER(10),FE(10),SE(10),DE(10),ANN(10),EW(10),FW(10),ENA(10)
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      CHARACTER ENA*5
      DATA RDIM/0/
      
C This block of data represents energies (ETAB) and the total efficience (FTAB)
C at that energy for 5"x5" NaI. Normalized to 1 at 1.33 MeV     
      DATA  ETAB   /
     +       0.    ,50 .     ,100.      ,200.      ,400.,
     +     500.    ,700.    ,1000.     ,1500.     ,2000.,
     +    5000.   ,7000.   ,10000.    ,20000./
      DATA  FTAB   /
     +    1.00,    1.00,     1.00,      1.00,      1.00,
     +    1.00,    1.00,     1.00,      0.97,      0.88,
     +    0.81,    0.81,     0.82,      0.95/ 

C This bolck of data represents energies (ER) for measured resp. func.,
C intensities of full-energy (FE), single-escape (SE) and double-escape (DE)
C peaks. The numbers are counts of the various RESP-EXP-122,...
C response functions. The counts are converted into probabilities
C pf, pc, ps, pd, pa in the RSPNAI routine.
      DATA ER/ 122.,   245.,    344.,   511.,  662.,  1173.,
     1        1333.,  1836.,   4439., 15110./
      DATA FE/ 1223,   3362,   13709,  44717,248445,  26670,
     1        25228,  33413,   69767,  30608/
      DATA SE/    0,      0,       0,      0,     0,      0,
     1            0,    898,   18594, 153009/
      DATA DE/    0,      0,       0,      0,     0,      0,
     1            0,      0,    2008, 122407/
      DATA ANN/   0,      0,       0,      0,     0,      0,
     1            0,    534,    3000,  30000/
      DATA ENA/'122',  '245',   '344',  '511', '662', '1173',
     1        '1333', '1836',  '4439','15110'/

C This block of data represents energies (EW) and half-width (FW) of the
C gamma-resolution in the spectra. (NB! Normalized to 1. for 1.33 MeV)
      DATA EW/  122.,   245.,    344.,   779.,  964.,  1332.,
     1         1408.,  2000.,   4000., 15000./
      DATA FW/  2.21,   1.83,   1.73,   1.18,  1.09,   1.00,   
     1          0.99,   0.84,   0.60,   0.32/

C THE NUMBER OF CALIBRATION POINTS
      IW  =10
      ITAB=14

C Reading dimension and energy calibration
      IITYPE=2
      IF(ITYPE.GT.1)IITYPE=1
      RDIM=Idim(IITYPE,IDEST,1)
      IF(RDIM.LE.10.OR.RDIM.GT.512)RDIM=512
      WRITE(6,1)RDIM
   1  FORMAT('Dimension of response-matrix <',I4,'>:',$)
      CALL READI(5,RDIM)
      IF(RDIM.GT.512)THEN
        WRITE(6,*)'Too big response matrix, maximum is 512 x 512'
        Istatus=1
        RETURN
      ENDIF

      a0=cal(IITYPE,IDEST,1,1)
      a1=cal(IITYPE,IDEST,1,2) 
      IF(a0+a1.EQ.1.)THEN  
        a0=0.0
        a1=20.0
      ENDIF
      FWHM=6.0
      WRITE(6,10)a0
  10  FORMAT(/'Cal. coeff. a0 (keV)     <',F8.1,'>:',$)
      CALL READF(5,a0)
      WRITE(6,11)a1
  11  FORMAT( 'Cal. coeff. a1 (keV/ch)  <',F8.1,'>:',$)
      CALL READF(5,a1)

      IRSP=1
      WRITE(6,2)IRSP
   2  FORMAT(/'NaI(1) or Gauss(2) response function      <',I1,'>:',$)
      CALL READI(5,IRSP)
      IF(Istatus.NE.0)RETURN

      DO I=0,511
C Finding FWHMs as function of full energy, normalized to 1 at 1.33 MeV
        E=a0+I*a1
        I1=1
        DO K=1,IW
         IF(E.GT.EW(K))I1=K
        ENDDO
        I2=I1+1
        IF(I1.EQ.IW)THEN
          I1=IW-1
          I2=IW
        ENDIF
        W=FW(I1)+(FW(I2)-FW(I1))*(E-EW(I1))/(EW(I2)-EW(I1))
        IF(W.LE.0.00001)W=0.00001                           
        Fwhm1(I)=W
C Finding total efficiency as function of full energy
        I1=1
        DO K=1,ITAB
         IF(E.GT.ETAB(K))I1=K
        ENDDO
        I2=I1+1
        IF(I1.EQ.ITAB)THEN
          I1=ITAB-1
          I2=ITAB
        ENDIF
        EffTot(I)=FTAB(I1)+(FTAB(I2)-FTAB(I1))*(E-ETAB(I1))/(ETAB(I2)-ETAB(I1))
        IF(EffTot(I).LE.0.00001)EffTot(I)=0.00001                           
      ENDDO

      IF(IRSP.EQ.1)CALL RSPNAI
      IF(IRSP.EQ.2)CALL RSPGAUSS
 
      END


      SUBROUTINE RSPNAI
C     Routine for estimating NaI response-functions based on
C     interpolation between experimental spectra
C     with filenames RESP-EXP-511, RESP-EXP-1333, etc.
C     The measured response functions represent Compton and
C     back-scattering, only. The intensities of full-energy, single
C     escape, double escape and the annihilation radiation are
C     removed from the spectra. Their intensities are treated separate
C     and are listed in the DATA statement below.
C     In addition, the spectra are unfolded by their energy resolution. 
C     Therefore, one of the last task of this subroutine is to fold 
C     the interpolated spectrum with a Gaussian.
C     Some parameters are:
C        Egam   Fullenergy gamma-ray in keV
C        R(i,j) Response matrix. Intensity R in ch. i for fullenergy j
C        RDIM   Length of response spectrum
C        a0,a1  Energy-calibration of spectrum to be unfolded
C        b0,b1  Energy-calibration of original experimental response functions
C        FWHM   Half-width of spectrum at 1.33 MeV (is taken as 0.5*FWHMtrue)
C        ISTAT  Must be 0 by first call. Later it carries information
C               about what spectrum f1 and f2 which have been read
C               from disk. ISTAT=1 means 1. and 2. resp. func., ISTAT=2
C               means 2. AND 3., etc.
C     FE,SE,DE  Fullenergy, single-escape and double-escape at energy ER
C           FW  Halfwidth (FWHM) at energy EW (normalized to 1 for 1.33 MeV)
C     FEn,SEn,..is normalized intensities (not counts of raw specter)


      INTEGER XDIM,YDIM,RDIM
      CHARACTER ENA*5,APP*4,FILNAM*80,comment*60
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response2/ETAB(14),FTAB(14),ER(10),FE(10),SE(10),DE(10),ANN(10),EW(10),FW(10),ENA(10)
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      COMMON/response4/pf(0:511),pc(0:511),ps(0:511),pd(0:511),pa(0:511)
      DIMENSION FEn(10),SEn(10),DEn(10),ANNn(10)
      DIMENSION Calib(6)
      INTEGER dim
      DIMENSION Fs(0:4095),Fs1(0:4095),Fs2(0:4095),F1(0:4095),F2(0:4095)
      DIMENSION F(0:511),G(0:511), Spec(0:8191)
      DIMENSION Ffu(0:511),Gfu(0:511),Fsi(0:511),Gsi(0:511),Fdo(0:511),Gdo(0:511),Fan(0:511),Gan(0:511)
      CHARACTER*20 DATTIM

      ISTAT=0

C Number of response functions to interpolate between
      IR  =10
      
C The measured response functions have energy 
C calibration b0 (keV) and b1(keV/ch) 
C Response matrix R(i,j) has maximum dimensions 512x512
      b0=0.0
      b1=10.
      ical=6
      DO J=0,511
        DO I=0,511
          R(I,J)= 0.
        ENDDO
      ENDDO

C Reading FWHM at 1.33 MeV. It will be multiplied by the function
C Fwhm1(i), which is normalized to 1 at 1.33 MeV
      FWHM=6.0
      WRITE(6,12)FWHM
  12  FORMAT('Experimental FWHM at Egam=1.33 MeV (%)<',F5.1,'>:',$)
      CALL READF(5,FWHM)
      FWHM=FWHM*0.5          ! NB, we operate with half the FWHM value
      WRITE(6,13)
  13  FORMAT('(In the calculation the response function is obtained',
     +/'with a FWHM value of 0.5*(the exp. FWHM value just given) due',
     +/'to technical reasons in the unfolding procedure)')
      IF(Istatus.NE.0)RETURN

      EgamMin=30.                    ! Lower limit is 30 keV
      MinEgam=((EgamMin-a0)/a1)+0.5
      IF(MinEgam.LT.0)  MinEgam=0
      IF(MinEgam.GT.511)MinEgam=511

C Main loop starts
      DO J=0,RDIM-1
        JT=(J/30)*30
        IF(JT.EQ.J)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        DO I=0,511
          F(I)=0.
        ENDDO

        Egam=a0+(a1*FLOAT(J))
        IF(Egam.LT.EgamMin)GOTO 999

C Finding upper limit for the response function. Finding first the fwhm
C and take 6 times sigma above full-energy Egam
C (Remember, FWHM=0.5*FWHMexp, so it is not 6 but 3 times sigma)
        W=Fwhm1(J)*(FWHM/100.)*Egam
        IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.  
        EgamMax=Egam+(6.0*W/2.35)
        MaxEgam=((EgamMax-a0)/a1)+0.5
        IF(MaxEgam.GT.511)MaxEgam=511

C Finding the two response functions (I1 and I2) to use for the interpolation
        I1=1
        DO I=1,IR
          IF(Egam.GT.ER(I))I1=I
        ENDDO
        I2=I1+1
        IF(I1.EQ.IR) THEN
          I1=IR-1
          I2=IR
        ENDIF

C Reading the two spectra to use for interpolation 
C But first we check if they already have been read
        IF(I1.NE.ISTAT) THEN
          INP=20
          FILNAM='/Users/magneg/Myprog/mama/resp/RESP-EXP-'//ENA(I1)
          OPEN(INP,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
          dim=-1                      !Gives no headeroutput
          DO i=0,4095 
            Spec(i) = 0.
          ENDDO
          CALL norr1dim(INP,comment,dim,Spec,Calib)
          DO i=0,4095 
            Fs1(i)=Spec(i)
          ENDDO
          CLOSE(INP)
          FILNAM='/Users/magneg/Myprog/mama/resp/RESP-EXP-'//ENA(I2)
          OPEN(INP,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
          dim=-1                      !Gives no headeroutput
          DO i=0,4095 
            Spec(i) = 0.
          ENDDO
          CALL norr1dim(INP,comment,dim,Spec,Calib)
          DO i=0,4095 
            Fs2(i)=Spec(i)
          ENDDO
          CLOSE(INP)

C Trying to extrapolate down to zero energy
C Finding highest counts in Compton spectrum
C Then take 70 % and put in from channel 0 up to
C first time spectrum exeeds this threshold
          ih1=0
          ih2=0
          ipass1=0
          ipass2=0
          att1=0.7
          att2=0.7
          do i=0,4095
            if(Fs1(i).GT.ih1)ih1=Fs1(i)
            if(Fs2(i).GT.ih2)ih2=Fs2(i)
          enddo
          do i=0,4095
            if(Fs1(i).LT.ih1.and.ipass1.EQ.0)then
              Fs1(i)=att1*ih1
            else
              ipass1=1
            endif
            if(Fs2(i).LT.ih2.and.ipass2.EQ.0)then
              Fs2(i)=att2*ih2
            else
              ipass2=1
            endif
          enddo

C Streching/compressing Fs1 and Fs2 to fit calibration a0 and a1
          idim1=4096
          idim2=4096
          do i=0,4095
            Fs(i)=Fs1(i)
          enddo
          CALL ELASTIC(Fs,F1,b0,b1,a0,a1,idim1,idim2) !F1 is new spec.
          do i=0,4095
            Fs(i)=Fs2(i)
          enddo
          CALL ELASTIC(Fs,F2,b0,b1,a0,a1,idim1,idim2) !F2 is new spec.         

C Normalizing before interpolation (Trine)
C Compton background is normalized to one
          SumF1 = 0.
          SumF2 = 0.
          DO I = 0,4095
            SumF1 = SumF1 + F1(I)
            SumF2 = SumF2 + F2(I)
          ENDDO
          DO I = 0,4095
            F1(I) = F1(I)/SumF1
            F2(I) = F2(I)/SumF2
          ENDDO
          FEn(I1)  = FE(I1) /SumF1
          SEn(I1)  = SE(I1) /SumF1
          DEn(I1)  = DE(I1) /SumF1
          ANNn(I1) = ANN(I1)/SumF1
          FEn(I2)  = FE(I2) /SumF2
          SEn(I2)  = SE(I2) /SumF2
          DEn(I2)  = DE(I2) /SumF2
          ANNn(I2) = ANN(I2)/SumF2

C Finding upper limit for the two response functions. Finding first the fwhm
C and take 6 times sigma above full-energy of E1 and E2
C (Remember, FWHM=0.5*FWHMexp, so it is not 6 but 3 times sigma)
          E1=ER(I1)
          E2=ER(I2)
          ii1=(E1-a0)/a1+0.5
          W=Fwhm1(ii1)*(FWHM/100.)*E1
          IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.  
          E1Max=E1+(6.0*W/2.35)
          MaxE1=((E1Max-a0)/a1)+0.5
          IF(MaxE1.GT.4095)MaxE1=4095
          ii2=min0(511,INT((E2-a0)/a1+0.5))
          W=Fwhm1(ii2)*(FWHM/100.)*E2
          IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.  
          E2Max=E2+(6.0*W/2.35)
          MaxE2=((E2Max-a0)/a1)+0.5
          IF(MaxE2.GT.4095)MaxE2=4095
        ENDIF

        ISTAT=I1      ! to check against next time if new response
                      ! functions have to be read

C Finding energy-positions for backscattering (Ebsc) and
C Compton edge (Ecom). If we have to extrapolate to response functions
C with higher Egam than have been measured, we interpolate ch. by ch.
C up to 1000 keV
        Theta=3.141592654
        Ecom=EnEl(Egam,Theta)
        Ebsc=Egam-Ecom
        IF(Egam.GT.ER(IR).AND.Egam.GT.2000.)Ebsc=1000.
        Lbsc=((Ebsc-a0)/a1)+0.5
        Lcom=((Ecom-a0)/a1)+0.5
        IF(MinEgam.GT.Lbsc)Lbsc=MinEgam
        IF(MaxEgam.LT.Lcom)Lcom=MaxEgam
        Lcom=Lcom-1

C Starting to interpolate between spectra F1 and F2. This concerns the
C Compton and backscattering events, and is not easy: The main rule
C is that we interpolate between points in the spectra that represent
C the same angle theta of Compton scattering. However, up to back.sc. or
C at 0.1*Egamma, we interpolate between the same energies.
C One-to-one interpolation up to Lbsc
        DO I=MinEgam,Lbsc
          f1i=F1(I)
          f2i=F2(I)
          if1i=(0.5*MaxE1)+0.5
          if2i=(0.5*MaxE2)+0.5
          IF(I.GT.if1i)f1i=F1(if1i)
          IF(I.GT.if2i)f2i=F2(if2i)
          F(I)=F(I)+f1i+((f2i-f1i)*(Egam-E1)/(E2-E1))
          IF(F(I).LT.0.)F(I)=0.
        ENDDO
        i1Top=I-1
        i2Top=I-1
        iTop =I-1
C Interpolating between equal theta for 0 up to 180 dgrs.
        DO I=Lbsc+1,Lcom
          E=a0+I*a1
          IF(E.GT.0.1.AND.E.LT.Ecom)THEN
            if(ABS(Egam-E).GT.0.001)z=E/((Egam/511.)*(Egam-E))
            Theta=ACOS(1.-z)
            IF(Theta.GT.0.AND.Theta.LT.3.141592654)THEN
              IF1=((EnEl(E1,Theta)-a0))/a1+0.5
              IF2=((EnEl(E2,Theta)-a0))/a1+0.5
              IF(IF1.LT.Lbsc) IF1=Lbsc
              IF(IF2.GT.MaxE2)IF2=MaxE2
              FA   =F2(IF2)*  CORR(E2,Theta) - F1(IF1)*CORR(E1,Theta)
              FB   =F1(IF1)*CORR(E1,Theta) + FA*(Egam-E1)/(E2-E1)
              F(I) =F(I)+FB/CORR(Egam,Theta)
              i1Top=IF1
              i2Top=IF2
              iTop =I
            ENDIF
          ELSE
            write(6,*)'I,E,Egam,Theta,Ecom',I,E,Egam,Theta,Ecom
          ENDIF
          IF(F(I).LT.0.)F(I)=0.
        ENDDO

C Linear interpolation the last distance up to E+6*sigma
        s1=float(MaxE1-i1Top)/float(MaxEgam-iTop)
        s2=float(MaxE2-i2Top)/float(MaxEgam-iTop)
        DO I=iTop+1,MaxEgam
          IF1=i1Top+(s1*FLOAT(I-iTop))+0.5
          IF2=i2Top+(s2*FLOAT(I-iTop))+0.5
          IF(IF1.GT.MaxE1)IF1=MaxE1
          IF(IF2.GT.MaxE2)IF2=MaxE2
          F(I)=F(I)+F1(IF1)+(F2(IF2)-F1(IF1))*(Egam-E1)/(E2-E1)
          IF(F(I).LT.0.)F(I)=0.
        ENDDO
        SUMF=0.
        DO I = 0,511
          SUMF=SUMF+F(I)
        ENDDO
C Folding Compton with a Gauss distribution, where
C factor=1 means 0.5*FWHMexp and = 2 means 1.0*FWHMexp
C The width contribution from channel-bin is w0=1
C Array F is smoothed -> G
        factor=1.    
        w0=1.           
        CALL GaussNaI(F,G,MinEgam,MaxEgam,factor,w0) !smoothing Compton part

C Adding the counts of the full-energy, single-escape,
C double-escape and annihilation peaks to the spectrum.
C Generelly, the total counts (yl+yh) have to be distributed on 
C the two channels il and ih.
        DO i=0,511
          Ffu(i)=0.
          Gfu(i)=0.
          Fsi(i)=0.
          Gsi(i)=0.
          Fdo(i)=0.
          Gdo(i)=0.
          Fan(i)=0.
          Gan(i)=0.
        ENDDO

        A=FEn(I1)+( FEn(I2)- FEn(I1))*(Egam-E1)/(E2-E1)   !full-energy intensity
        IF(A.LT.0.)A=0.
        Egami=(Egam-a0)/a1
        il=Egami              ! Distribute counts on ch il and ih
        ih=il+1
        yl=(ih-Egami)*A
        yh=(Egami-il)*A
        IF(il.GE.0.AND.il.LE.MaxEgam) Ffu(il)=Ffu(il)+yl
        IF(ih.GE.0.AND.ih.LE.MaxEgam) Ffu(ih)=Ffu(ih)+yh
        ymax=AMAX1(yl,yh)
        ymin=AMIN1(yl,yh)
        IF(ymax.GT.0)THEN
          w0=(ymin+ymax)/ymax
        ELSE
          w0=1.
        ENDIF
        factor=1. 
        lim=MAX0(INT((3.*(Fwhm1(il)*2.*FWHM/100.))*FLOAT(il)+0.5) , 1)
        m1=MAX0(il-lim,MinEgam)
        m2=MIN0(ih+lim,MaxEgam)
        CALL GaussNaI(Ffu,Gfu,m1,m2,factor,w0) !smoothing full energy peak

        B=0.
        C=0.
        D=0.
        IF(Egam.GT.1022)THEN
          AN=511.0
          SI=Egam-(1.*AN)
          DO=Egam-(2.*AN)
          SIi=(SI-a0)/a1
          DOi=(DO-a0)/a1
          ANi=(AN-a0)/a1
          B=SEn(I1) +( SEn(I2)- SEn(I1))*(Egam-E1)/(E2-E1)
          C=DEn(I1) +( DEn(I2)- DEn(I1))*(Egam-E1)/(E2-E1)
          D=ANNn(I1)+(ANNn(I2)-ANNn(I1))*(Egam-E1)/(E2-E1)

C Taking care of the limiting case around 2*mc2=1022 keV
          IF(E1.LT.1022.AND.E2.GT.1022)THEN
            B= SEn(I2)*(Egam-1022.)/(E2-1022.)
            C= DEn(I2)*(Egam-1022.)/(E2-1022.)
            D=ANNn(I2)*(Egam-1022.)/(E2-1022.)
          ENDIF

          IF(B.LT.0.)B=0.
          IF(C.LT.0.)C=0.
          IF(D.LT.0.)D=0.

          il=SIi
          ih=il+1
          yl=(ih-SIi)*B
          yh=(SIi-il)*B
          IF(il.GE.0.AND.il.LE.MaxEgam) Fsi(il)=Fsi(il)+yl
          IF(ih.GE.0.AND.ih.LE.MaxEgam) Fsi(ih)=Fsi(ih)+yh
          ymax=AMAX1(yl,yh)
          ymin=AMIN1(yl,yh)
          IF(ymax.GT.0)THEN
            w0=(ymin+ymax)/ymax
          ELSE
            w0=1.
          ENDIF
          lim=MAX0(INT((3.*(Fwhm1(il)*2.*FWHM/100.))*FLOAT(il)+0.5) , 1)
          m1=MAX0(il-lim,MinEgam)
          m2=MIN0(ih+lim,MaxEgam)
          factor=1.               
          CALL GaussNaI(Fsi,Gsi,m1,m2,factor,w0) !smoothing s.esc. peak

          il=DOi              
          ih=il+1
          yl=(ih-DOi)*C
          yh=(DOi-il)*C
          IF(il.GE.0.AND.il.LE.MaxEgam) Fdo(il)=Fdo(il)+yl
          IF(ih.GE.0.AND.ih.LE.MaxEgam) Fdo(ih)=Fdo(ih)+yh
          ymax=AMAX1(yl,yh)
          ymin=AMIN1(yl,yh)
          IF(ymax.GT.0)THEN
            w0=(ymin+ymax)/ymax
          ELSE
            w0=1.
          ENDIF
          lim=MAX0(INT((3.*(Fwhm1(il)*2.*FWHM/100.))*FLOAT(il)+0.5) , 1)
          m1=MAX0(il-lim,MinEgam)
          m2=MIN0(ih+lim,MaxEgam)
          factor=1.               
          CALL GaussNaI(Fdo,Gdo,m1,m2,factor,w0) !smoothing d.esc. peak

          il=ANi 
          ih=il+1
          yl=(ih-ANi)*D
          yh=(ANi-il)*D
          IF(il.GE.0.AND.il.LE.MaxEgam) Fan(il)=Fan(il)+yl
          IF(ih.GE.0.AND.ih.LE.MaxEgam) Fan(ih)=Fan(ih)+yh
          ymax=AMAX1(yl,yh)
          ymin=AMIN1(yl,yh)
          IF(ymax.GT.0)THEN
            w0=(ymin+ymax)/ymax
          ELSE
            w0=1.
          ENDIF
          lim=MAX0(INT((3.*(Fwhm1(il)*2.*FWHM/100.))*FLOAT(il)+0.5) , 1)
          m1=MAX0(il-lim,MinEgam)
          m2=MIN0(ih+lim,MaxEgam)
          factor=1.               
          CALL GaussNaI(Fan,Gan,m1,m2,factor,w0) !smoothing ann. peak
        ENDIF

C We renormalize so that matrix R(i,j) have 1*RDIM counts
        SumR=0.
        DO I=0,RDIM-1
          R(I,J)=G(I)+Gfu(I)+Gsi(I)+Gdo(I)+Gan(I)
          IF(R(I,J).LT.0)R(I,J)=0
          SumR=SumR+R(I,J)
        ENDDO
        DO I=0,RDIM-1
          IF(SumR.GT.0)R(I,J)=R(I,J)/SumR
        ENDDO
 999    CONTINUE
      ENDDO

C Finding parameters as function of full energy
C Writing out to file: resp.dat
      DO I=0,511
        E=a0+I*a1
C The probabilities for full energy, Compton, single, double and annih. made:
        I1=1
        DO K=1,IR
         IF(E.GT.ER(K))I1=K
        ENDDO
        I2=I1+1
        IF(I1.EQ.IR)THEN
          I1=IR-1
          I2=IR
        ENDIF
        pf(I) = amax1(0.,FEn(I1) +(FEn(I2) -FEn(I1)) *(E-ER(I1))/(ER(I2)-ER(I1)))
        pc(I) = 1.                                  !due to Trines normalization
        ps(I) = amax1(0.,SEn(I1) +(SEn(I2) -SEn(I1)) *(E-ER(I1))/(ER(I2)-ER(I1)))
        pd(I) = amax1(0.,DEn(I1) +(DEn(I2) -DEn(I1)) *(E-ER(I1))/(ER(I2)-ER(I1)))
        pa(I) = amax1(0.,ANNn(I1)+(ANNn(I2)-ANNn(I1))*(E-ER(I1))/(ER(I2)-ER(I1)))
        total=pf(I)+pc(I)+ps(I)+pd(I)+pa(I)
        IF(total.LE.0.)total=10000000.
        pf(I) = pf(I)/total
        pc(I) = 1.   /total
        ps(I) = ps(I)/total
        pd(I) = pd(I)/total
        pa(I) = pa(I)/total
      ENDDO

  20  OPEN(UNIT=25,FILE='resp.dat', ERR=9998)
       
      ISM=1
      IF(ITYPE.EQ.1)ISM=2
      CALL DATETIME(DATTIM)
      WRITE(25,199)FNAME(ISM,IDEST),DATTIM(1:12)
      WRITE(25,210)a0,a1,FWHM*2.
199   FORMAT('Response function created for file:',A,' at ',A)
210   FORMAT('Calibration (a0,a1)=',F8.1,F9.3,'  FWHM=',F7.1,/)

      iStep=1
      IF(RDIM.GT.50)iStep=RDIM/50                  !steps for output
      WRITE(25,*)'Egam(keV) FWHM(keV) EffTot  Photo  Compton Single  Double   Annih'
      DO i=0,RDIM-1
        Egam=a0+i*a1
        IF(Egam.GT.0)THEN
          IF((i/iStep)*iStep.EQ.i)THEN
            fwh=0.
            IF(Egam.GT.0)fwh=Fwhm1(i)*(2.*FWHM/100.)*Egam
            IF(fwh.LT.ABS(a1)/5.)fwh=ABS(a1)/5.
            WRITE(25,14)Egam, fwh, EffTot(i),pf(i), pc(i), ps(i), pd(i), pa(i)
 14         FORMAT(     F8.1,F10.1,     F8.3, F8.4,  F8.4,  F8.4,  F8.4,  F8.4)
          ENDIF
        ENDIF
      ENDDO
      write(6,*)
      write(6,*)'Parameters for response function written to resp.dat'
      write(6,*)
      GOTO 9998
 9999 WRITE(6,*)'Cannot find the response function: ',FILENAM
 9998 CONTINUE
      CLOSE(24)
      CLOSE(25)

      END


      SUBROUTINE RSPGAUSS
C     Routine for producing response-functions for counters with
C     a Gaussian distribution
C     Some parameters are:
C        Egam   Energy in keV
C        R(I,J) Respone function. For a fullenergy j, you get
C               a spectrum with intensity R at channel i
C        RDIM   Length of respone spectrum
C        a0,a1  Energy-calibration of spectrum
C        FWHM   Half-width of spectrum at 1.33 mev
C        FW     Halfwidth (FWHM) at energy EW (NORMALIZED TO 1 FOR 1.33 MEV)
      CHARACTER*20 DATTIM
      CHARACTER APP*4
      INTEGER XDIM,YDIM,RDIM
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      DIMENSION F(0:511),G(0:511)

      FWHM=6.0

C Initializing response matrix
      DO J=0,511
        DO I=0,511
          R(I,J)= 0.
        ENDDO
      ENDDO

C Reading in various parameters to be used
c      IITYPE=2
c      IF(ITYPE.GT.1)IITYPE=1
c      a0=cal(IITYPE,IDEST,1,1)
c      a1=cal(IITYPE,IDEST,1,2) 
c      IF(a0+a1.EQ.1.)THEN  
c        a0=0.0
c        a1=80.0
c      ENDIF
c      WRITE(6,10)a0
c  10  FORMAT(/'Cal. coeff. a0 (keV)     <',F8.1,'>:',$)
c      CALL READF(5,a0)
c      WRITE(6,11)a1
c  11  FORMAT( 'Cal. coeff. a1 (keV/ch)  <',F8.1,'>:',$)
c      CALL READF(5,a1)

      IANS=1
      WRITE(6,12)IANS
  12  FORMAT(/'Define FWHM as function of channels (1)',
     1'or use the NaI-expression (2)<',I1,'>:',$)
      CALL READI(5,IANS)

      IF(IANS.EQ.2)THEN
        WRITE(6,13)FWHM
  13    FORMAT(/'FWHM at Egam=1.33 MeV (%)<',F8.3,'>:',$)
        CALL READF(5,FWHM)
        FWHM=0.5*FWHM
      ELSE
        IXL=RDIM*0.1+0.5
        IXH=RDIM*0.9+0.5
        FWXL=2.
        FWXH=2.
        WRITE(6,14)IXL,FWXL
  14    FORMAT(/'Write FWHM(ch) around ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWXL)
        WRITE(6,15)IXH,FWXH
  15    FORMAT( 'Write FWHM(ch) around ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWXH)
        FWXL=0.5*FWXL
        FWXH=0.5*FWXH

C Finding parametrization of fwhm.: FWHM = A + B * SQRT(ch)
        BX=(FWXL-FWXH)/(SQRT(float(IXL))-SQRT(float(IXH)))
        AX=FWXL-BX*SQRT(float(IXL))
        WRITE(6,*)'FWHM have been expressed by A + B * SQRT(ch):'
        WRITE(6,16)AX,BX
 16     FORMAT('Ax=',F8.4,'  Bx=',F8.4,/)
      ENDIF
      IF(Istatus.NE.0)RETURN

      WRITE(6,17)
 17   FORMAT('(In the calculation the response function is obtained',
     1/'with a FWHM value of 0.5*(the exp. FWHM value just given) due',
     1/'to technical reasons in the unfolding procedure)')

      EgamMin=30.
      MinEgam=(EgamMin-a0)/a1+0.5
      IF(MinEgam.LT.   0)MinEgam=0

C Main loop starts
      DO J=0,RDIM-1
        JT=(J/10)*10
        IF(JT.EQ.J)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        DO I=0,511
          F(I)=0.
          G(I)=0.
        ENDDO
        Egam=a0+a1*J
        IF(Egam.LT.EgamMin) GOTO 999

C Finding upper limit for the response function. Finding first the fwhm
C and take 6 times sigma above full-energy Egam
        W=Fwhm1(J)*(FWHM/100.)*Egam
        IF(IANS.EQ.1)W=(AX+BX*SQRT(float(J)))*a1
        IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.  
        EgamMax=Egam+(6.0*W/2.35)
        MaxEgam=((EgamMax-a0)/a1)+0.5
        IF(MaxEgam.GT.511)MaxEgam=511

C Putting a sharp peak into F(i=j)
        F(J)=10000.

C Folding detector resolution as a gauss distr. with sig=fwhm/2.35
        DO I=MinEgam,MaxEgam
          E=a0+I*a1
C Finding the fwhm (in keV) for that channel
          W=Fwhm1(i)*(FWHM/100.)*E
          IF(IANS.EQ.1)W=(AX+BX*SQRT(float(J)))*a1
          IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.  
C Finding integration limits. Going 6*sigma to each side.
          Kmin=((E-a0-(6.0*W/2.35))/a1)+0.5
          Kmax=((E-a0+(6.0*W/2.35))/a1)+0.5
          IF(Kmin.LT.MinEgam)Kmin=MinEgam
          IF(Kmax.LT.MinEgam)Kmax=MinEgam
          IF(Kmax.GT.MaxEgam)Kmax=MaxEgam
          IF(W.LT.ABS(a1)/5.)W=ABS(a1)/5.

          GK=0
          DO K=Kmin,Kmax
            EE=a0+K*a1
            GK=GK+GAUSS(E,EE,W)*a1
          ENDDO
          IF(GK.LE.0)GK=1000000
          DO K=Kmin,Kmax
            EE=a0+K*a1
            G(K)=G(K)+(F(I)*GAUSS(E,EE,W)*a1/GK)
          ENDDO
        ENDDO
        DO I=MinEgam,MaxEgam
          R(I,J)=G(I)
        ENDDO

C We renormalize so that matrix R(i,j) have integral 1*RDIM
        SUM1=0.
        DO I=0,RDIM-1
          SUM1=SUM1+R(I,J)
        ENDDO
        DO I=0,RDIM-1
          IF(SUM1.GT.0)R(I,J)=R(I,J)/SUM1
        ENDDO
 999    CONTINUE
      ENDDO

  20  OPEN(UNIT=25,FILE='resp.dat', ERR=6789)
      ISM=1
      IF(ITYPE.EQ.1)ISM=2
      CALL DATETIME(DATTIM)
      WRITE(25,199)FNAME(ISM,IDEST),DATTIM(1:12)
      WRITE(25,210)a0,a1,2.0*FWHM
      IF(IANS.EQ.1)WRITE(25,211)a0,a1,2.0*FWHL,2.0*FWHH
199   FORMAT('Response function created for file:',A,' at ',A)
210   FORMAT('Calibration (a0,a1)=',F8.1,F9.3,'  FWHM=',F7.1,/)
211   FORMAT('Calibration (a0,a1)=',F8.1,F9.3,'  FWHMl=',F7.1,' FWHMh=',F7.1,/)

      iStep=1
      IF(RDIM.GT.50)iStep=RDIM/50        !steps for output
      WRITE(25,*)'Egam(keV) FWHM(keV) EffTot'
      DO i=0,RDIM-1
        Egam=a0+i*a1
        IF(Egam.GT.0)THEN
          IF((i/iStep)*iStep.EQ.i)THEN
            fwh=0.
            IF(Egam.GT.0)THEN
              fwh=Fwhm1(i)*(2.*FWHM/100.)*Egam
              IF(IANS.EQ.1)fwh=(AX+BX*SQRT(float(i)))*a1
            ENDIF
            IF(fwh.LT.ABS(a1)/5.)fwh=ABS(a1)/5.
            xEffTot=1.
            WRITE(25,22)Egam,fwh,xEffTot
 22         FORMAT(F8.1,F10.2,F8.2)
          ENDIF
        ENDIF
      ENDDO
      CLOSE(25)
      write(6,*)
      write(6,*)'Parameters for response function written to resp.dat'
      write(6,*)
 6789 CONTINUE
      END
    
           
      SUBROUTINE SCORING(SoluP,Lsave,Lmax,SCORE,Isc,wfluc)
c Routine to calculate the score of each solution. The score-function,
c which should be as small as possible, is simply a weighted sum of
c chisquare and fluctuations

      DIMENSION SoluP(200,7),SC(200)
      CHARACTER SCORE(200)*4

      Isc=0
      DO I=1,200
        SCORE(I)='    '
        SC(200)=0
      ENDDO
      IF(wfluc.LT.0.OR.wfluc.GT.0.5)wfluc=0.2
      wchi=1.-wfluc

C Calculating the score-function
      THRES=0.3*SoluP(LSAVE,6)
      DO I=1,Lmax
        CHI=SoluP(I,6)
        FLU=SoluP(I,7)
        IF(FLU.LT.1.45)FLU=1.45
        SC(I)=wchi*CHI + wfluc*FLU
        EPS=SoluP(I,6)-SoluP(LSAVE,6)
        IF(EPS.GT.THRES)SC(I)=SC(I)+1000
      ENDDO

C Finding the favorit solution
      SCR=1000000
      DO I=1,Lmax
        IF(SC(I).LT.SCR)THEN
          SCR=SC(I)
          Isc=I
        ENDIF
      ENDDO
C Marking the solutions
      THRES1=0.1*THRES
      THRES2=0.3*THRES
      THRES3=0.7*THRES
      DO I=1,Lmax
        EPS=SC(I)-SC(Isc)
        IF(EPS.LT.THRES3)SCORE(I)=' *  '
        IF(EPS.LT.THRES2)SCORE(I)=' ** '
        IF(EPS.LT.THRES1)SCORE(I)=' ***'
      ENDDO

      SCORE(LSAVE)='<   '
      IF(LSAVE.EQ.Isc)SCORE(LSAVE)='<***'
      RETURN
      END


      SUBROUTINE UnFold
      INTEGER XDIM,YDIM,RDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60

      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
    
      IF(RDIM.EQ.0)THEN
        WRITE(6,*)'No response function present'
        WRITE(6,*)'Use the RM command to create one'
        Istatus=1
        RETURN
      ENDIF
        
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      iVersion=0
      WRITE(6,6)iVersion
 6    FORMAT(/'New (0) or old (1) unfolding procedure <',I1,'>:',$)
      CALL READI(5,iVersion)

      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)
        IF(XDIM.GT.RDIM)XDIM=RDIM
        WRITE(6,3)XDIM
 3      FORMAT(/'Dimension along x-axis <',I4,'>:',$)
        CALL READI(5,XDIM)
        WRITE(6,4)YDIM
 4      FORMAT( 'Dimension along y-axis <',I4,'>:',$)
        CALL READI(5,YDIM)
        IF(Istatus.NE.0)RETURN

        CALL UnFoldit(iVersion)

        WRITE(6,5)a0,a1
 5      FORMAT('Calibration is a0=',F6.1,'keV, a1=',F7.2,'keV/ch')
        cal(1,IDEST,1,1)=a0
        cal(1,IDEST,1,2)=a1
        cal(1,IDEST,1,3)=0
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)

        IF(a0+a1.NE.cal(1,ISP,1,1)+cal(1,ISP,1,2))THEN
          WRITE(6,*)'Warning, different energy calibration for'
          WRITE(6,*)'response matrix and source matrix.' 
        ENDIF 
      ELSE
        IMAXCH=Idim(2,ISP,1)
        IF(IMAXCH.GT.RDIM)IMAXCH=RDIM
        WRITE(6,7)IMAXCH
 7      FORMAT(/'Dimension of singles spectrum  <',I4,'>:',$)
        CALL READI(5,IMAXCH)
        IF(Istatus.NE.0)RETURN
        MAXCH=IMAXCH-1

        CALL UnFoldit(iVersion)

        WRITE(6,8)a0,a1
   8    FORMAT('Calibration is a0=',F6.1,'keV, a1=',F7.2,'keV/ch')
        cal(2,IDEST,1,1)=a0
        cal(2,IDEST,1,2)=a1
        cal(2,IDEST,1,3)=0
        IF(a0+a1.NE.cal(2,ISP,1,1)+cal(2,ISP,1,2))THEN
          WRITE(6,*)'Warning, different energy calibration for'
          WRITE(6,*)'response matrix and source spectrum.' 
        ENDIF
      ENDIF 

C Updating comment in the heading of spectrum file
      IF(ITYPE.GT.1)THEN
        xcomm(1:3)='UN:'
        fname(1,IDEST)(1:8)='UN'//fname(1,ISP)(1:6)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
      ELSE
        xcomm(1:3)='UN:'
        fname(2,IDEST)(1:8)='UN'//fname(2,ISP)(1:6)
        comm(2,IDEST)=comm(2,ISP)
        CALL AddComment(xcomm,3)
      ENDIF  
      END



      SUBROUTINE UnFoldit(iVersion)
C A program for unfolding detector response effects from a continuos
C gamma ray spectrum. Modified version (Aug. 1995) which smoothes the 
C Compton contribution, which is to be subtracted.
C
C UCID - 30079
C Lawrence Livermore Laboratory
C William J. Oconnel September 1973
C
C UCRL - 9748
C A computer analysis for complex sodium iodide gamma spectra
c James F. Mollenauer   august 1961
C
C Oslo Cyclotron Laboratory version 1989,1993,1994,1995 M.G.
C See NIM paper of M. Guttormsen et al. 1996, in press
C        Raw    Raw spectrum
C        U      Unfolded spectrum
C        F      Folded spectrum, F=R(I,J)*U
C        a0,a1  Calibration coeff in units of keV and keV/ch
C        LEN    Channels per spectrum
C        mode   = -1 : Difference iteration (d)
C               = +1 : Ratio iteration      (r)
C        Iter   =Max number of iteration steps

      INTEGER XDIM,YDIM,RDIM
      CHARACTER APP*4,waitname*8
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      COMMON/response1/R(0:511,0:511),RDIM,a0,a1,FWHM
      COMMON/response3/EffTot(0:511),Fwhm1(0:511),EffExp(0:511)
      COMMON/response4/pf(0:511),pc(0:511),ps(0:511),pd(0:511),pa(0:511)

      INTEGER low,high,ChiLow,ChiHigh,lower,upper
      INTEGER sum,Fsum,sumCH,FsumCH
      DIMENSION Raw(0:511),F(0:511),U(0:511),lower(0:511),upper(0:511)
      DIMENSION Fsave(0:511),Usave(0:511)
      DIMENSION SoluF(200,0:511),SoluP(200,7)
      DIMENSION rWAIT(0:8191)
      CHARACTER SCORE(200)*4,ANS*1
      CHARACTER modus*2,moil*2,moim*2,moir*2
      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colocr
      REAL Limit(0:19)
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      DIMENSION u0(0:511),su0(0:511),v(0:511),us(0:511),ud(0:511)
      DIMENSION ua(0:511),sua(0:511),w(0:511),sw(0:511),c(0:511),sc(0:511)

      ISP=1
      IF(IDEST.EQ.1)ISP=2
      Emin  =30.          ! 30 keV lowest limit
      EminCh=100.         ! 100 keV lower limit for Chi2-test
      Iter  =33           ! Number of max. iterations

C Using rSPEC(IDEST,i) to display spectra. Putting back later
      DO i=0,MAXCH
        rWAIT(i)=rSPEC(IDEST,i)
        rSPEC(IDEST,i)=0
      ENDDO
      waitname=fname(2,IDEST)
      IF(ITYPE.GT.1)fname(2,IDEST)=fname(1,ISP)
      IF(ITYPE.EQ.1)fname(2,IDEST)=fname(2,ISP)

C Zeroing destination spectrum
      IF(ITYPE.GT.1)THEN                !matrix
        LEN=XDIM
        IF(RDIM.LT.XDIM)LEN=RDIM
        Iydim=YDIM
        DO I=0,4095
          DO J=0,511
            rMAT(IDEST,I,J)=0
          ENDDO
        ENDDO
      ELSE                              !singles
        LEN=MAXCH+1
        IF(RDIM.LT.LEN)LEN=RDIM
        Iydim=1
        DO I=0,8191
          rSPEC(IDEST,I)=0
        ENDDO
      ENDIF

C Lowest channel treated
      low=((Emin-a0)/a1)+0.5
      IF(low.LT.0.OR.low.GE.LEN)low=0
      lowCh=((EminCh-a0)/a1)+0.5
      IF(lowCh.LT.0.OR.lowCh.GE.LEN)lowCh=0

C Defining upper border for the unfolding and chisq-test
      Ix1=LEN-1
      Ix2=LEN-1
      Iy1=0
      Iy2=Iydim-1
  
      IF(ITYPE.GT.1)THEN                !matrix
        WRITE(6,*)'Give upper limits for the unfolding. The boarder is'
        WRITE(6,*)'given by interpolation between (x1,y1) and (x2,y2)'
        WRITE(6,*)' '
        WRITE(6,*)'    (x2,y2) second point'
        WRITE(6,*)'xxxxxxx'
        WRITE(6,*)'xxxxxxxxx'
        WRITE(6,*)'xxxxxxxxxxx'
        WRITE(6,*)'xx matrix xxx'
        WRITE(6,*)'xxxxxxxxxxxxxxx'
        WRITE(6,*)'             (x1,y1) first point'
        WRITE(6,*)' '

        WRITE(6,123)Ix1
 123    FORMAT(/'First point x1  <',I5,'>:',$)
        CALL READI(5,Ix1)
        WRITE(6,124)Iy1
 124    FORMAT( 'First point y1  <',I5,'>:',$)
        CALL READI(5,Iy1)
        WRITE(6,125)Ix2
 125    FORMAT( 'Second point x2 <',I5,'>:',$)
        CALL READI(5,Ix2)
        WRITE(6,126)Iy2
 126    FORMAT( 'Second point y2 <',I5,'>:',$)
        CALL READI(5,Iy2)
      ELSE                              !singles
        WRITE(6,12)Ix1
 12     FORMAT(/'Give upper channel for unfolding  <',I5,'>:',$)
        CALL READI(5,Ix1)
        Ix2=Ix1
      ENDIF
      IF(Istatus.NE.0)RETURN

      CF=0.
      Dx12=Ix2-Ix1
      Dy12=Iy2-Iy1
      IF(Iy2.NE.Iy1)CF=Dx12/Dy12
      DO J=0,Iydim-1
        upper(J)=Ix1-CF*(FLOAT(Iy1-J))+0.5
        IF(upper(J).LT.low  )upper(J)=low
        IF(upper(J).GT.LEN-1)upper(J)=LEN-1
      ENDDO

C Setting lower limits for the chisquare test
      WRITE(6,130)
 130  FORMAT('  Give limits for the chisquare-test:',/,
     +       '  Opt. 1: Recommended for NaI-spectra. For full-energy gammas',
     +/,     '          above 2 MeV, we set lower limit at 500 keV. Below,',
     +/,     '          the limit is 1/4 of the full-energy. Remember,'
     +/,     '          full-energy is taken from the upper unfolding limit',
     +/,     '  Opt. 2: A fixed lower limit for the chi-test is applied'
     +/,     '  Opt. 3: Return and set proper upper limits for unfolding',/)

      Iopt=1
      IF(Ix1.EQ.Ix2)Iopt=2
      WRITE(6,131)Iopt
 131  FORMAT(/'Option (1/2/3)                  <',I1,'>:',$)
      CALL READI(5,Iopt)
      IF(Istatus.NE.0)RETURN

      IF(Iopt.EQ.1)THEN
        DO J=0,Iydim-1
          Emax=a0+upper(J)*a1
          lower(J)=(500.-a0)/a1                     !500 keV IF E>2MeV
          IF(Emax.LT.2000)lower(J)=(Emax*.25-a0)/a1
          IF(lower(J).LT.low)lower(J)=low
        ENDDO
      ENDIF

      IF(Iopt.EQ.2)THEN
        WRITE(6,132)lowCh
 132    FORMAT(/'Lower channel for chi-test  <',I5,'>:',$)
        CALL READI(5,lowCh)
        DO J=0,Iydim-1
          lower(J)=lowCh
        ENDDO
      ENDIF
      IF(Istatus.NE.0)RETURN

      IF(Iopt.NE.1.AND.Iopt.NE.2)THEN
        WRITE(6,*)'No unfolding performed'
        Istatus=1
        RETURN
      ENDIF

      ANS='y'
      WRITE(6,133)ANS    
 133  FORMAT(/,'Include total NaI-eff.    (y/n) <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(Istatus.NE.0)RETURN
      IF(ANS.EQ.'y'.OR.ANS.EQ.'Y')THEN
        CALL ExpThres
      ENDIF

      iter=33
      WRITE(6,134)iter   
 134  FORMAT(/,'Number of iterations ( <200 )  <',I2,'>:',$)
      CALL READI(5,iter)
      IF(iter.GT.200)iter=200
      IF(Istatus.NE.0)RETURN

      wfluc=0.2
      WRITE(6,*)' '
      WRITE(6,*)'The iteration is terminated when the folding of'
      WRITE(6,*)'the unfolded spectrum equals the raw spectrum. It'
      WRITE(6,*)'is however recommended to stop before the Chi2 is'
      WRITE(6,*)'at minimum. Thus, you can put a certain weight on'
      WRITE(6,*)'the importance not to have too strong fluctuations'
      WRITE(6,*)'in the final spectrum. We recommend a weight-factor'
      WRITE(6,*)'of 0.2 (valid range is 0.0 - 0.5)'
      WRITE(6,135)wfluc   
 135  FORMAT(/,'Weight on fluctuations <',F3.1,'>:',$)
      CALL READF(5,wfluc)
      IF(wfluc.GT.0.5)wfluc=0.2
      IF(Istatus.NE.0)RETURN

C Loop for spectrum J to be unfolded***************************
      DO J=0,Iydim-1
        high=   upper(J)
        ChiHigh=upper(J)
        ChiLow= lower(J)

C Getting the raw spectrum Raw(I)
        DO I=0,511
          IF(ITYPE.GT.1)Raw(I)=rMAT(ISP,I,J)
          IF(ITYPE.EQ.1)Raw(I)=rSPEC(ISP,I)
        ENDDO
        sum=   0
        sumCH= 0
        DO I=low,high
          sum  =sum + Raw(I)
        ENDDO
        DO I=ChiLow,ChiHigh
          sumCH=sumCH+Raw(I)
        ENDDO

C Initialize parameters
        DO I=1,Iter
          DO JJ=0,LEN-1
            SoluF(I,JJ)=0
          ENDDO
          DO JJ=1,7
            SoluP(I,JJ)=0
          ENDDO
        ENDDO

        DO I=0,LEN-1
          U(I)    =0.0
          F(I)    =0.0
          Fsave(I)=0.0
          Usave(I)=0.0
        ENDDO

        ModeChange=0
        CHIsave=1000000000
        CHIold =1000000000
                              
        FlucRaw=Fluc(Raw,ChiLow,ChiHigh,a1)
       
C The experimental pulse height spectrum is the first
C approximation to the unfolded gamma spectrum U(I)
        DO I=low,high
          U(I)=Raw(I)
        ENDDO

C Iteration loop for spectrum J. Folding the unfolded spectrum
C We have to start the integration somewhat below ch I, due to the
C detector resolution. We take conservative 20% resolution
        mode=0                      !starts with no method
        iTry=0
        DO L=1,Iter
          DO I=low,high
            F(I)=0.0
            Klow=I*0.8
            DO K=Klow,high
              F(I)=F(I)+R(I,K)*U(K)
            ENDDO
          ENDDO

C Calculate chisquare between folded and raw spectrum
          CHISQ=0.
          Ichi=0
          DO I=ChiLow,ChiHigh
            sig2=Raw(I)
            IF(sig2.LT.4.)sig2=4.
            CHISQ=CHISQ+((F(I)-Raw(I))**2)/sig2
            Ichi=Ichi+1
          ENDDO
          IF(Ichi.LT.1)Ichi=1
          IF(Ichi.GT.1)Ichi=Ichi-1
          CHISQ=CHISQ/Ichi

C Compute sum of counts
          Fsum  =0.
          FsumCH=0.
          DO I=low,high
            Fsum=Fsum+F(I)
          ENDDO
          DO I=ChiLow,ChiHigh
            FsumCH=FsumCH+F(I)
          ENDDO
 
          RelFluc=Fluc(U,ChiLow,ChiHigh,a1)/FlucRaw
          SoluP(L,1)=mode
          SoluP(L,2)=sum
          SoluP(L,3)=Fsum
          SoluP(L,4)=sumCH
          SoluP(L,5)=FsumCH
          SoluP(L,6)=CHISQ
          SoluP(L,7)=RelFluc
          DO JJ=low,high
            SoluF(L,JJ)=U(JJ)
          ENDDO
          Lmax=L

C Saves the best solution after at least 3 iterations
          IF(L.GT.3.AND.CHISQ.LT.CHIsave)THEN
            Lsave=L
            CHIsave=CHISQ
            DO I=low,high
              Usave(I)=U(I)
              Fsave(I)=F(I)
            ENDDO
          ENDIF

          IF(L.GT.3.AND.ABS( CHISQ-CHIold).LT.0.0006)       IterStop=1
          IF(L.GT.3.AND.ABS((CHISQ-CHIold)/CHISQ).LT.0.002) IterStop=1
          IF(iTry.GT.10.AND.CHISQ.GT.CHIold)                IterStop=1
          IF(iTry.GT.Iter/2.0 .AND.ModeChange.EQ.1)         IterStop=1
          iTry=iTry+1
          IF(IterStop.EQ.1)THEN
            IF(ModeChange.LT.10)THEN                   !Changing mode
              IterStop=0    !flags if going to end for one or another mode
              iTry    =0
              mode=mode*(-1)
              ModeChange=ModeChange+1
              DO I=low,high                            !Using the best solution
                F(I)=Fsave(I)                          !as initial function
                U(I)=Usave(I)
              ENDDO
            ELSE
              GO TO 100                                !End iteration          
            ENDIF
          ENDIF

C mode=-1 selects difference, mode=+1 ratio iteration
          IF(L.EQ.1)mode=-1                            !used for loop number 2
          IF(mode.EQ.-1) THEN
            DO I=low,high
              U(I)=U(I)+(Raw(I)-F(I))                  !difference mode
            ENDDO
          ELSE
            DO I=low,high
              IF(ABS(F(I)).GT.4)U(I)=U(I)*(Raw(I)/F(I))!ratio mode
            ENDDO
          ENDIF
          CHIold=CHISQ
        ENDDO

C Iteration loop for spectrum J ended

  100   CONTINUE

C Finding the best solution: It will be loop number Isc
        CALL SCORING(SoluP,Lsave,Lmax,SCORE,Isc,wfluc)

C Making compressed output in case of singles spectrum
        IF(ITYPE.EQ.1)THEN
          moil=' n'
          moim=' n'
          moir=' n'
          WRITE(6,26)
  26      FORMAT(30X,'  S U M M A R Y')
          WRITE(6,27)
          LLH=(L/3.)
          DO IL=1,LLH
            moil=' n'
            moim=' n'
            moir=' n'
            IM=IL+LLH
            IR=MIN0(IM+LLH,200)
            IF(SoluP(IL,1).EQ.-1)moil=' d'
            IF(SoluP(IL,1).EQ.+1)moil=' r'
            IF(SoluP(IM,1).EQ.-1)moim=' d'
            IF(SoluP(IM,1).EQ.+1)moim=' r'
            IF(SoluP(IR,1).EQ.-1)moir=' d'
            IF(SoluP(IR,1).EQ.+1)moir=' r'
            WRITE(6,28)IL,MOIL,SoluP(IL,6),SoluP(IL,7),SCORE(IL),
     +                 IM,MOIM,SoluP(IM,6),SoluP(IM,7),SCORE(IM),
     +                 IR,MOIR,SoluP(IR,6),SoluP(IR,7),SCORE(IR)
  27      FORMAT(' LP MD  CHISQ  Fluct SCR     LP MD  CHISQ  Fluct SCR     LP MD  CHISQ  Fluct SCR')
  28        FORMAT(I3,A2,F8.2,F7.2,A4,2(I7,A2,F8.2,F7.2,A4))
          ENDDO
        ENDIF

        modus=' n'
        IF(SoluP(Isc,1).EQ.-1)modus=' d'
        IF(SoluP(Isc,1).EQ.+1)modus=' r'
        K2=SoluP(Isc,5)+0.5
        K3=SoluP(Isc,4)+0.5

        WRITE(6,30)J,modus,K2,K3,SoluP(Isc,6),SoluP(Isc,7)
  30    FORMAT(' Row:',I4,'  Mode:',A2,'  Area:',I9,'(',I9,')  Chi:',F7.2,'  Fluct:',F6.2)

        IF(iVersion.EQ.1)THEN   !Dropping the Compton subtraction method
          DO i=0,LEN-1
            u(i)=0.0
          ENDDO
          DO i=low,high
            u(i)=SoluF(Isc,i)
          ENDDO
          GO TO 999  
        ENDIF



C***************************************************************(new begin)
C       New method: Compton Subtraction Method (Desember 1995/mg)
C       Reference: M. Guttormsen et al. NIM (1996), in press
C       The resolution in the unfolded spectrum u0 is about 0.87FWHM. 
C       Thus, it remains to smooth it with 0.5*FWHM.
C       Then we deduce S - U (rawspectrum - unfolded) to get the 
C       Compton-background etc., that is a smooth function of
C       energy (except for single+double+511 keV peaks). 
C       Therefore, we smooth
C       this differanse with FWHM, and calculate Ufinal=S-smooth(S-U). 
C       Remember, the FWHM parameter contains only 50% of
C       the value given by user: FWHM = FWHMresp = 0.5*FWHMexp
        DO i=0,LEN-1
          u0(i)   =0.0
          su0(i)  =0.0
          u(i)    =0.0
          v(i)    =0.0
          us(i)   =0.0
          ud(i)   =0.0           ! spectrum names as in NIM paper
          ua(i)   =0.0
          sua(i)  =0.0
          w(i)    =0.0
          sw(i)   =0.0
          c(i)    =0.0
          sc(i)   =0.0
        ENDDO

        CALL ERASE                 !erase the spectrum window
        icmap1=COLORMAP(1)         !saving this, and put back value at end
        ired  =COLORMAP(10)        !colors for spectra
        iblue =COLORMAP(1)
        igreen=COLORMAP(4)
        ITYPEwait=ITYPE            !have to simulate that we deal with
                                   !singles for the reason of displaying spectra
        ITYPE=1
        LOCH=0                     !display markers
        HICH=high

C Taking the best solution from earlier
        DO i=low,high
          u0(i)=SoluF(Isc,i)
        ENDDO

C Show spectrum u0
        DO i=low,high
          rSPEC(IDEST,i)=u0(i)
        ENDDO
        i1=1
        i2=2
        i3=0
        CALL SetMarker(0,2,0)
        COLORMAP(1)=iblue
        CALL DSPSP(i1,i2,i3,*333)
  333   CONTINUE

C Making us, ud and ua (single, double, annih) from unfolded spectrum
C Single and double escape peaks have the same shape as u0 (same FWHM).
        id511 =min0(high,INT(( 511./a1)+0.5))
        id1022=min0(high,INT((1022./a1)+0.5))
        DO i=high,id1022,-1
          us(i- id511)=u0(i)*ps(i)
        ENDDO

        DO i=high,id1022,-1
          ud(i-id1022)=u0(i)*pd(i)
        ENDDO

        i511= min0(high,INT(((511.-a0)/a1)+0.5))
        ua511=0.
        DO i=high,i511,-1
          ua511=ua511+u0(i)*pa(i)
        ENDDO
        Egami=(511.-a0)/a1
        il=Egami                          ! distributing counts on ch il and ih
        ih=il+1
        yl=(ih-Egami)*ua511
        yh=(Egami-il)*ua511
        IF(il.GE.0.AND.il.LE.high)ua(il)=ua(il)+yl
        IF(ih.GE.0.AND.ih.LE.high)ua(ih)=ua(ih)+yh
        ymax=AMAX1(yl,yh) !finding fwhm already present for 511 peak
        ymin=AMIN1(yl,yh)
        IF(ymax.GT.0)THEN
          w0=(ymin+ymax)/ymax
        ELSE
          w0=1.
        ENDIF
        factor=2.
        m1=max0(INT((0.7*i511+0.5)-1),low)
        m2=min0(INT((1.3*i511+0.5)+1),high)
        CALL GaussNaI(ua,sua,m1,m2,factor,w0)! have to be smoothed since ua is
                                             ! a spike in two channels around i511
C Making the us + ud spectrum
        DO i=low,high
          w(i)=us(i)+ud(i)
        ENDDO
C Smoothing with additional 0.5*FWHM
        factor=1.
        w0=1.           
        CALL GaussNaI(w,sw,low,high,factor,w0)
C Adding the sua spectrum to get final sw spectrum
        DO i=low,high
          sw(i)=sw(i)+sua(i)
        ENDDO
C Showing sw
        DO i=low,high
          rSPEC(IDEST,i)=sw(i)
        ENDDO
        i1=1
        i2=2
        i3=0
        CALL SetMarker(0,2,0)
        COLORMAP(1)=igreen
        CALL DSPSP(i1,i2,i3,*555)
555     continue
C Smoothing the u0 spectrum
        factor=1.
        w0=1.
        CALL GaussNaI(u0,su0,low,high,factor,w0)
C Multiplying down with pf
        DO i=low,high
          su0(i)=su0(i)*pf(i)
        ENDDO
C Making the v spectrum
        DO i=low,high
          v(i)=su0(i)+sw(i)
        ENDDO
C Making the Compton c spectrum
        DO i=low,high
          c(i)=Raw(i)-v(i)              !c is Compton-background
        ENDDO

C Showing Compton spectrum c
        i1=1
        i2=2
        i3=0
        DO i=low,high
          rSPEC(IDEST,i)=c(i)
        ENDDO
        COLORMAP(1)=ired
        CALL SetMarker(0,2,0)
        CALL DSPSP(i1,i2,i3,*666)
  666   CONTINUE

C Smoothing Compton with 1*FWHM
        factor=2.
        w0=1.
        CALL GaussNaI(c,sc,low,high,factor,w0)   !sc is smoothed Compton-background
C Showing original raw spectrum 
        i1=2
        i2=2
        i3=0
        DO i=low,high
          rSPEC(IDEST,i)=Raw(i)
        ENDDO
        COLORMAP(1)=ired
        CALL SetMarker(0,2,0)
        CALL DSPSP(i1,i2,i3,*777)
  777   CONTINUE
C Showing smoothed Compton sc+single+double+ann
        i1=2
        i2=2
        i3=0
        DO i=low,high
          rSPEC(IDEST,i)=sc(i)+sw(i)
        ENDDO
        COLORMAP(1)=igreen
        CALL DSPSP(i1,i2,i3,*888)
 888    CONTINUE

        DO i=low,high
          u(i)=Raw(i)-sc(i)-sw(i)         !u is the unfolded spectrum
        ENDDO

C Using the photo/total probability pf(i) to make u(i) contain all counts
        DO i=low,high
          IF(pf(i).GT.0.)THEN
            u(i)=u(i)/pf(i)
          ELSE
            u(i)=0.
          ENDIF
        ENDDO

C Showing final u/pf
        DO i=low,high
          rSPEC(IDEST,i)=u(i)
        ENDDO
        COLORMAP(1)=iblue
        CALL SetMarker(0,2,0)
        CALL DSPSP(i1,i2,i3,*999)

C Putting back what was in rSPEC(IDEST,i)
        DO i=0,MAXCH
          rSPEC(IDEST,i)=rWAIT(i)
        ENDDO
        ITYPE=ITYPEwait
C Putting back color
        COLORMAP(1)=icmap1

 999    CONTINUE


C********************************************************(new ended)

C Correcting for NaI efficiency as function of gamma-energy
        negstat=-1
        DO i=0,high
          rMAT(IDEST,I,J)=0
          rSPEC(IDEST,I)=0
          IF(u(i).GT.0)negstat=+1
          IF(i.lt.low)u(i)=0
          IF(negstat.EQ.-1)u(i)=0 !remove neg. counts in the first channels
          IF(ANS.EQ.'y'.OR.ANS.EQ.'Y')THEN
            effi=EffTot(I)*EffExp(I)
            IF(ITYPE.GT.1.AND.effi.GT.0.)rMAT(IDEST,I,J)=u(i)/effi
            IF(ITYPE.EQ.1.AND.effi.GT.0.)rSPEC(IDEST,I)=u(i)/effi
          ELSE
            IF(ITYPE.GT.1)rMAT(IDEST,I,J)=u(i)
            IF(ITYPE.EQ.1)rSPEC(IDEST,I)=u(i)
          ENDIF
        ENDDO

      ENDDO                                !J-loop for all spectra ended
      fname(2,IDEST)=waitname              !Putting back old name
      END



      SUBROUTINE FUNCFIT 
      CHARACTER*80 ANS
      REAL x(1:200),y(1:200),logy(1:200),a0(0:3),a1(0:3),a2(0:3),a3(0:3)
      REAL*8 XMAT(4,4),sx1,sx2,sx3,sx4,sx5,sx6,sx0y,sx1y,sx2y,sx3y
      INTEGER typefunc,typeinput
      COMMON/commonfit/NA

      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      INTEGER COLORMAP(19),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)

      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      COMMON/pofit/iii

      EXTERNAL fhyp,fexp,lexp,dE,fFermi1,lFermi1,fFermi2,lFermi2,fPol,range
      REAL lFermi1,lFermi2,lexp
      DIMENSION FIT(200),SIGMAY(200),A(5),DELTAA(5),SIGMAA(5),CH(500)
      DIMENSION bSIGMAA(5),bA(5)
      CHARACTER*8 chd
      COMMON/THICK/d,ifunc
      DIMENSION Spec(0:8191),Calib(6)
      CHARACTER NAME*80,COMMEN*60,CHR*40
      INTEGER dim

C patched by Andreas Schiller September 10 2003.
C reason: make more standard repetitive formats

C added the following variables:
      CHARACTER*16 F1STR,F2STR,F3STR,F4STR,F5STR,F6STR,F7STR,F8STR,F9STR,F0STR

      iblue    =COLORMAP(1)
      igreen   =COLORMAP(4)
      ibrown   =COLORMAP(7)
      ired     =COLORMAP(10)
      iwhite   =19
      iblack   =20

C Testing if called from PO command. Then simplified tests
      IF(iii.EQ.1)THEN
        typefunc=0
        typeinput=1
        iii=0
        GO TO 7777
      ENDIF
C Asking what type of fit and input by mouse or typing
      WRITE(6,*)'Give function to fit data points:'
      WRITE(6,*)'Polynomial  y=a+bx+cxx+dxxx ....(0)'
      WRITE(6,*)'Hyperbolic  y=a+b/x ............(1)'
      WRITE(6,*)'Exponential y=a+be^(cx) ........(2)'
      WRITE(6,*)'Range R(E) from dE-E plot ......(3)'
      WRITE(6,*)'A3+A2*EXP(2*sqrt(A1*x))/x*x.....(4)'
      WRITE(6,*)'A3+A2*EXP(2*sqrt(A1*x))/x**3/2..(5)'
      WRITE(6,*)'Return to mama .................(6)'
      ians=0
      WRITE(6,1)ians
 1    FORMAT('Give your answer <',I1,'>:',$)
      CALL READI(5,ians)
      IF(ians.LT.0.OR.ians.GT.5)RETURN
      IF(Istatus.NE.0)RETURN
      typefunc=ians
    
      IF(typefunc.EQ.3)THEN
        WRITE(6,*)' '
        WRITE(6,*)'You should now have displayed a dE-E matrix'
        WRITE(6,*)'where you may click along the banana corresponding'
        WRITE(6,*)'to the type of particles you want to optimize for.'
        WRITE(6,*)'Use many points (max=200) and be sure to click'
        WRITE(6,*)'for x y pairs at the ends of the banana. Blow'
        WRITE(6,*)'up your mama graphic window in order to make'
        WRITE(6,*)'accurate clicking. If you have not the proper'
        WRITE(6,*)'dE-E plot displayed, you may now return to mama.'
      ENDIF

      WRITE(6,*)' '
      WRITE(6,*)'Give input values (x,y) by clicking or typing:'
      WRITE(6,*)'Clicking in displayed matrix/spectrum .....(0)'
      WRITE(6,*)'Typing x y pairs from keyboard ............(1)'
      WRITE(6,*)'Return to mama ............................(2)'
      ians=0
      WRITE(6,1)ians
      CALL READI(5,ians)
      IF(ians.LT.0.OR.ians.GT.1)RETURN
      IF(Istatus.NE.0)RETURN
      typeinput=ians

7777  CONTINUE
      DO i=0,3
        a0(i)=0.
        a1(i)=0.
        a2(i)=0.        
        a3(i)=0.
      ENDDO
C First locating where the green button is in pixels (see curse.f)
      CALL INITG(nx,ny)             !Pixel size of window
      is=18

      mx1=2
      mx2=mx1+2*is
      mx3=mx2+4
      mx4=mx3+2*is
      mx5=mx4+4
      mx6=mx5+3*is
      mx7=mx6+4
      mx8=mx7+3*is
      mx10=nx-1
      mx9=mx10-13

      my1=ny+42
      my2=my1-0.7*is
      my3=my2-0.3*is
      my33=my3-4    !An extra -4 because we never get iy > spec. area

C Input by clicking in proper spectrum
      i=0
      IF(typeinput.EQ.0)THEN
      Istatus=-7     !to flag that green button is active
      CALL CLEANUP
        IF(i.GT.200)THEN
          WRITE(6,*)'Maximum (200) allowed datapoints reached'
          GO TO 98
        ENDIF  
        WRITE(6,*)'Type X or click on green button to exit'
999     CALL RETIC(Xp,Yp,ANS)
        i=i+1
        CALL CVXY(Xp,Yp,ix,iy,1)
        IF(ANS(1:1).EQ.'X'.OR.ANS(1:1).EQ.'x')THEN
          Istatus=0    !to flag that green button is active
          CALL CLEANUP
          GO TO 98
        ENDIF
        IF(ix.GE.mx9.AND.ix.LE.mx10.AND.iy.GE.my33)THEN
          Istatus=0    !to flag that green button is active
          CALL CLEANUP
          GO TO 98
        ENDIF
C Finding x y position in matrix or spectrum
        IF(ITYPE.GT.1)THEN                        ! matrix
          x(i)=Xp
          y(i)=Yp
        ENDIF
        IF(ITYPE.EQ.1)THEN                        ! spectrum
          x(i)=Xp
          iix=Xp
          IF(iix.GE.0.AND.iix.LE.8191)THEN
            y(i)=rSPEC(IDEST,iix)     
          ELSE
            i=i-1           ! not a valid (x,y) point
          ENDIF
        ENDIF
        WRITE(6,4)i,x(i),y(i)
        GO TO 999
      ENDIF

C Input by typing from keyboard
      IF(typeinput.EQ.1)THEN
        WRITE(6,2)
 2      FORMAT(/'Type pairs of x and y values for the data set.',/,
     +  'The numbers in a pair should be separated with space,',/,
     +  'and each pair should end with RETURN. Type characters',/,       
     +  'instead of numbers to terminate the inputs',/,   
     +  'Example:',/,       
     +  '1.2   5.7',/,    
     +  '2.6   9.7',/,       
     +  '3.1   8.5',/,    
     +  'x',/,
     +   '(Maximum 200 pairs)')
C Reading in the data set of x and y values:
        DO i=1,200
          CALL CASK('Type x y pair (character for stop): ',ANS,K)
          CALL FFIN(ANS,K,x(i),y(i),ydum,*98)
        ENDDO
      ENDIF

C Listing current data points and testing for doubletts
 98   imax=i-1
 99   WRITE(6,3)
      xave=0
      yave=0
  3   FORMAT(/'   Pair no.          X            Y')
      DO i=1,imax
        WRITE(6,4)i,x(i),y(i)
  4     FORMAT(4X,I3,4X,2E13.6)
        xave=xave+x(i)
        yave=yave+y(i)
      ENDDO
      idouble=0
      DO i=1,imax-1
        DO ii=i+1,imax
          IF((x(i).EQ.x(ii)).AND.(y(i).EQ.y(ii)))THEN !identical points
            idouble=idouble+1
            WRITE(6,*)'Warning, you have identical pairs'
          ENDIF
        ENDDO
      ENDDO

      xave=xave/imax
      yave=yave/imax
      WRITE(6,5)xave,yave
  5   FORMAT('Average:   ',2E13.6)
      xl=x(1)
      xh=x(1)
      x1=x(1)
      x2=x(1)
      yl=y(1)
      yh=y(1)
      DO i=2,imax                       !finding display limits
        IF(x(i).LT.xl)x1=x(i)
        IF(x(i).GT.xh)x2=x(i)
        IF(y(i).LT.yl)THEN
          yl=y(i)
          xl=x(i)
        ENDIF
        IF(y(i).GT.yh)THEN
          yh=y(i)
          xh=x(i)
        ENDIF
      ENDDO

C Displaying current data points
      IF(typeinput.EQ.0)THEN              !old display
        CALL DSfunc(x,y,imax,0.,0.,0.,0.,1)
      ENDIF
      IF(typeinput.EQ.1)THEN              !new display
        dx=(x2-x1)/10.                    !some air on the sides
        dy=(yh-yl)/10.
        CALL DSfunc(x,y,imax,x1-dx,x2+dx,yl-dy,yh+dy,1)
      ENDIF

C Asking if values OK, or modify them
77    ians=0
      Istatus=0
      WRITE(6,*)'You may modify one or more x y data points'
      WRITE(6,*)'in the list by typing from keyboard:'
      WRITE(6,*)'Input values are OK, start fitting ....(0)'
      WRITE(6,*)'Delete an  x y pair ...................(1)'
      WRITE(6,*)'Replace an x y pair ...................(2)'
      WRITE(6,*)'Add a new  x y pair....................(3)'
      WRITE(6,*)'Return to mama ........................(4)'
      WRITE(6,1)ians
      CALL READI(5,ians)
      IF(ians.EQ.4)RETURN
      IF(ians.LT.0.OR.ians.GT.4)GO TO 77
      IF(Istatus.NE.0)GO TO 77

      IF(ians.EQ.1)THEN                             !delete
        Ipair=imax
        WRITE(6,10)Ipair
 10     FORMAT(/'Delete pair no <',I3,'>:',$)
        CALL READI(5,Ipair)
        IF(Ipair.LT.1.OR.Ipair.GT.200)GO TO 99
        IF(Istatus.NE.0)GO TO 99
        DO i=max0(2,Ipair+1),imax
          x(i-1)=x(i)
          y(i-1)=y(i)
        ENDDO
        imax=imax-1
        GO TO 99
      ENDIF
      IF(ians.EQ.2)THEN                             !replace
        Ipair=imax
        WRITE(6,11)Ipair
 11     FORMAT(/'Replace pair no <',I3,'>:',$)
        CALL READI(5,Ipair)
        IF(Ipair.LT.1.OR.Ipair.GT.200)GO TO 99
        IF(Istatus.NE.0)GO TO 99
        WRITE(6,12)x(Ipair),y(Ipair)
 12     FORMAT(  'Old values are:                 ',2E13.6)
        CALL CASK('Type modified x y and (RETURN): ',ANS,K)
        CALL FFIN(ANS,K,x(Ipair),y(Ipair),ydum,*99)
        IF(Ipair.GT.imax)imax=Ipair
        GO TO 99
      ENDIF
      IF(ians.EQ.3)THEN                             !insert
        Ipair=imax+1
        CALL CASK('Type new x y and (RETURN): ',ANS,K)
        CALL FFIN(ANS,K,x(Ipair),y(Ipair),ydum,*99)
        imax=imax+1
        IF(imax.GT.200)imax=200
        GO TO 99
      ENDIF
      IF(imax.GT.200)THEN
        imax=200
        WRITE(6,*)'Maximum (200) allowed datapoints reached'
      ENDIF
      IF(imax-idouble.LT.2)RETURN

C Now comes the fitting according to the fit-function chosen  
C The number of points to fit is imax


C*********************************************************************
      IF(typefunc.EQ.0)THEN  !Polynomial, treated specially, not GRIDLS
        sx1=0.               !See p.277 in M.R. Spiegel Prob & Stat
        sx2=0.
        sx3=0.
        sx4=0.
        sx5=0.
        sx6=0.
        sx0y=0.
        sx1y=0.
        sx2y=0.
        sx3y=0.
       
        DO i=1,imax
          sx1=sx1+x(i)
          sx2=sx2+x(i)*x(i)
          sx3=sx3+x(i)*x(i)*x(i)
          sx4=sx4+x(i)*x(i)*x(i)*x(i)
          sx5=sx5+x(i)*x(i)*x(i)*x(i)*x(i)
          sx6=sx6+x(i)*x(i)*x(i)*x(i)*x(i)*x(i)
          sx0y=sx0y+y(i)
          sx1y=sx1y+x(i)*y(i)
          sx2y=sx2y+x(i)*x(i)*y(i)
          sx3y=sx3y+x(i)*x(i)*x(i)*y(i)
        ENDDO

C Constant fit
        IF(imax-idouble.GE.1)THEN
          XMAT(1,1)=imax
          XMAT(2,1)=sx1
          XMAT(1,2)=sx1
          XMAT(2,2)=sx2
          CALL MATINV(XMAT,1,4)
          a0(0)=XMAT(1,1)*sx0y
        ENDIF

C Linear fit
        IF(imax-idouble.GE.2)THEN
          XMAT(1,1)=imax
          XMAT(2,1)=sx1
          XMAT(1,2)=sx1
          XMAT(2,2)=sx2
          CALL MATINV(XMAT,2,4)
          a0(1)=XMAT(1,1)*sx0y+XMAT(2,1)*sx1y
          a1(1)=XMAT(1,2)*sx0y+XMAT(2,2)*sx1y
        ENDIF

C Quadratic fit
        IF(imax-idouble.GE.3)THEN       
          XMAT(1,1)=imax
          XMAT(2,1)=sx1
          XMAT(3,1)=sx2
          XMAT(1,2)=sx1
          XMAT(2,2)=sx2
          XMAT(3,2)=sx3
          XMAT(1,3)=sx2
          XMAT(2,3)=sx3
          XMAT(3,3)=sx4
          CALL MATINV(XMAT,3,4)
          a0(2)=XMAT(1,1)*sx0y+XMAT(2,1)*sx1y+XMAT(3,1)*sx2y
          a1(2)=XMAT(1,2)*sx0y+XMAT(2,2)*sx1y+XMAT(3,2)*sx2y
          a2(2)=XMAT(1,3)*sx0y+XMAT(2,3)*sx1y+XMAT(3,3)*sx2y
        ENDIF

C Cubic fit
        IF(imax-idouble.GE.4)THEN
          XMAT(1,1)=imax
          XMAT(2,1)=sx1
          XMAT(3,1)=sx2
          XMAT(4,1)=sx3
          XMAT(1,2)=sx1
          XMAT(2,2)=sx2
          XMAT(3,2)=sx3
          XMAT(4,2)=sx4
          XMAT(1,3)=sx2
          XMAT(2,3)=sx3
          XMAT(3,3)=sx4
          XMAT(4,3)=sx5
          XMAT(1,4)=sx3
          XMAT(2,4)=sx4
          XMAT(3,4)=sx5
          XMAT(4,4)=sx6      
          CALL MATINV(XMAT,4,4)
          a0(3)=XMAT(1,1)*sx0y+XMAT(2,1)*sx1y+XMAT(3,1)*sx2y+XMAT(4,1)*sx3y
          a1(3)=XMAT(1,2)*sx0y+XMAT(2,2)*sx1y+XMAT(3,2)*sx2y+XMAT(4,2)*sx3y
          a2(3)=XMAT(1,3)*sx0y+XMAT(2,3)*sx1y+XMAT(3,3)*sx2y+XMAT(4,3)*sx3y
          a3(3)=XMAT(1,4)*sx0y+XMAT(2,4)*sx1y+XMAT(3,4)*sx2y+XMAT(4,4)*sx3y
        ENDIF

C Outputs
        chi0=0.
        chi1=0.
        chi2=0.
        chi3=0.    
        WRITE(6,20)                                            
 20   FORMAT(/'Pair no.    X         Y    Constant  Linear  Quadratic    Cubic')
        DO i=1,imax
          y0=a0(0)
          chi0=chi0+(y(i)-y0)*(y(i)-y0)          
          y1=a0(1)+a1(1)*x(i)
          chi1=chi1+(y(i)-y1)*(y(i)-y1)
          y2=a0(2)+a1(2)*x(i)+a2(2)*x(i)*x(i)
          chi2=chi2+(y(i)-y2)*(y(i)-y2)
          y3=a0(3)+a1(3)*x(i)+a2(3)*x(i)*x(i)+a3(3)*x(i)*x(i)*x(i)
          chi3=chi3+(y(i)-y3)*(y(i)-y3)
          fy0=9.999
          fy1=9.999
          fy2=9.999
          fy3=9.999
          IF(imax.GE.1)fy0=y0
          IF(imax.GE.2)fy1=y1
          IF(imax.GE.3)fy2=y2
          IF(imax.GE.4)fy3=y3

          WRITE(6,21)i,x(i),y(i),fy0,fy1,fy2,fy3
 21       FORMAT(I4,6F10.3)
        ENDDO

        ch0=9.999
        ch1=9.999
        ch2=9.999
        ch3=9.999
        IF(imax.GE.1)ch0=chi0/(imax-1.+0.1)
        IF(imax.GE.2)ch1=chi1/(imax-2.+0.1)
        IF(imax.GE.3)ch2=chi2/(imax-3.+0.1)
        IF(imax.GE.4)ch3=chi3/(imax-4.+0.1)
        WRITE(6,22)ch0,ch1,ch2,ch3
 22     FORMAT('Chisquare (Ysigma=1):   ',4E10.3)

        IF(imax-idouble.GE.1)THEN
          WRITE(6,13)a0(0)
 13       FORMAT('Const.: a=',F12.4)
          CALL SETCOLOR(ired)
          CALL CVXY(xx,yy,1,iy,2)
          yy=a0(0)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(1,iy,0)
          DO ix=2,nx-30
            CALL CVXY(xx,yy,ix,iy,2)
            yy=a0(0)
            CALL CVXY(xx,yy,ix,iy,1)
            CALL KTRAS(ix,iy,1)
          ENDDO
          IF(iy.GT.ny-20)iy=ny-50
          IF(iy.LT.10)   iy=50
          CALL KTRAS(ix,iy,0)
          CALL PUTG('Const.',6,1,1)
          CALL FINIG
        ENDIF
        IF(imax-idouble.GE.2)THEN
          WRITE(6,23)a0(1),a1(1)
 23       FORMAT('Linear: a=',F12.4,' b=',F12.4)
          CALL SETCOLOR(iblue)
          CALL CVXY(xx,yy,1,iy,2)
          yy=a0(1)+a1(1)*xx
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(1,iy,0)
          DO ix=2,nx-30
            CALL CVXY(xx,yy,ix,iy,2)
            yy=a0(1)+a1(1)*xx
            CALL CVXY(xx,yy,ix,iy,1)
            CALL KTRAS(ix,iy,1)
          ENDDO
          IF(iy.GT.ny-20)iy=ny-50
          IF(iy.LT.10)   iy=50
          CALL KTRAS(ix,iy,0)
          CALL PUTG('Linear',6,1,1)
          CALL FINIG
        ENDIF
        IF(imax-idouble.GE.3)THEN
          WRITE(6,24)a0(2),a1(2),a2(2)
  24      FORMAT('Quadr.: a=',F12.4,' b=',F12.4,' c= ',E13.6)
          CALL SETCOLOR(igreen)
          CALL CVXY(xx,yy,1,iy,2)
          yy=a0(2)+a1(2)*xx+a2(2)*xx*xx
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(1,iy,0)
          DO ix=2,nx-30
            CALL CVXY(xx,yy,ix,iy,2)
            yy=a0(2)+a1(2)*xx+a2(2)*xx*xx
            CALL CVXY(xx,yy,ix,iy,1)
            CALL KTRAS(ix,iy,1)
          ENDDO
          IF(iy.GT.ny-20)iy=ny-40
          IF(iy.LT.10)   iy=40
          CALL KTRAS(ix,iy,0)
          CALL PUTG('Quadr.',6,1,1)
          CALL FINIG
        ENDIF
        IF(imax-idouble.GE.4)THEN
          WRITE(6,25)a0(3),a1(3),a2(3),a3(3)
  25      FORMAT('Cubic : a=',F12.4,' b=',F12.4,' c= ',E13.6,
     +    ' d= ',E14.8)
          CALL SETCOLOR(ibrown)
          CALL CVXY(xx,yy,1,iy,2)
          yy=a0(3)+a1(3)*xx+a2(3)*xx*xx+a3(3)*xx*xx*xx
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(1,iy,0)
          DO ix=2,nx-30
            CALL CVXY(xx,yy,ix,iy,2)
            yy=a0(3)+a1(3)*xx+a2(3)*xx*xx+a3(3)*xx*xx*xx
            CALL CVXY(xx,yy,ix,iy,1)
            CALL KTRAS(ix,iy,1)
          ENDDO
          IF(iy.GT.ny-20)iy=ny-30
          IF(iy.LT.10)   iy=30
          CALL KTRAS(ix,iy,0)
          CALL PUTG('Cubic ',6,1,1)
          CALL FINIG
        ENDIF
        CALL WriteFit(fpol,typefunc,a0,a1,a2,a3)
      ENDIF


C*********************************************************************
      IF(typefunc.EQ.1)THEN
        iOK = 0
        NA  = 1
        IF(Istatus.NE.0)GO TO 99
        IF(NA.GT.imax-idouble)THEN
          WRITE(6,*)'Number of parameters < independent data points'
          RETURN
        ENDIF
C Estimate parameters to be fitted
        A(1)=xave*yave
        IF(A(1).EQ.0.)A(1)=0.1
        A(2)=0.1

        WRITE(6,100)
 100    FORMAT(/'In order to start fit, start-values for the parameters',/,
     +         'have to be given. The default values are estimated from',/,
     +         'the y(x) values for the first (xl) and last (xh) point.',/,
     +         'You may start fitting with these values, or simply obtain',/,
     +         'the function with the given parameters (without fit).',/,
     +         ' ',/,
     +         'Your present fit-function looks like this (x=channels):',/,
     +         'Hyperbola(x) = A2 + A1/x                               ')
 
 177    CONTINUE
        WRITE(6,401)  A(1)
 101    FORMAT(/'Give start value for A1 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,402)  A(2)
 102    FORMAT( 'Give start value for A2 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(2))
        IF(Istatus.NE.0)RETURN

 199    IF(iOK.EQ.0)GO TO 188           !no fit yet
        ians=0
        Istatus=0
        WRITE(6,*)' '
        WRITE(6,*)'Give type of Chi**2 weighting:'
        WRITE(6,*)'Weighting with 1/Yexp(i) ............(0)'
        WRITE(6,*)'Weighting with 1.0 for all Yexp(i)...(1)'
        WRITE(6,*)'Return to mama ......................(2)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(ians.EQ.2)RETURN
        IF(ians.LT.0.OR.ians.GT.2)GO TO 177
        IF(Istatus.NE.0)GO TO 177
        IF(ians.EQ.0)MODE=-1
        IF(ians.EQ.1)MODE=0
 196    PROG  =0.0001
        M     =0
        CHISQR=1.0E+10
        bCH   =1.0E+10
        NBAD  =0
        DO i=1,NA
          SIGMAA(i)=A(i)/10.
          DELTAA(i)=A(i)/10.
        ENDDO

        IF(iOK.EQ.0)GO TO 188
 123    CALL GRIDLS(x,y,SIGMAY,imax,MODE,fhyp,A
     +  ,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 123
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CH(M).LT.bCH)THEN
          bCH=CH(M)               !saving best values
          DO i=1,NA
            bSIGMAA(i)=SIGMAA(i)
            bA(i)     =A(i)
          ENDDO
        ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(NBAD.GT.4.OR.M.GE.500)GO TO 124
        IF(VER.GT.PROG) GO TO 123
 124    CONTINUE

        DO i=1,NA      !replacing best values
          SIGMAA(i)=bSIGMAA(i)
          A(i)     =bA(i)
        ENDDO

C Presenting results, both numerical and graphical
        WRITE(6,120)                                            
 120    FORMAT(/'Pair no.       X            Y          FIT')
        DO i=1,imax
          WRITE(6,121)i,x(i),y(i),fhyp(x(i),A)
 121      FORMAT(I4,3E13.6)
        ENDDO

        ch1=0.000
        IF(imax.GT.NA)ch1=bCH
        WRITE(6,131)ch1
 131     FORMAT('Chisquare:',E12.3)

C changed the following 6 lines A.S.
        WRITE(F1STR,132)NA
        WRITE(6,FMT=F1STR)'Fit parameters  a,   b,... =',(a(i),i=NA,1,-1)
 132    FORMAT('(A28,',I5.5,'E12.4)')
        WRITE(F2STR,133)NA
        WRITE(6,FMT=F2STR)'Uncertainty  siga,sigb,... =',(sigmaa(i),i=NA,1,-1)
 133    FORMAT('(A28,',I5.5,'E12.4)')

 188    IF(NA.EQ.1)THEN
          CALL SETCOLOR(ired+iOK*10)
          CALL PUTG('   a/x',6,1,1)
          a0(0)=a(1)
        ENDIF
        IF(NA.EQ.2)THEN
          CALL SETCOLOR(igreen-iOK*3)
          CALL PUTG(' a+b/x',6,1,1)
          a0(1)=a(2)
          a1(1)=a(1)
        ENDIF

        CALL CVXY(xx,yy,1,iy,2)
        yy=fhyp(xx,A)
        CALL CVXY(xx,yy,ix,iy,1)
        CALL KTRAS(1,iy,0)
        DO ix=2,nx-30
          CALL CVXY(xx,yy,ix,iy,2)
          yy=fhyp(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(ix,iy,1)
        ENDDO
        IF(iy.GT.ny-20)iy=ny-NA*20
        IF(iy.LT.10)   iy=NA*20
        CALL KTRAS(ix,iy,0)
        CALL FINIG

        IF(NA.EQ.1.AND.imax-idouble.GE.2)THEN
          NA=2
          A(2)=yl
          IF(A(2).EQ.0)A(2)=0.1
          GO TO 196  ! a new fit with one more parameter
        ENDIF

        IF(iOK.EQ.1)GO TO 143
        NA   = 1
        iOK  = 0        ! no fit
        ians = 0        ! start fitting
        WRITE(6,*)' '
        WRITE(6,*)'Start fitting........................(0)'
        WRITE(6,*)'Modify the start parameters..........(1)'
        WRITE(6,*)'The function looks OK, do not fit....(2)'
        WRITE(6,*)'Return to mama.......................(3)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(Istatus.NE.0)GO TO 177
        IF(ians.EQ.0)iOK=1
        IF(ians.EQ.1)GO TO 177
        IF(ians.EQ.2)iOK=0
        IF(ians.EQ.3)RETURN
        IF(ians.LT.0.OR.ians.GT.3)GO TO 177
        IF(iOK.EQ.1)GO TO 199
        IF(iOK.EQ.0)GO TO 144

 143    WRITE(6,140)
 140    FORMAT('Final result:')
        WRITE(6,141)a0(0)
 141    FORMAT('y=a/x   : a=',E14.6)
        WRITE(6,142)a0(1),a1(1)
 142    FORMAT('y=a+b/x : a=',E14.6,' b=',E14.6)
 144    CALL WriteFit(fhyp,typefunc,a0,a1,a2,a3)
      ENDIF


C*********************************************************************
      IF(typefunc.EQ.2)THEN
        iOK = 0
        NA  = 2
        IF(Istatus.NE.0)GO TO 99
        IF(NA.GT.imax-idouble)THEN
          WRITE(6,*)'Number of parameters < independent data points'
          RETURN
        ENDIF

C Estimate parameters to be fitted
        IF(yl.LT.0)yl=0
        IF(yh.LT.0)yh=0
        A(1)=(alog(yl)-alog(yh))/(xl-xh)
        IF(A(1).EQ.0)A(1)=0.1
        A(2)=yh/(exp(xh*A(1)))
        IF(A(2).EQ.0)A(2)=0.1
        A(3)=yl

        WRITE(6,200)
 200    FORMAT(/'In order to start fit, start-values for the parameters',/,
     +         'have to be given. The default values are estimated from',/,
     +         'the y(x) values for the first (xl) and last (xh) point.',/,
     +         'You may start fitting with these values, or simply obtain',/,
     +         'the function with the given parameters (without fit).',/,
     +         ' ',/,
     +         'Your present fit-function looks like this (x=channels):',/,
     +         'Exponential(x) = A3 + A2 * EXP(A1*x)')
 
 277    CONTINUE
        WRITE(6,401)  A(1)
 201    FORMAT(/'Give start value for A1 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,402)  A(2)
 202    FORMAT( 'Give start value for A2 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,403)  A(3)
 203    FORMAT( 'Give start value for A3 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(3))
        IF(Istatus.NE.0)RETURN

 299    IF(iOK.EQ.0)GO TO 288
        ians=1
        Istatus=0
        WRITE(6,*)' '
        WRITE(6,*)'Give type of Chi**2 weighting:'
        WRITE(6,*)'Weighting with 1/Yexp(i) ............(0)'
        WRITE(6,*)'Weighting with 1.0 for all Yexp(i)...(1)'
        WRITE(6,*)'Return to mama ......................(2)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(ians.EQ.2)RETURN
        IF(ians.LT.0.OR.ians.GT.2)GO TO 277
        IF(Istatus.NE.0)GO TO 277
        IF(ians.EQ.0)MODE=-1
        IF(ians.EQ.1)MODE=0
 296    PROG  =0.0001
        M=0
        CHISQR=1.0E+10
        bCH   =1.0E+10
        NBAD  =0
        DO i=1,NA
          SIGMAA(i)=A(i)/10.
          DELTAA(i)=A(i)/10.
        ENDDO
        DO i=1,imax
          logy(i)=0.
          IF(y(i).GT.0)logy(i)=log(y(i))
        ENDDO

        IF(iOK.EQ.0)GO TO 288
 223    CALL GRIDLS(x,logy,SIGMAY,imax,MODE,lexp,A,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 223
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CH(M).LT.bCH)THEN
          bCH=CH(M)               !saving best values
          DO i=1,NA
            bSIGMAA(i)=SIGMAA(i)
            bA(i)     =A(i)
          ENDDO
        ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(NBAD.GT.4.OR.M.GE.500)GO TO 224
        IF(VER.GT.PROG) GO TO 223
 224    CONTINUE

        DO i=1,NA                !replacing best values
          SIGMAA(i)=bSIGMAA(i)
          A(i)     =bA(i)
        ENDDO

C Presenting results, both numerical and graphical
        WRITE(6,220)                                            
 220    FORMAT(/'Pair no.       X            Y          FIT')
        DO i=1,imax
          WRITE(6,221)i,x(i),y(i),fexp(x(i),A)
 221      FORMAT(I4,3E13.3)
        ENDDO

        ch1=0.000
        IF(imax.GT.NA)ch1=bCH
        WRITE(6,231)ch1
 231     FORMAT('Chisquare:',E12.3)

C changed the following 6 lines A.S.
        WRITE(F3STR,232)NA
        WRITE(6,FMT=F3STR)'Fit parameters  a,   b,... =',(a(i),i=NA,1,-1)
 232    FORMAT('(A28,',I5.5,'E12.4)')
        WRITE(F4STR,233)NA
        WRITE(6,FMT=F4STR)'Uncertainty  siga,sigb,... =',(sigmaa(i),i=NA,1,-1)
 233    FORMAT('(A28,',I5.5,'E12.4)')

 288    IF(NA.EQ.2)THEN
        CALL SETCOLOR(ired+iOK*10)
        CALL PUTG('ae^(bx)',7,1,1)
          a0(1)=a(2)
          a1(1)=a(1)
        ENDIF
        IF(NA.EQ.3)THEN
          CALL SETCOLOR(igreen-iOK*3)
          CALL PUTG('a+be^(cx)',9,1,1)
          a0(2)=a(3)
          a1(2)=a(2)
          a2(2)=a(1)
        ENDIF

        CALL CVXY(xx,yy,1,iy,2)
        yy=fexp(xx,A)
        CALL CVXY(xx,yy,ix,iy,1)
        CALL KTRAS(1,iy,0)
        DO ix=2,nx-30
          CALL CVXY(xx,yy,ix,iy,2)
          yy=fexp(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(ix,iy,1)
        ENDDO
        IF(iy.GT.ny-20)iy=ny-(NA+1)*10
        IF(iy.LT.10)   iy=NA*10
        CALL KTRAS(ix-20,iy+10,0)
        CALL FINIG

        IF(NA.EQ.2.AND.imax-idouble.GE.3)THEN
          NA=3
          IF(A(3).EQ.0)A(3)=0.1
          GO TO 296     ! a new fit with one more parameter
        ENDIF

        IF(iOK.EQ.1)GO TO 243
        NA   = 2
        iOK  = 0        ! no fit
        ians = 0        ! start fitting
        WRITE(6,*)' '
        WRITE(6,*)'Start fitting........................(0)'
        WRITE(6,*)'Modify the start parameters..........(1)'
        WRITE(6,*)'The function looks OK, do not fit....(2)'
        WRITE(6,*)'Return to mama.......................(3)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(Istatus.NE.0)GO TO 277
        IF(ians.EQ.0)iOK=1
        IF(ians.EQ.1)GO TO 277
        IF(ians.EQ.2)iOK=0
        IF(ians.EQ.3)RETURN
        IF(ians.LT.0.OR.ians.GT.3)GO TO 277
        IF(iOK.EQ.1)GO TO 299
        IF(iOK.EQ.0)GO TO 244


 243    WRITE(6,240)
 240    FORMAT(/,'Final result:')
        WRITE(6,241)a0(1),a1(1)
 241    FORMAT('y=ae^(bx)   : a=',E14.6,' b=',E14.6)
        WRITE(6,242)a0(2),a1(2),a2(2)
 242    FORMAT('y=a+be^(cx) : a=',E14.6,' b=',E14.6,' c=',E14.6)
 244    CALL WriteFit(fexp,typefunc,a0,a1,a2,a3)
      ENDIF
     

C*********************************************************************
      IF(typefunc.EQ.3)THEN
        IF(Istatus.NE.0)GO TO 99
        IF(NA.GT.imax-idouble)THEN
          WRITE(6,*)'Number of parameters < independent data points'
          RETURN
        ENDIF

C Setting up defaults values
 300    ICAL=2                 !calibration is quadratic
        dim=2048
        d=130.
        WRITE(6,301)d
 301    FORMAT(/'Give thickness of Si ',
     +          'dE-detector (um) <',F6.1,'>:',$)
        CALL READF(5,d)
        IF(d.LE.1.OR.d.GT.3000)GO TO 300

C Choosing range function
      ifunc=1
      WRITE(6,361)ifunc
 361  FORMAT('Choose type of range curve:',/,
     +       'E(a1+a2*E) +a3*/(E+a4)    (1)',/,
     +       'a1*E**a2                  (2)',/,
     +       'a1*E**(a2+a3*log(E))      (3)',/,
     +       'exp(a1+a2*lnE+a3*lnE*lnE) (4) <',I1,'>:',$)
 
        CALL READI(5,ifunc)
        IF(ifunc.LT.1.OR.ifunc.GT.4)THEN
          Istatus=1
          RETURN
        ENDIF

 305    ab1=40.
        WRITE(6,302)ab1
 302    FORMAT('Type calibration a1 (keV/ch)',/, 
     +  'of the dE-E banana you want to fit <',F5.2,'>:',$)
        CALL READF(5,ab1)
        Calib(1)=0.
        Calib(2)=ab1
        Calib(3)=0.
        xc=20./ab1
        IF(ab1.LT.2.OR.ab1.GT.1000)GO TO 305

 304    CHR='alp'
        WRITE(6,303)CHR(1:3)
 303    FORMAT('Range curve for:',/,
     +         '                proton  (pro)',/,
     +         '                deuteron(deu)',/,
     +         '                triton  (tri)',/,
     +         '                tau     (tau)',/,
     +         '                alpha   (alp) <',A3,'>:',$)
        CALL READA(5,CHR)
        A(1)=0

        IF(ifunc.EQ.1)THEN
          NA=4
          IF(CHR.EQ.'pro'.OR.CHR.EQ.'PRO'.OR.
     +       CHR.EQ.'deu'.OR.CHR.EQ.'DEU'.OR.
     +       CHR.EQ.'tri'.OR.CHR.EQ.'TRI')THEN
            A(1)=0.81743/xc
            A(2)=0.0008742/(xc*xc)
            A(3)=-409.254
            A(4)=566.175*xc
          ENDIF
          IF(CHR.EQ.'tau'.OR.CHR.EQ.'TAU'.OR.
     +       CHR.EQ.'alp'.OR.CHR.EQ.'ALP')THEN
c            A(1)=0.29871/xc                     ! old values from Finn
c            A(2)=0.000133/(xc*xc)
c            A(3)=-474.768
c            A(4)=1864.*xc
            A(1)=0.756/xc                        ! new values from Magne
            A(2)=6.853E-05/(xc*xc)
            A(3)=-6720.
            A(4)=9650.*xc 
          ENDIF
        ENDIF

        IF(ifunc.EQ.2)THEN
          NA=2
          IF(CHR.EQ.'pro'.OR.CHR.EQ.'PRO'.OR.
     +       CHR.EQ.'deu'.OR.CHR.EQ.'DEU'.OR.
     +       CHR.EQ.'tri'.OR.CHR.EQ.'TRI')THEN
            A(1)=0.006
            A(2)=1.
            A(3)=0
            A(4)=0
          ENDIF
          IF(CHR.EQ.'tau'.OR.CHR.EQ.'TAU'.OR.
     +       CHR.EQ.'alp'.OR.CHR.EQ.'ALP')THEN
            A(1)=0.006    
            A(2)=1.
            A(3)=0
            A(4)=0 
          ENDIF
        ENDIF

        IF(ifunc.EQ.3)THEN
          NA=3
          IF(CHR.EQ.'pro'.OR.CHR.EQ.'PRO'.OR.
     +       CHR.EQ.'deu'.OR.CHR.EQ.'DEU'.OR.
     +       CHR.EQ.'tri'.OR.CHR.EQ.'TRI')THEN
            A(1)=0.0006
            A(2)=1.0
            A(3)=0.01
          ENDIF
          IF(CHR.EQ.'tau'.OR.CHR.EQ.'TAU'.OR.
     +       CHR.EQ.'alp'.OR.CHR.EQ.'ALP')THEN
            A(1)=0.0006
            A(2)=1.0
            A(3)=0.01
          ENDIF
        ENDIF

        IF(ifunc.EQ.4)THEN
          NA=3
          IF(CHR.EQ.'pro'.OR.CHR.EQ.'PRO'.OR.
     +       CHR.EQ.'deu'.OR.CHR.EQ.'DEU'.OR.
     +       CHR.EQ.'tri'.OR.CHR.EQ.'TRI')THEN
            A(1)=1.
            A(2)=0.1
            A(3)=0.01
          ENDIF
          IF(CHR.EQ.'tau'.OR.CHR.EQ.'TAU'.OR.
     +       CHR.EQ.'alp'.OR.CHR.EQ.'ALP')THEN
            A(1)=1.
            A(2)=0.1
            A(3)=0.01
          ENDIF
        ENDIF

        IF(A(1).EQ.0)GO TO 304
       
        IF(Istatus.NE.0)GO TO 99
        M     =0
        PROG  =0.00000001
        MODE  =0
        CHISQR=1.0E+10
        bCH   =1.0E+10
        NBAD  =0

C Estimate parameters to be fitted
        DO i=1,NA
          SIGMAA(i)=A(i)/10.
          DELTAA(i)=A(i)/10.
        ENDDO
 
  323   CALL GRIDLS(x,y,SIGMAY,imax,MODE,dE,A
     +  ,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 323
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CH(M).LT.bCH)THEN
          bCH=CH(M)                            !saving best values
          DO i=1,NA
            bSIGMAA(i)=SIGMAA(i)
            bA(i)     =A(i)
          ENDDO
        ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(M.EQ.20)THEN                 ! Just to try new values
          DO i=1,NA
            A(i)=(0.3*A(i)+0.7*bA(i))
          ENDDO
        ENDIF
        IF(M.EQ.40)THEN    
          DO i=1,NA
            A(i)=0.5*bA(i)
          ENDDO
        ENDIF
        IF(M.EQ.60)THEN    
          DO i=1,NA
            A(i)=1.5*bA(i)
          ENDDO
        ENDIF        
        IF(M.EQ.80)THEN     
          DO i=1,NA
            A(i)=bA(i)
          ENDDO
          A(1)=0.5*bA(1)
          A(2)=1.5*bA(2)
        ENDIF
        IF(M.EQ.100)THEN  
          DO i=1,NA
            A(i)=bA(i)
          ENDDO
          A(1)=1.5*bA(1)
          A(2)=0.5*bA(2)
        ENDIF
        IF(M.EQ.120)THEN  
          DO i=1,NA
            A(i)=bA(i)
          ENDDO
        ENDIF

        IF(NBAD.GT.100.OR.M.GE.500)GO TO 324
        IF(VER.GT.PROG) GO TO 323
 324    CONTINUE

        DO i=1,NA                              !replacing best values
          SIGMAA(i)=bSIGMAA(i)
          A(i)     =bA(i)
        ENDDO
C Presenting results, both numerical and graphical
        WRITE(6,320)                                            
 320    FORMAT(/'Pair no.       X            Y          FIT')
        DO i=1,imax
          WRITE(6,321)i,x(i),y(i),dE(x(i),A)
 321      FORMAT(I4,3E13.6)
        ENDDO

        ch1=0.000
        IF(imax.GT.NA)ch1=bCH
        WRITE(6,331)ch1
 331     FORMAT('Chisquare (Ysigma=):',E12.3)

C changed the following 6 lines A.S.
        WRITE(F5STR,332)NA
        WRITE(6,FMT=F5STR)'Fit parameters  a,   b,... =',(a(i),i=1,NA)
 332    FORMAT('(A28,',I5.5,'E13.4)')
        WRITE(F6STR,333)NA
        WRITE(6,FMT=F6STR)'Uncertainty  siga,sigb,... =',(sigmaa(i),i=1,NA)
 333    FORMAT('(A28,',I5.5,'E13.4)')

        dsave=d
        d=20.
        DO i=1,7
          d=d+i*10.
          CALL SETCOLOR(ibrown)
          CALL CVXY(xx,yy,5,iy,2)
          yy=dE(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          IF(i.EQ.1)i0=iy/2
          ip=i0+i*15
          CALL KTRAS(5,iy,0)
          DO ix=6,nx-25
            CALL CVXY(xx,yy,ix,iy,2)
            yy=dE(xx,A)
            CALL CVXY(xx,yy,ix,iy,1)
            CALL KTRAS(ix,iy,1)
          ENDDO
          write(chd,344,err=398)d
 344      format(F8.1) 
          CALL PUTG(chd,8,1,1)
 398      CONTINUE
        ENDDO
        d=dsave
        CALL SETCOLOR(ired)
        CALL CVXY(xx,yy,5,iy,2)
        yy=dE(xx,A)
        CALL CVXY(xx,yy,ix,iy,1)
        ip=0.8*iy
        CALL KTRAS(5,iy,0)
        DO ix=6,nx-25
          CALL CVXY(xx,yy,ix,iy,2)
          yy=dE(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(ix,iy,1)
        ENDDO
        write(chd,345,err=399)d
 345    format(F8.1) 
        CALL PUTG(chd,8,1,1)
 399    CONTINUE
        CALL FINIG

        IF(typeinput.EQ.0.AND.ITYPE.GT.1)THEN
          DO i=0,8191
            Spec(i)=0
          ENDDO
          WRITE(6,*)' '
          WRITE(6,*)'A thickness spectrum of the dE-E matrix'
          WRITE(6,*)'will now automatically be written to file.'
          DO j=0,YDIM-1
            ydE=j
            DO i=0,XDIM-1
              xE=i
              id=range(xE+ydE,A,ifunc)-range(xE,A,ifunc)
              IF(id.GE.1.AND.id.LE.512)THEN
                Spec(id)=Spec(id)+rMAT(IDEST,i,j)
              ENDIF
            ENDDO
          ENDDO
          NAME='thick-'//CHR
          WRITE(6,348)NAME(1:9)
 348      FORMAT(' Type filename <',A,'>:',$)
          CALL READA(5,NAME)
          dim=512
          OPEN(20,FILE=NAME,ACCESS='SEQUENTIAL',IOSTAT=IOS)
          IF(IOS.NE.0)THEN
            WRITE(6,*) 'No file access'
            RETURN
          ENDIF
          COMMEN='Thickness spectrum using range for '//CHR(1:3)//' on silicon'
          CALL norw1dim(20,COMMEN,dim,Spec,Calib)
          CLOSE(20)
        ENDIF

       WRITE(6,*)' '
       WRITE(6,*)'The extracted range curve (this is not the red curve'
       WRITE(6,*)'seen in the window) will now be saved as file. You'
       WRITE(6,*)'may first give another calibration for the range'
       WRITE(6,*)'curve since the dE-E plot might have been compressed:'
        
 347    ar1=ab1
        WRITE(6,*)' '
        WRITE(6,346)ar1
 346    FORMAT('Type calibration a1 (keV/ch) of range curve',
     +         ' <',F5.2,'>:',$)
        CALL READF(5,ar1)
        IF(ar1.LT.2.OR.ar1.GT.1000)GO TO 347
        xxc=ab1/ar1
        A(1)=A(1)/xxc
        A(2)=A(2)/(xxc*xxc)
        A(3)=A(3)
        A(4)=A(4)*xxc

        WRITE(6,349)ar1
 349    FORMAT(/,'Fit parameters after going to a1= ',F8.2,' keV is:')
        WRITE(6,*)(a(i),i=1,NA)

C  Making the range curve spectrum
        DO i=0,8191
          Spec(i)=0
        ENDDO
        dim=2048
        DO i=0,dim-1
          xx=i+1
          Spec(i)=range(xx,A,ifunc)
        ENDDO

C Writing on file
        NAME='range-'//CHR
        WRITE(6,350)NAME(1:9)
 350    FORMAT('Type filename <',A,'>:',$)
        CALL READA(5,NAME)
        OPEN(20,FILE=NAME,ACCESS='SEQUENTIAL',IOSTAT=IOS)
        IF(IOS.NE.0)THEN
          WRITE(6,*) 'No file access'
          RETURN
        ENDIF
        COMMEN='Range curve for '//CHR(1:3)//' on silicon'
        CALL norw1dim(20,COMMEN,dim,Spec,Calib)
        CLOSE(20)
      ENDIF
 

C*********************************************************************
      IF(typefunc.EQ.4)THEN
        iOK = 0
        NA  = 2
        IF(Istatus.NE.0)GO TO 99
        IF(NA.GT.imax-idouble)THEN
          WRITE(6,*)'Number of parameters < independent data points'
          RETURN
        ENDIF

C Estimate parameters to be fitted
        IF(yl.LT.0)yl=0
        IF(yh.LT.0)yh=0
        A(1)=((0.5*alog((yh*xh*xh)/(yl*xl*xl)))**2)/(xh-2.*sqrt(xl*xh)+xl)
        A(2)=yl*xl*xl/exp(2.*sqrt(A(1)*xl))
        A(3)=yl

        WRITE(6,400)
 400    FORMAT(/'In order to start fit, start-values for the parameters',/,
     +         'have to be given. The default values are estimated from',/,
     +         'the y(x) values for the first (xl) and last (xh) point.',/,
     +         'You may start fitting with these values, or simply obtain',/,
     +         'the function with the given parameters (without fit).',/,
     +         ' ',/,
     +         'Your present fit-function looks like this (x=channels):',/,
     +         'Fermi(x) = A3 + A2 * EXP(2 * sqrt(A1*x)) / x*x')
 
 477    CONTINUE
        WRITE(6,401)  A(1)
 401    FORMAT(/'Give start value for A1 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,402)  A(2)
 402    FORMAT( 'Give start value for A2 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,403)  A(3)
 403    FORMAT( 'Give start value for A3 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(3))
        IF(Istatus.NE.0)RETURN

 499    IF(iOK.EQ.0)GO TO 488           !no fit yet
        ians=1
        Istatus=0
        WRITE(6,*)' '
        WRITE(6,*)'Give type of Chi**2 weighting:'
        WRITE(6,*)'Weighting with 1/Yexp(i) ............(0)'
        WRITE(6,*)'Weighting with 1.0 for all Yexp(i)...(1)'
        WRITE(6,*)'Return to mama ......................(2)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(ians.EQ.2)RETURN
        IF(ians.LT.0.OR.ians.GT.2)GO TO 477
        IF(Istatus.NE.0)GO TO 477
        IF(ians.EQ.0)MODE=-1
        IF(ians.EQ.1)MODE=0
 496    PROG  =0.0001
        M=0
        CHISQR=1.0E+10
        bCH   =1.0E+10
        NBAD  =0

        SIGMAA(1)=A(1)/10.
        DELTAA(1)=A(1)/10.
        SIGMAA(2)=A(2)/10.
        DELTAA(2)=A(2)/10.
        SIGMAA(3)=A(3)/10.
        DELTAA(3)=A(3)/10.
        DO i=1,imax
          logy(i)=0.
          IF(y(i).GT.0)logy(i)=log(y(i))
        ENDDO
        IF(iOK.EQ.0)GO TO 488           !no fit yet
 423    CALL GRIDLS(x,logy,SIGMAY,imax,MODE,lFermi1,A,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 423
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CH(M).LT.bCH)THEN
          bCH=CH(M)               !saving best values
          DO i=1,NA
            bSIGMAA(i)=SIGMAA(i)
            bA(i)     =A(i)
          ENDDO
        ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(NBAD.GT.4.OR.M.GE.500)GO TO 424
        IF(VER.GT.PROG) GO TO 423
 424    CONTINUE

        DO i=1,NA                !replacing best values
          SIGMAA(i)=bSIGMAA(i)
          A(i)     =bA(i)
        ENDDO

C Presenting results, both numerical and graphical
        WRITE(6,420)                                            
 420    FORMAT(/'Pair no.       X            Y          FIT')
        DO i=1,imax
          WRITE(6,421)i,x(i),y(i),Ffermi1(x(i),A)
 421      FORMAT(I4,3E13.3)
        ENDDO

        ch1=0.000
        IF(imax.GT.NA)ch1=bCH
        WRITE(6,431)ch1
 431    FORMAT('Chisquare:',E12.3)

C changed the following 6 lines A.S.
        WRITE(F7STR,432)NA
        WRITE(6,FMT=F7STR)'Fit parameters  a,   b,... =',(a(i),i=NA,1,-1)
 432    FORMAT('(A28,',I5.5,'E12.4)')
        WRITE(F8STR,433)NA
        WRITE(6,FMT=F8STR)'Uncertainty  siga,sigb,... =',(sigmaa(i),i=NA,1,-1)
 433    FORMAT('(A28,',I5.5,'E12.4)')

 488    IF(NA.EQ.2)THEN
          CALL SETCOLOR(ired+iOK*10)
          CALL PUTG('FermiRho',8,1,1)
          a0(1)=a(2)
          a1(1)=a(1)
        ENDIF
        IF(NA.EQ.3)THEN
          CALL SETCOLOR(igreen-iOK*3)
          CALL PUTG('a+FermiRho',10,1,1)
          a0(2)=a(3)
          a1(2)=a(2)
          a2(2)=a(1)
        ENDIF

        CALL CVXY(xx,yy,1,iy,2)
        yy=fFermi1(xx,A)
        CALL CVXY(xx,yy,ix,iy,1)
        CALL KTRAS(1,iy,0)
        DO ix=2,nx-30
          CALL CVXY(xx,yy,ix,iy,2)
          yy=fFermi1(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(ix,iy,1)
        ENDDO
        IF(iy.GT.ny-20)iy=ny-(NA+1)*10
        IF(iy.LT.10)   iy=NA*10
        CALL KTRAS(ix-20,iy+10,0)
        CALL FINIG

        IF(NA.EQ.2.AND.imax-idouble.GE.3)THEN
          NA=3
          IF(A(3).EQ.0)A(3)=0.1
          GO TO 496     ! a new fit with one more parameter
        ENDIF
        
        IF(iOK.EQ.1)GO TO 443
        NA   = 2
        iOK  = 0        ! no fit
        ians = 0        ! start fitting
        WRITE(6,*)' '
        WRITE(6,*)'Start fitting........................(0)'
        WRITE(6,*)'Modify the start parameters..........(1)'
        WRITE(6,*)'The function looks OK, do not fit....(2)'
        WRITE(6,*)'Return to mama.......................(3)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(Istatus.NE.0)GO TO 477
        IF(ians.EQ.0)iOK=1
        IF(ians.EQ.1)GO TO 477
        IF(ians.EQ.2)iOK=0
        IF(ians.EQ.3)RETURN
        IF(ians.LT.0.OR.ians.GT.3)GO TO 477
        IF(iOK.EQ.1)GO TO 499
        IF(iOK.EQ.0)GO TO 444

 443    WRITE(6,440)
 440    FORMAT(/,'Final result:')
        WRITE(6,441)a0(1),a1(1)
 441    FORMAT('y=a(x^-2)e^2sqrt(bx)   : a=',E14.6,' b=',E14.6)
        WRITE(6,442)a0(2),a1(2),a2(2)
 442    FORMAT('y=a+b(x^-2)e^2sqrt(cx) : a=',E14.6,' b=',E14.6,' c=',E14.6)
 444    CALL WriteFit(fFermi1,typefunc,a0,a1,a2,a3)
      ENDIF


C*********************************************************************
      IF(typefunc.EQ.5)THEN
        iOK = 0
        NA  = 2
        IF(Istatus.NE.0)GO TO 99
        IF(NA.GT.imax-idouble)THEN
          WRITE(6,*)'Number of parameters < independent data points'
          RETURN
        ENDIF

C Estimate parameters to be fitted
        IF(yl.LT.0)yl=0
        IF(yh.LT.0)yh=0
        A(1)=( (0.5*alog((yl/yh)*((xl/xh)**(3./2.))))**2 )/(xl-2.*sqrt(xl*xh)+xh)
        A(2)=yl*(xl**(3./2.))/exp(2.*sqrt(A(1)*xl))
        A(3)=yl

        WRITE(6,500)
 500    FORMAT(/'In order to start fit, start-values for the parameters',/,
     +         'have to be given. The default values are estimated from',/,
     +         'the y(x) values for the first (xl) and last (xh) point.',/,
     +         'You may start fitting with these values, or simply obtain',/,
     +         'the function with the given parameters (without fit).',/,
     +         ' ',/,
     +         'Your present fit-function looks like this (x=channels):',/,
     +         'Fermi(x) = A3 + A2 * EXP(2 * sqrt(A1*x)) / x**3/2')
 
 577    CONTINUE
        WRITE(6,501)  A(1)
 501    FORMAT(/'Give start value for A1 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,502)  A(2)
 502    FORMAT( 'Give start value for A2 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,503)  A(3)
 503    FORMAT( 'Give start value for A3 parameter  <',E11.4,'>:',$)
        CALL READF(5,A(3))
        IF(Istatus.NE.0)RETURN

 599    IF(iOK.EQ.0)GO TO 588           !no fit yet
        ians=1
        Istatus=0
        WRITE(6,*)' '
        WRITE(6,*)'Give type of Chi**2 weighting:'
        WRITE(6,*)'Weighting with 1/Yexp(i) ............(0)'
        WRITE(6,*)'Weighting with 1.0 for all Yexp(i)...(1)'
        WRITE(6,*)'Return to mama ......................(2)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(ians.EQ.2)RETURN
        IF(ians.LT.0.OR.ians.GT.2)GO TO 577
        IF(Istatus.NE.0)GO TO 577
        IF(ians.EQ.0)MODE=-1
        IF(ians.EQ.1)MODE=0
 596    PROG  =0.0001
        M=0
        CHISQR=1.0E+10
        bCH   =1.0E+10
        NBAD  =0

        SIGMAA(1)=A(1)/10.
        DELTAA(1)=A(1)/10.
        SIGMAA(2)=A(2)/10.
        DELTAA(2)=A(2)/10.
        SIGMAA(3)=A(3)/10.
        DELTAA(3)=A(3)/10.
        DO i=1,imax
          logy(i)=0.
          IF(y(i).GT.0)logy(i)=log(y(i))
        ENDDO
        IF(iOK.EQ.0)GO TO 588           !no fit yet
 523    CALL GRIDLS(x,logy,SIGMAY,imax,MODE,lFermi2,A,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 523
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CH(M).LT.bCH)THEN
          bCH=CH(M)               !saving best values
          DO i=1,NA
            bSIGMAA(i)=SIGMAA(i)
            bA(i)     =A(i)
          ENDDO
        ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(NBAD.GT.4.OR.M.GE.500)GO TO 524
        IF(VER.GT.PROG) GO TO 523
 524    CONTINUE

        DO i=1,NA                !replacing best values
          SIGMAA(i)=bSIGMAA(i)
          A(i)     =bA(i)
        ENDDO

C Presenting results, both numerical and graphical
        WRITE(6,520)                                            
 520    FORMAT(/'Pair no.       X            Y          FIT')
        DO i=1,imax
          WRITE(6,521)i,x(i),y(i),fFermi2(x(i),A)
 521      FORMAT(I4,3E13.3)
        ENDDO

        ch1=0.000
        IF(imax.GT.NA)ch1=bCH
        WRITE(6,531)ch1
 531    FORMAT('Chisquare:',E12.3)

C changed the following 6 lines A.S.
        WRITE(F9STR,532)NA
        WRITE(6,FMT=F9STR)'Fit parameters  a,   b,... =',(a(i),i=NA,1,-1)
 532    FORMAT('(A28,',I5.5,'E12.4)')
        WRITE(F0STR,533)NA
        WRITE(6,FMT=F0STR)'Uncertainty  siga,sigb,... =',(sigmaa(i),i=NA,1,-1)
 533    FORMAT('(A28,',I5.5,'E12.4)')

 588    IF(NA.EQ.2)THEN
          CALL SETCOLOR(ired+iOK*10)
          CALL PUTG('FermiRho',8,1,1)
          a0(1)=a(2)
          a1(1)=a(1)
        ENDIF
        IF(NA.EQ.3)THEN
          CALL SETCOLOR(igreen-iOK*3)
          CALL PUTG('a+FermiRho',10,1,1)
          a0(2)=a(3)
          a1(2)=a(2)
          a2(2)=a(1)
        ENDIF

        CALL CVXY(xx,yy,1,iy,2)
        yy=fFermi2(xx,A)
        CALL CVXY(xx,yy,ix,iy,1)
        CALL KTRAS(1,iy,0)
        DO ix=2,nx-30
          CALL CVXY(xx,yy,ix,iy,2)
          yy=fFermi2(xx,A)
          CALL CVXY(xx,yy,ix,iy,1)
          CALL KTRAS(ix,iy,1)
        ENDDO
        IF(iy.GT.ny-20)iy=ny-(NA+1)*10
        IF(iy.LT.10)   iy=NA*10
        CALL KTRAS(ix-20,iy+10,0)
        CALL FINIG

        IF(NA.EQ.2.AND.imax-idouble.GE.3)THEN
          NA=3
          IF(A(3).EQ.0)A(3)=0.1
          GO TO 596     ! a new fit with one more parameter
        ENDIF
        
        IF(iOK.EQ.1)GO TO 543
        NA   = 2
        iOK  = 0        ! no fit
        ians = 0        ! start fitting
        WRITE(6,*)' '
        WRITE(6,*)'Start fitting........................(0)'
        WRITE(6,*)'Modify the start parameters..........(1)'
        WRITE(6,*)'The function looks OK, do not fit....(2)'
        WRITE(6,*)'Return to mama.......................(3)'
        WRITE(6,1)ians
        CALL READI(5,ians)
        IF(Istatus.NE.0)GO TO 577
        IF(ians.EQ.0)iOK=1
        IF(ians.EQ.1)GO TO 577
        IF(ians.EQ.2)iOK=0
        IF(ians.EQ.3)RETURN
        IF(ians.LT.0.OR.ians.GT.3)GO TO 577
        IF(iOK.EQ.1)GO TO 599
        IF(iOK.EQ.0)GO TO 544

 543    WRITE(6,540)
 540    FORMAT(/,'Final result:')
        WRITE(6,541)a0(1),a1(1)
 541    FORMAT('y=a(x^-3/2)e^2sqrt(bx)   : a=',E14.6,' b=',E14.6)
        WRITE(6,542)a0(2),a1(2),a2(2)
 542    FORMAT('y=a+b(x^-3/2)e^2sqrt(cx) : a=',E14.6,' b=',E14.6,' c=',E14.6)
 544    CALL WriteFit(fFermi2,typefunc,a0,a1,a2,a3)
      ENDIF



      RETURN
      END


      SUBROUTINE WriteFit(func,typefunc,a0,a1,a2,a3)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      CHARACTER fname*8,comm*60

      CHARACTER COMMEN*60, ANS*1, NAME*80, FILNAM*80
      DIMENSION A(5), Spec(0:8191)
      DIMENSION a0(0:3),a1(0:3),a2(0:3),a3(0:3), Calib(6)
      INTEGER dim, typefunc
      COMMON/commonfit/NA


      DO i = 0,8191
        Spec(i) = 0.
      ENDDO
      DO i = 1,5
        A(i) = 0.
      ENDDO

      ANS='y'
      WRITE(6,1)ANS
 1    FORMAT(/'Save your fit-spectrum (y/n) <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(ANS.EQ.'N'.OR.ANS.EQ.'n') RETURN
      IF(Istatus.NE.0)RETURN

      NA = 2
      WRITE(6,2)NA
 2    FORMAT( 'How many free parameters     <',I1,'>:',$)
      CALL READI(5,NA)

      IF(typefunc.EQ.0)THEN
        IF(NA.LT.1.OR.NA.GT.4)THEN
          WRITE(6,*)'Sorry, you must have: 0 < number of parameters < 5'
          Istatus = 1
        ENDIF
      ENDIF
      IF(typefunc.EQ.1)THEN
        IF(NA.LT.1.OR.NA.GT.2)THEN
          WRITE(6,*)'Sorry, you must have: 0 < number of parameters < 3'
          Istatus = 1
        ENDIF
      ENDIF
      IF(typefunc.EQ.2)THEN
        IF(NA.LT.2.OR.NA.GT.3)THEN
          WRITE(6,*)'Sorry, you must have: 1 < number of parameters < 4'
          Istatus = 1
        ENDIF
      ENDIF
      IF(typefunc.EQ.4)THEN
        IF(NA.LT.2.OR.NA.GT.3)THEN
          WRITE(6,*)'Sorry, you must have: 1 < number of parameters < 4'
          Istatus = 1
        ENDIF
      ENDIF
      IF(typefunc.EQ.5)THEN
        IF(NA.LT.2.OR.NA.GT.3)THEN
          WRITE(6,*)'Sorry, you must have: 1 < number of parameters < 4'
          Istatus = 1
        ENDIF
      ENDIF

      IF(NA.GT.4.OR.NA.LT.1.OR.Istatus.NE.0)RETURN

      IF(NA.EQ.1)THEN
        A(1)=a0(0)
        A(2)=0
        A(3)=0
        A(4)=0
      ENDIF
      IF(NA.EQ.2)THEN
        A(1)=a1(1)
        A(2)=a0(1)
        A(3)=0
        A(4)=0
      ENDIF      
      IF(NA.EQ.3)THEN
        A(1)=a2(2)
        A(2)=a1(2)
        A(3)=a0(2)
        A(4)=0
      ENDIF
      IF(NA.EQ.4)THEN
        A(1)=a3(3)
        A(2)=a2(3)
        A(3)=a1(3)
        A(4)=a0(3)
      ENDIF

      IF(Istatus.NE.0)RETURN

      WRITE(6,23)  cal(2,IDEST,1,1)
      CALL READF(5,cal(2,IDEST,1,1))
      IF(Istatus.NE.0)RETURN
      WRITE(6,24)  cal(2,IDEST,1,2)
      CALL READF(5,cal(2,IDEST,1,2))
      IF(Istatus.NE.0)RETURN
      WRITE(6,25)  cal(2,IDEST,1,3)
      CALL READF(5,cal(2,IDEST,1,3))
 23   FORMAT(/'Cal. coeff. a0 (keV) on x-axis     <',F11.1,'>:',$)
 24   FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis  <',F11.3,'>:',$)
 25   FORMAT( 'Cal. coeff. a2 (keV/ch2) on x-axis <',E11.4,'>:',$)
      IF(Istatus.NE.0)RETURN

      m=0
      DO i=1,1
        DO j=1,3
          m=m+1
          Calib(m)=cal(2,IDEST,i,j)
        ENDDO
      ENDDO
      iCal=m

      LIN=MAX(64,MAXCH+1)
      WRITE(6,4)LIN
    4 FORMAT( 'Length of output-spectrum                 <',I4,'>:',$)
      CALL READI(5,LIN) 
      IF(Istatus.NE.0)RETURN
      dim=LIN

C  Making the fit curve spectrum
      DO i = 0,dim-1
        xx = i
        Spec(i)=func(xx,A)
      ENDDO

C Writing the file
      NAME='SPEC'
      WRITE(6,5)NAME(1:4)
  5   FORMAT( 'Filename                                  <',A,'>:',$)
      CALL READA(5,NAME)
      IF(Istatus.NE.0)RETURN
      CALL LENGDE(NAME,LIN)
      FILNAM=NAME(1:LIN) 
      OPEN(20,FILE=FILNAM,ACCESS='SEQUENTIAL',IOSTAT=IOS)
      IF(IOS.NE.0)THEN
        WRITE(6,*) 'No file access'
        RETURN
      ENDIF
      COMMEN='Fit-spectrum obtained with MAMA FD-command'
      CALL norw1dim(20,COMMEN,dim,Spec,Calib)
      CLOSE(20)

      END


      SUBROUTINE DSfunc(x,y,n,x1,x2,yl,yh,type)
      Integer type
      REAL x(1:200),y(1:200)
      CHARACTER*28 HEADING
C y      -vector containing the Y data points
C x      -vector containing the X data points
C n      -number of points
C x1,x2  -lower and higher limits for x-axis, if=0's, old display
C yl,yh  -lower and higher limits for y-axis, if=0's, old display
C type   -determines type of drawing:
C         = 0 draw line between points (theory) 
C         = 1 draw crosses for points (experiment)

      iblack=20
      CALL SETCOLOR(iblack)
      CALL INITG(NX,NY)
      IYAXIS=1
      IF(abs(x1)+abs(x2)+abs(yl)+abs(yh).GT.0)THEN ! New display
        CALL ERASE
        CALL LIMG(NX,0,NY,0)
        X0=x1
        DX=x2-x1
        Y0=yl
        DY=yh-yl
        CALL TRAX(DX,X0,DY,Y0,IYAXIS)  ! Draw axis
        CALL MSPOT(NX-4,-2)            ! Units on x-axis
        CALL PUTG('x',1,8,1)
        CALL MSPOT(7,NY+3)             ! Units on y-axis
        CALL PUTG('y',1,2,1)
        CALL DATETIME(HEADING)
        CALL MSPOT(NX/2,NY-20)
        CALL PUTG(HEADING,11,8,1)
c        DISP = .TRUE.
      ENDIF

      IF(type.EQ.0)THEN
        CALL PSPOT(x(1),y(1))
        DO i=2,n
          CALL VECT(x(i),y(i))
        ENDDO
      ELSE
        DO i=1,n
          CALL SYMBG(5,x(i),y(i),8,0.)   ! 5 = cross
        ENDDO                            ! 8 = size in pixels
      ENDIF

      CALL FINIG
      RETURN
      END


      FUNCTION dE(E,A)
      COMMON /THICK/d,ifunc
      DIMENSION A(5)
      INTEGER try
      EXTERNAL range
C Solving dE from the implicite equation d=R(E+dE)-R(E), where
C d is the thickness of the front detector. Making search by 
C Newton's method (I think), which is only working for
C monotonically functions. New estimate made by interpolation.
      try=0
      IF(E.LT.100)THEN    !Initializing
        x1=5.*(E+50.)
        x2=2.*x1
      ELSE
        x1=E/10               
        x2=2.*x1
      ENDIF

      rE =range(E,A,ifunc)
      dE =x2

101   y1 =range(E+x1,A,ifunc)-rE
      y2 =range(E+x2,A,ifunc)-rE
      IF(ABS(y1-y2).LT.0.001)GO TO 100
      
99    try=try+1
      x0 =(d-y1)*(x2-x1)/(y2-y1)+x1   !interpolating new guess
      IF(x0.LT.1.AND.try.LT.50)THEN   !desperate new guess
        x1=200
        x2=400
        dE=x2
        GO TO  101
      ENDIF

      y0  =range(E+x0,A,ifunc)-rE
  
      IF(ABS(y1-d).GT.ABS(y2-d))THEN  !storing best pair of values
        x1=x2
        y1=y2
      ENDIF
      x2=x0
      y2=y0
      IF(ABS(y2-d).GT.0.1.AND.try.LT.50)GO TO 99  ! 1/10 ch. accuracy

100   dE=x2

      RETURN
      END

      FUNCTION range(x,A,ifunc)
      DIMENSION A(5)
      range=0.
      IF(ABS(x+A(4)).LT.0.0000001)RETURN
      IF(ifunc.EQ.1)range=x*(A(1)+A(2)*x)+A(3)*x/(x+A(4))
      IF(ifunc.EQ.2)range=A(1)*(x** A(2))
      IF(ifunc.EQ.3)range=A(1)*(x**(A(2)+A(3)*log(x)))
      IF(ifunc.EQ.4)range=exp(A(1)+A(2)*log(x)+A(3)*log(x)*log(x))
      RETURN
      END

      FUNCTION fPol(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
C Sorry, for this stupid A(i) assignments, but too much work to change
C all other functions accordingly
      fPol=0.
      IF(NA.EQ.1)fPol=A(1)
      IF(NA.EQ.2)fPol=A(2)+A(1)*x
      IF(NA.EQ.3)fPol=A(3)+A(2)*x+A(1)*x*x
      IF(NA.EQ.4)fPol=A(4)+A(3)*x+A(2)*x*x+A(1)*x*x*x
      IF(NA.EQ.5)fPol=A(5)+A(4)*x+A(3)*x*x+A(2)*x*x*x+A(1)*x*x*x*x
      RETURN
      END

      FUNCTION fhyp(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      fhyp =0.
      IF(x.EQ.0)RETURN
      A2   =0.
      IF(NA.GE.2)A2=A(2)
      fhyp=A2+(A(1)/x)
      RETURN
      END

      FUNCTION fexp(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      fexp = 0.
      A3   = 0.
      IF(NA.GE.3)A3=A(3)
      z = A(1)*x
      IF(z.GT.88.)z=88.       ! we have single precision E+/-38
      IF(z.GT.-88.)THEN      
         fexp=A3+(A(2)*EXP(z))
      ENDIF
      RETURN
      END

      FUNCTION lexp(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      REAL lexp
      lexp = 0.
      xexp = 0.
      A3   = 0.
      IF(NA.GE.3)A3=A(3)
      z = A(1)*x
      IF(z.GT.88.)z=88.       ! we have single precision E+/-38
      IF(z.GT.-88.)THEN      
         xexp=A3+(A(2)*EXP(z))
      ENDIF
      IF(xexp.GT.0)THEN
        lexp=log(xexp)
      ELSE
        lexp=0.
      ENDIF    
      RETURN
      END

      FUNCTION fFermi1(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      fFermi1 = 0.
      A3      = 0.
      IF(NA.GE.3)A3=A(3)
      y=A(1)*x
      IF(y.GT.0.)THEN
        z=2.0*SQRT(y)
        IF(z.GT.88.)z=88.       ! we have single precision E+/-38
        IF(z.GT.-88.)THEN      
          fFermi1=A3+(A(2)*EXP(z)/(x*x))
        ENDIF
      ENDIF
      RETURN
      END

      FUNCTION lFermi1(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      REAL lFermi1
      lFermi1 = 0.
      Fermi1  = 0.
      A3      = 0.
      IF(NA.GE.3)A3=A(3)
      y=A(1)*x
      IF(y.GT.0.)THEN
        z=2.0*SQRT(y)
        IF(z.GT.88.)z=88.       ! we have single precision E+/-38
        IF(z.GT.-88.)THEN      
          Fermi1=A3+(A(2)*EXP(z)/(x*x))
        ENDIF
      ENDIF
      IF(Fermi1.GT.0)THEN
        lFermi1=log(Fermi1)
      ELSE
        lFermi1=0.
      ENDIF    
      RETURN
      END

      FUNCTION fFermi2(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      fFermi2 = 0.
      A3      = 0.
      IF(NA.GE.3)A3=A(3)
      y=A(1)*x
      IF(y.GT.0.)THEN
        z=2.0*SQRT(y)
        IF(z.GT.88.)z=88.       ! we have single precision E+/-38
        IF(z.GT.-88.)THEN      
          fFermi2=A3+(A(2)*EXP(z)/(x**(3./2.)))
        ENDIF
      ENDIF
      END
  
      FUNCTION lFermi2(x,A)
      DIMENSION A(5)
      COMMON/commonfit/NA
      REAL lFermi2
      lFermi2 = 0.
      Fermi2  = 0.
      A3      = 0.
      IF(NA.GE.3)A3=A(3)
      y=A(1)*x
      IF(y.GT.0.)THEN
        z=2.0*SQRT(y)
        IF(z.GT.88.)z=88.       ! we have single precision E+/-38
        IF(z.GT.-88.)THEN      
          Fermi2=A3+(A(2)*EXP(z)/(x**(3./2.)))
        ENDIF
      ENDIF
      IF(Fermi2.GT.0)THEN
        lFermi2=log(Fermi2)
      ELSE
        lFermi2=0.
      ENDIF      
      RETURN
      END
      REAL FUNCTION GETMKRCHNL(MN)
C     note: a function not a SUBROUTINE ....
C     above line is a flag for searches....

C        gets a channel that is within the acceptable fitting range....
C        INPUT: MN the Marker Number.
C        OUTPUT: GETMKRCHNL the channel number.
C        CALLed by CHNGMARK

C        local variables....
C                    MN is the Marker Number....
      INTEGER        MN
      CHARACTER*40   ANS

C        common blocks....

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
 
      COMMON /LUS/ IR,IW,IP,IG

      itry=0
10    IF (DISP .AND. HDX.GE.MCH(2) .AND. LDX.LE.MCH(1)) THEN
         CALL RETIC(X,Y,ANS)
         IF (ANS(1:1).NE.'T' .AND. ANS(1:1).NE.'t') GO TO 30
      ENDIF
20    CALL ASK(33HNew position=?(rtn for old value),33,ANS,JK)
      IF (JK.EQ.0) THEN
         IF (MN.GT.2) THEN
            GETMKRCHNL = PPOS(MN-2)
         ELSE
            GETMKRCHNL = MCH(MN)
         ENDIF
         RETURN
      ENDIF
      CALL FFIN(ANS,JK,X,RJ1,RJ2,*20)
      X = X + 0.5
      IF (X.LT.0.5 .OR. IFIX(X).GT.MAXCH) THEN
         WRITE (IW,*) ' Marker ch. outside spectrum - try again'
                  itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF

         GO TO 10
      ENDIF
30    IF (MN.GT.2) THEN
         IF (MCH(1).GT.IFIX(X) .OR. MCH(2).LT.IFIX(X)) THEN
            WRITE (IW,*) ' Peaks must be within limits - try again'
                  itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF

            GO TO 10
         ENDIF
         GETMKRCHNL = X - 0.5
      ELSE
C        boundary markers....
         DO 40 I = 1, NPKS
            IF ((MN.EQ.1 .AND. IFIX(X).GT.IFIX(PPOS(I))) .OR. 
     +          (MN.EQ.2 .AND. IFIX(X).LT.IFIX(PPOS(I)))) THEN
               WRITE(IW,*)' Peaks must be within limits, try again'
                  itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF

               GO TO 10
            ENDIF
40       CONTINUE
         GETMKRCHNL = X
      ENDIF
      END
      PROGRAM GF2
C Simplified by Magne

      CHARACTER*40 ANS
      WRITE(6,5)
 5    FORMAT(' ',/,
     +' ____________________________________________________'/
     +'|                                                    |'/ 
     +'|               Welcome to M A M A  6.0              |'/
     +'|                                                    |'/
     +'|   MAtrix MAnipulation, Oslo Cyclotron Laboratory   |'/
     +'|           Magne Guttormsen, November 2002          |'/
     +'|                                                    |'/
     +'|   MAMA handles 2 matrices of dimension 4096x512    |'/
     +'|       and 2 singles spectra of length 8192         |'/
     +'|                                                    |'/
     +'| Imortant commands:                                 |'/
     +'|  HE - help            ST - stop MAMA               |'/
     +'|  RE - read file       WR - write file              |'/
     +'|  DS - display spec.   CR - curser, activate spec.  |'/
     +'|  SD - display SIRIUS  OD - display OFFLINE         |'/
     +'|  HE NW - news                                      |'/
     +'|____________________________________________________|')

      CALL GFINIT(2) 
 10   CALL CASK('mama>',ANS,NC)
      IF (NC.GT.1) CALL GFEXEC(ANS,NC) !Decode and execute command
      GO TO 10                         !Ask for new command

      END
      SUBROUTINE GFEXEC(ANS,NC)
C          this subroutine decodes and executes the commands....

      CHARACTER*40 ANS
      INTEGER      NC

C --  SIRIUS
      integer	   type

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      INTEGER XDIM,YDIM
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3
      COMMON/REMEMBER/mlimit(0:19)
      COMMON/FREEZE/ifreeze

      INTEGER status,system,pid,getpid
      CHARACTER*5 pidnumber

      LOGICAL         DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/OL/I3,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      INTEGER         IWMODE
      CHARACTER*8     NWTSP
      REAL            WTSP(8192)
      COMMON /WTMODE/ IWMODE,NWTSP,WTSP

      INTEGER WINMOD, MAXSPEC
      LOGICAL READY, NOT_INT
      DATA WINMOD/0/,MAXSPEC/0/,READY/.FALSE./

      COMMON /LUS/ IR,IW,IP,IG

      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)

      INTEGER nColor(1:64)

      COMMON/SAVEOUTLAY/OLhi,OLlo,OLlc,OLhc
      REAL OLhi(64),OLlo(64),OLlc(64),OLhc(64)

      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM

      INTEGER*2 ICMNDS(90),ICMND
      DATA ICMNDS/
     +    'FT','LP','  ','  ','FX','FR','MA','  ','  ','DS',
     +    'DX','DY','DZ','SC','CR','UD','DF','CL','HE','PO',
     +    'WP','CE','IC','  ','SU','SE','CT','OM','EX','RP',
     +    'FI','TX','RA','  ','RW','CC','AP','DP','HC','PF',
     +    'SD','OD','OV','OS','NF','LS','DM','RF','  ','  ',
     +    '  ','  ','  ','  ','  ','  ','ME','  ','  ','ST',
     +    'RE','WR','AR','OL','UC','PC','SM','CO','PM','PA',
     +    'FN','RN','SH','RM','UN','FO','GR','XY','NO','CU',
     +    'NU','AN','TF','FD','FG','EL','CA','TR','UX','  '/

C Gets window parameters for use for F77 routines through
C COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      CALL GETGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)
c        write(6,*)FDX,FX0,FDY,FY0
c        write(6,*)IDX,IX0,IDY,IY0
c        write(6,*)IYFLAG

C This subroutine decodes and executes the commands
C Convert lower case to upper case characters
      DO I=1,2
         IC=ICHAR(ANS(I:I))
         IF (IC.GE.97.AND.IC.LE.122) ANS(I:I)=CHAR(IC-32)
      ENDDO

15    READ(ANS,'(A2)')ICMND
      DO K=1,90
         IF (ICMND.EQ.ICMNDS(K)) GO TO 70
      ENDDO

C Command cannot be recognized
999   WRITE(IW,*) 'Bad command'
      n=2
      IF(IR.EQ.5)CALL GFHELP(ANS(1:2))
      IF (IR.NE.5) THEN
         WRITE(IW,*) ' Bad command: ',ANS
         ANS='CF CHK'
         NC=6
         GO TO 15
      ENDIF
      GO TO 30

70    IDATA = 0
      IN    = 0
      IN2   = 0
      r1    = 0.
      r2    = 0.
      r3    = 0.

      GO TO (
     +  80,  90,  90,  90,  90,  90,  80,  90,  90,  80,
     +  79,  79,  79,  80,  80,  90,  90,  80,  90,  90,
     +  90,  90,  90,  90,  80,  90,  80,  80,  80,  80,
     +  90,  90,  90,  90,  80,  90,  90,  80,  90,  80,
     +  90,  90,  80,  80,  90,  90,  80,  90,  90,  90,
     +  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,
     +  90,  90,  90,  80,  90,  90,  90,  90,  90,  90,
     +  90,  90,  90,  90,  90,  90,  90,  90,  90,  90,
     +  90,  90,  90,  90,  90,  90,  90,  90,  90,  90),K


C       FT   LP             FX   FR   MA             DS
C       DX   DY   DZ   SC   CR   UD   DF   CL   HE   PO
C       WP   CE   IC        SU   SE   CT   OM   EX   RP
C       FI   TX   RA        RW   CC   AP   DP   HC   PF
C       SD   OD   OV   OS   NF   LS   DM   RF   
C                                     ME             ST
C       RE   WR   AR   OL   UC   PC   SM   CO   PM   PA      
C       FN   RN   SH   RM   UN   FO   GR   XY   NO   CU
C       NU   AN   TF   FD   FG   EL   CA   TR   UX

C Decode real input
79    CALL FFIN(ANS(3:40),NC-2,r1,r2,r3,*999)
      GO TO 90

C Decode integer input string where required
80    CALL ININ(ANS(3:40),NC-2,IDATA,IN,IN2,*999)

C Branch to execute mama command
90    GO TO (
     +  100,  200, 5900, 5900,  600,  600,  700, 5900, 5900, 1000,
     + 1100, 1200, 1300, 1400, 1500, 1600, 1700, 1800, 1900, 2000,
     + 2100, 2200, 2300, 5900, 2500, 2600, 2700, 2800, 2900, 3000,
     + 3100, 3200, 3300, 5900, 3500, 3600, 3700, 3800, 3900, 4000,
     + 4100, 4200,   95, 4400, 4500, 4600, 4700, 4800, 5900, 5900,
     + 5900, 5900, 5900, 5900, 5900, 5900, 1900, 5900, 5900, 6000,
     + 8100, 8120, 8140,   95, 8180, 8200, 8220, 8240, 8260, 8280,
     + 8300, 8320, 8340, 8360, 8380, 8400, 8420, 8440, 8460, 8480,
     + 8500, 8520, 8540, 8560, 8580, 8600, 8620, 8640, 8660, 5900),K

C Informing on new definitions
 95   WRITE(6,*)' '
      WRITE(6,*)'The following new commands operate now:'
      WRITE(6,*)'DS and OS - Display and Overlay Spectrum or matrix'
      WRITE(6,*)'DM and OM - Display and Overlay Multiple spectra'
      WRITE(6,*)'Please, use:'
      WRITE(6,*)'DM instead of old OL'
      WRITE(6,*)'OS instead of old OV'
      WRITE(6,*)'MP instead of old DM'
      GO TO 30

C Get limits etc. and/or do fit (FT)
100   IF (IDATA.LE.0 .AND. (.NOT.READY .OR. MCH(2).GT.MAXCH))
     +   GO TO 999
      IF (IDATA.GT.15) GO TO 999
      CALL DOFIT(IDATA,READY)
      GO TO 30

C List pars (LP)
200   CALL TYPEIT(1)
      GO TO 30

C Fix or free parameters (FX)
600   CALL FIXORFREE(ANS,NC)
      GO TO 30

C Change limits or peak positions (MA)
700   CALL CHNGMARK(IDATA)
      GO TO 30

C Display markers (DM)
800   IF (.NOT.READY) THEN
         WRITE(IW,*) 'Bad command: No fit defined'
      ELSEIF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet displayed'
      ELSE
         CALL DSPMKR(99)
      ENDIF
      GO TO 30

C Clear graphics screen and display spectrum (DS)
1000  CALL ERASE
      DO ic=1,64
        nColor(ic)=0
      ENDDO
      IF(ITYPE.GT.1)THEN
        CALL DSPMA(IDATA,IN,IN2) 
      ELSE
        ic=max0(IDATA,1)
        ic=min0(ic,64)
        IF(IN.EQ.0)ic=1
        ncolor(ic)=ncolor(ic)+1
        CALL DSPSP(IDATA,IN,IN2,*999)
      ENDIF
      GO TO 30

C Change low and high marker on X,Y and Z axis for display (DX) (DY) (DZ)
1100  IF(ITYPE.GT.1)THEN
        LDX=r1
        HDX=r2
        IF(LDX.GT.HDX)THEN
          WAIT=LDX
          LDX  =HDX
          HDX  =WAIT
        ENDIF
      ELSE
        LOCH=r1
        HICH=r2
        IF(LOCH.GT.HICH)THEN
          WAIT =LOCH
          LOCH =HICH
          HICH =WAIT
        ENDIF
      ENDIF
      DO i=1,64
        OLlc(i)=LDX
        OLhc(i)=HDX
      ENDDO
      IF(r1.EQ.1.AND.r2.EQ.0)CALL SetMarker(1,0,0)
      IF(r1.EQ.2.AND.r2.EQ.0)CALL SetMarker(2,0,0)
      CALL SetMarker(0,0,0)
      GO TO 30
1200  IF(ITYPE.GT.1)THEN
        LDY=r1
        HDY=r2
        IF(LDY.GT.HDY)THEN
          WAIT =LDY
          LDY  =HDY
          HDY  =WAIT
        ENDIF
      ELSE
        LOCNT=r1
        HICNT=r2
        IF(LOCNT.GT.HICNT)THEN
          WAIT=LOCNT
          LOCNT=HICNT
          HICNT=WAIT
        ENDIF
      ENDIF
      DO i=1,64
        OLlc(i)=LDY
        OLhc(i)=HDY
      ENDDO
      IF(r1.EQ.1.AND.r2.EQ.0)CALL SetMarker(0,1,0)
      IF(r1.EQ.2.AND.r2.EQ.0)CALL SetMarker(0,2,0)
      CALL SetMarker(0,0,0)
      GO TO 30
1300  LDZ=r1
      HDZ=r2
      IF((LDZ.EQ.0.AND.HDZ.EQ.-1).OR.(LDZ.EQ.-1))THEN !case of manual settings
      WRITE(6,*)'Manual setting of z-levels for 2-dim. plot chosen'
      WRITE(6,*)'By next ds command, you have to type the level-values'
      WRITE(6,*)'(In order to go back, type ds 1(reset) or ds 2(auto))'
        LDZ = -1
        HDZ = -1
      ENDIF
      IF(LDZ.GT.HDZ)THEN
        WAIT= LDZ
        LDZ  = HDZ
        HDZ  = WAIT
      ENDIF
      IF(Idistype.EQ.2)THEN
        OLlocnt=LDZ         !in case of OL command
        OLhicnt=HDZ
        DO i=1,64
          OLhi(i)=HDZ
          OLlo(i)=LDZ
        ENDDO
        IF(r1.EQ.2.AND.r2.EQ.0)iOL=3 !auto for outlay(i)
      ENDIF
      IF(LDZ.EQ.0)LDZ=0.0000001  
      IF(r1.EQ.1.AND.r2.EQ.0)CALL SetMarker(0,0,1)
      IF(r1.EQ.2.AND.r2.EQ.0)CALL SetMarker(0,0,2)
      GO TO 30

C Change scale lin, quad or log (SC)
1400  IF (IDATA.LT.-3.OR.IDATA.GT.3) GO TO 999     
      IYAXIS=IDATA
      CALL SetMarker(0,0,0)
      GO TO 30

C Call or dislay cursor (CR)
1500  IF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet displayed...'
      ELSEIF (IDATA.NE.0 .AND. (IDATA.LT.LDX .OR. IDATA.GT.HDX)) THEN
         WRITE(IW,*) 'Bad command: Channel outside displayed region...'
      ELSE
         CALL CURSE(IDATA)
      ENDIF
      GO TO 30

C UpDate SD or OD spectra (UD)
1600  WRITE(6,*) 'To terminate the update window, CLOSE it with the mouse.'
      OPEN(UNIT=7,FILE='updateinfo.dat',err=30)
      write(7,*)IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      write(7,*)XDIM,YDIM,MAXCH
      write(7,*)I3,iRC,m1,m2,Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      write(7,*)Limit,COLORMAP
      write(7,*)Istatus,ITYPE,IDEST,iCE,itext
      write(7,*)cal
      write(7,*)UNITx,UNITy,fname
      write(7,*)comm
      CLOSE(7)
      status=system('mamaupdate &')
      GO TO 30

C Display fit (DF)
1700  IF (.NOT.READY) THEN
         WRITE(IW,*) 'Bad command: No fit defined...'
      ELSEIF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet* displayed...'
      ELSE
         CALL DSPFIT
      ENDIF
      GO TO 30

C Calibration Lines for gammas (CL)
1800  status=system('cat /user/schiller/osloware/mama/doc/CalibLines')
      GO TO 30

C Get help and menues (HE) (ME)
1900  CALL GFHELP(ANS)
      GO TO 30

C POlynom fit to data (PO)
2000  CALL POLYFIT
      GO TO 30

C Write Paw file (WP)
2100  CALL WRITEPAW
      GO TO 30

C Channel/Energy on axis (CE)
2200  IF(iCE.EQ.0)THEN
        iCE=1
        WRITE(6,*)'Energy-display activated'
      ELSE
        iCE=0    
        WRITE(6,*)'Channel-display activated'
      ENDIF
      GO TO 30

C Icon selected (IC)
2300  IF(IDEST.EQ.1.and.ITYPE.GT.1)THEN
        IDEST=2
        ITYPE=3
        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
        CALL SetMarker(-1,-1,-1)
        GO TO 30
      ENDIF
      IF(IDEST.EQ.2.and.ITYPE.GT.1)THEN
        IDEST=1
        ITYPE=1
        MAXCH=Idim(2,IDEST,1)-1
        CALL SetMarker(-1,-1,-1)
        GO TO 30
      ENDIF
      IF(IDEST.EQ.1.and.ITYPE.EQ.1)THEN
        IDEST=2
        ITYPE=1
        MAXCH=Idim(2,IDEST,1)-1
        CALL SetMarker(-1,-1,-1)
        GO TO 30
      ENDIF
      IF(IDEST.EQ.2.and.ITYPE.EQ.1)THEN
        IDEST=1
        ITYPE=3
        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
        CALL SetMarker(-1,-1,-1)
        GO TO 30
      ENDIF
      GO TO 30

C Sum counts using cursor (SU)
2500  K=1
      CALL SUMCTS(K,IDATA,IN)
      GO TO 30

C Set Environment (SE)
2600  CALL ENVIRONMENT
      GO TO 30

C Set CounTs using cursor (CT)
2700  IF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet displayed'
      ELSE
         CALL SETCTS
      ENDIF
      GO TO 30

C Overlay multiple spectra (OM)
2800  iColSpecOld=COLORMAP(1) 
      ic=max0(IDATA,1)
      ic=min0(ic,64)
      IF(IN.EQ.0)ic=1
      ncolor(ic)=ncolor(ic)+1
      iColSpecNew=iColSpecOld+ncolor(ic)     !taking next color as default
      iColSpecNew= MOD(iColSpecNew-1,16)+1

      WRITE(6,2801)iColSpecNew
2801  FORMAT('Give color:',
     +     / '(1)blue       (5)medium sea   (9)sandy   (13)yellow3',
     +     /,'(2)deep sky   (6)green       (10)red     (14)yellow2',
     +     /,'(3)light sky  (7)brown       (11)coral   (15)yellow',       
     +     /,'(4)sea green  (8)chocolate   (12)orange  (16)peach <',I2,'>:',$)

      CALL READI(5,iColSpecNew)
      COLORMAP(1)=iColSpecNew

      DO ic=1,64
        nColor(ic)=0
      ENDDO
      IF(IDATA.GT.0)iOL=IDATA
      CALL OUTLAY(iOL)     !IDATA gives reset(1) or autoscaling(2,3)
      iOL=0
      COLORMAP(1)=iColSpecOld      !resetting color

      GO TO 30

C Expand spectrum display using cursor (EX)
2900  IF (.NOT.DISP) THEN
         WRITE(IW,*) 'Bad command: New spectrum not yet displayed'
         GO TO 30
      ENDIF

      IF(ITYPE.GT.1)THEN                !Matrix
        write(6,*)'Click two times for proper markers in matrix'
        CALL RETIC(X1,Y1,ANS)
        CALL RETIC(X2,Y2,ANS)
        LDX=X1
        HDX=X2
        LDY=Y1
        HDY=Y2
        IF(LDX.GT.HDX)THEN
          LDX=X2
          HDX=X1
        ENDIF
        IF(LDY.GT.HDY)THEN
          LDY=Y2
          HDY=Y1 
        ENDIF
        CALL SetMarker(0,0,0)
        GO TO 2950
      ELSE                              !Singles    
        write(6,*)'Click for lower and higher marker in spectrum'
        CALL RETIC(X1,Y,ANS)
        CALL RETIC(X2,Y,ANS)                  
        LOCH=X1
        HICH=X2
        IF(LOCH.GT.HICH)THEN
          LOCH=X2
          HICH=X1
        ENDIF
        CALL SetMarker(0,2,0)
        GO TO 2950
      ENDIF
      GO TO 30
 
C Clear and redraw graphics screen with new display limits, called by EX
2950  IF(ITYPE.GT.1)THEN
        DO ic=1,64
          nColor(ic)=0
        ENDDO
        IN2=IDATA
        CALL ERASE
c        CALL TXTMOD           
        IF (IDATA*IN.EQ.0)IDATA=0
        CALL DSPMA(IDATA,IN,IN2)
      ELSE
        IN2 = IDATA
        CALL ERASE
         DO ic=1,64
          nColor(ic)=0
        ENDDO
c        CALL TXTMOD
        IF (IDATA*IN.EQ.0) IDATA=0
        CALL DSPSP(IDATA,IN,IN2,*2960)
2960    CONTINUE
      ENDIF
      GO TO 30

C Fix/free relative peak positions (RP)
3000  IRELPOS=IDATA
      IF (IDATA.LT.1) THEN
         IRELPOS = 0
         WRITE(IW,*) 'Relative peak positions fixed'
      ELSE
         IRELPOS = 1
         WRITE(IW,*) 'Relative peak positions free to vary'
      ENDIF
      GO TO 30

C Channel/Energy on axis (FI)
3100  IF(ifreeze.EQ.0)THEN
        ifreeze=1
        WRITE(6,*)'Fixed x-y display activated (PM)'
      ELSE
        ifreeze=0    
        WRITE(6,*)'Fixed x-y display disactivated (PM)'
      ENDIF
      GO TO 30

C Text on/off on axis (TX)
3200  IF(itext.EQ.0)THEN
        itext=1
        WRITE(6,*)'Display with name/time is activated'
      ELSE
        itext=0    
        WRITE(6,*)'Display without name/time is activated'
      ENDIF
      GO TO 30

C RANDOMIZE SPECTRUM (RA)
3300  CALL RANDOMIZE
      GO TO 30

C Fix/free relative widths (RW)
3500  IF (IDATA.LT.1) THEN
         IRELW = 0
         WRITE(IW,*) 'Relative widths fixed'
      ELSE
         IRELW = 1
         WRITE(IW,*) 'Relative widths free to vary'
      ENDIF
      GO TO 30

C Change color map (CC)
3600  CALL CHANGECOL
      GO TO 30

C Add peak to fit (AP)
3700  MODE=1
      CALL ADDDELPK(MODE,IDATA,READY)
      GO TO 30

C Delete peak from fit (DP)
3800  MODE=2
      CALL ADDDELPK(MODE,IDATA,READY)
      GO TO 30

C Hardcopy of graphics screen, using snapshot-tool (HC)
3900  status=system('snapshot &')
      GO TO 30

C Set up peak find on spectrum display (PF)
 4000 CALL PEAKFIND
      GO TO 30


C -------------------------------------------------------------------
C     S I R I U S   E X T E N S I O N S*
C -------------------------------------------------------------------

C     Display spectra in shared memory from SIRIUS data acquistion system
C     Display offline spectra (OD)
C     Display online spectra  (SD)
4100  continue


c      call sirius_spectra( TYPE )
      if(TYPE.GT.0)then
        call ERASE
        IDEST=1
      endif
      call CLEANUP
C --  Display spectrum
      if ( TYPE .EQ. 2) then
        call DSPMA( IDATA, IN, IN2) 
      endif
      if( TYPE .EQ. 1) then
        call DSPSP( IDATA, IN, IN2, *999)
      endif
      go to 30

C     Display spectra in shared memory from OFFLINE off-line sorting system
4200  continue
c      call offline_spectra( TYPE )
      if(TYPE.GT.0)then
        call ERASE
        IDEST=1
      endif
      call CLEANUP
C --  Display spectrum
      if ( TYPE .EQ. 2) then
        call DSPMA( IDATA, IN, IN2) 
      endif
      if( TYPE .EQ. 1) then
        call DSPSP( IDATA, IN, IN2, *999)
      endif
      go to 30
C -------------------------------------------------------------------


C Overlay spectrum (OS)
4400  iColSpecOld=COLORMAP(1) 
      IF(ITYPE.EQ.1)THEN
        ic=max0(IDATA,1)
        ic=min0(ic,64)
        IF(IN.EQ.0)ic=1
        ncolor(ic)=ncolor(ic)+1
        iColSpecNew=iColSpecOld+ncolor(ic)-1    !taking next color as default
        iColSpecNew= MOD(iColSpecNew-1,16)+1

        WRITE(6,4401)iColSpecNew
4401    FORMAT('Give :',
     +     / '(1)blue       (5)medium sea   (9)sandy   (13)yellow3',
     +     /,'(2)deep sky   (6)green       (10)red     (14)yellow2',
     +     /,'(3)light sky  (7)brown       (11)coral   (15)yellow',       
     +     /,'(4)sea green  (8)chocolate   (12)orange  (16)peach <',I2,'>:',$)

        CALL READI(5,iColSpecNew)
        COLORMAP(1)=iColSpecNew
      ENDIF

      IF(ITYPE.GT.1)THEN
        CALL DSPMA(IDATA,IN,IN2) 
      ELSE
        CALL DSPSP(IDATA,IN,IN2,*999)
      ENDIF

      COLORMAP(1)=iColSpecOld      !resetting color

      GO TO 30

C Define new fit; use X with cursor to exit (NF)
4500  IDATA = 99
      CALL DOFIT(IDATA,READY)
      GO TO 30

C Unix command ls (LS)   
4600  status=system('ls')
      GO TO 30

C Display multiple spectra (DM)
4700  CALL ERASE
      DO ic=1,64
        nColor(ic)=0
      ENDDO
      IF(IDATA.GT.0)iOL=IDATA
      CALL OUTLAY(iOL)     !IDATA gives reset(1) or autoscaling(2,3)
      iOL=0
      GO TO 30

C Reset free parameters (RF)
4800  CALL PARSET(0)
      GO TO 30

C READ SPECTRUM FILE (RE)
8100    CALL READFILE
        GO TO 30

C WRITING SPECTRUM TO DISK (WR)
8120    CALL WRITEFILE
        GO TO 30

C ARITHMETIC (+-*/) (AR)
8140    CALL ARITHMETIC
        GO TO 30

C Correct 2-dim matrix from uncorrelated events (UC)
8180    CALL Uncorrelation
        GO TO 30

C PUT CONSTANT (OR ZERO) IN SPECTRUM (PC)
8200    CALL PUTCONST
        GO TO 30

C SMOOTHING SPECTRUM (SM)
8220    CALL SMOOTH
        GO TO 30

C COMPRESS SPECTRUM (CO)
8240    CALL COMP
        GO TO 30

C PROJECT MATRIX DOWN TO X OR Y AXIS (PM)
8260    CALL PROJ      
        GO TO 30

C MAKE A PARTITION IN THE XY-PLANE (PA)
8280    CALL MAKEPART
        GO TO 30

C FILL NEG. NUMB. WITH POS. COUNTS FROM NEIGHBOUR CHANNELS (FN)
8300    CALL FILLNEG
        GO TO 30

C REPLACE NEG. NUMBERS BY ZEROS (RN)
8320    CALL REPLACE
        GO TO 30

C SHOW SPECTRUM CONTENT AROUND CH=(X,Y) (SH)
8340    CALL SHOW
        GO TO 30

C MAKING RESPONE MATRIX (RM)
8360    CALL RESP
        GO TO 30

C UNFOLD SPECTRUM (UN)
8380    CALL UNFOLD
        GO TO 30

C FOLD SPECTRUM (FO)
8400    CALL FOLD
        GO TO 30

C GET RESPONE MATRIX INTO WORKING SPECTRUM (GR)
8420    CALL GETRESP
        GO TO 30

C INTERCHANGE X AND Y AXIS (XY)
8440    CALL INTERCH
        GO TO 30

C NORMALIZE TO 100000 ALONG X-AXIS (NO)
8460    CALL NORMALIZE
        GO TO 30

C MAKE A CUT IN THE XY-PLANE, EXAMPLE Ex=Ex-Eg (CU)
8480    CALL CUTPLANE
        GO TO 30

C CALCULATE LEVEL-DENSITY, EXP. N AND TEMPERATURE (NU)
8500    CALL NUTE
        GO TO 30

C CALCULATE EXPONENT N IN Egam**N (AN)
8520    CALL FITan
        GO TO 30

C MAKE FIT OF TOTAL LANSCAPE WITH JUST ONE SET OF a AND  n (TF)
8540    CALL LANDSCAPE
        GO TO 30

C FIT DATA WITH A FUNCTION (FD)
8560    CALL FUNCFIT
        GO TO 30

C EXTRACT 1.GENERATION GAMMA-SPECTRA (FG)
8580    CALL FIGEGA
        GO TO 30

C STRETCH OR COMRESS SPECTRA IN AN ELASTIC WAY (EL)
8600    CALL ELASTICM
        GO TO 30

C CALIBRATE SPECTRA (CA)
8620    CALL CALIBRATE
        GO TO 30

C PUTS SINGLES SPECTRUM INTO MATRIX (ONE OR SEVERAL EQUAL ROWS) (TR)
8640    CALL TRANS2MATRIX
        GO TO 30

C TYPE A UNIX COMMAND (UX)
8660    CALL UNIXCMD
        GO TO 30

5900  WRITE (IW,*)' This command is not yet implemented'
      GO TO 999

C         ST ; stop and exit....
6000  CALL ASKYN(36HAre you sure you want to exit? (y/n),36,*30)
c6000  CALL CASKYN('Are you sure you want to exit? (y/n)',IALT_RET)
         IF (IALT_RET.EQ.1) GO TO 30

C Here I try to delete the Welcome picture. The PID number use to be 2 more
C than the current mama-process
c      pid=getpid()
c      Iwelcome=pid+2
c      WRITE(pidnumber(1:5),778,ERR=777)Iwelcome
c778   FORMAT(I5)
c      status=system('kill -9 '//pidnumber(1:5)) 
c777   CALL EXIT(0)

      CALL EXIT(0)

30    CONTINUE
      CALL CLEANUP

      RETURN

      END


C=======================================================================

      SUBROUTINE GFFIN(MODE)

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      REAL          AREAS(15),DAREAS(15),CENTS(15)
      COMMON /AREA/ AREAS,DAREAS,CENTS
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
C       calc. areas, centroids and errors....

      R=PARS(4)/50.0
      R1=1.0-0.5*R
      BET=PARS(5)
      DO 320 I=1,NPKS
         IC=3*I+4
         Y=PARS(IC+1)/(BET*3.33021838)
         D=EXP(-Y*Y)/ERFC(Y)
         A=R*BET*D+1.06446705*PARS(IC+1)*R1
         AREAS(I)=A*PARS(IC+2)
         EH=A*ERRS(IC+2)
         ER=(2.0*BET*D-1.06446705*PARS(IC+1))*ERRS(4)/100.0
         EB=R*D*(1.0+2.0*Y*Y-1.12837917*D*Y)*ERRS(5)
         EW=(R1*1.06446705+0.600561216*R*D*(D/1.77245385-Y))*ERRS(IC+1)
         DAREAS(I)=SQRT(EH*EH+PARS(IC+2)*PARS(IC+2)*(ER*ER+EB*EB+EW*EW))
         CENTS(I)=PARS(IC)-R*BET*D*BET/A
320   CONTINUE
      IF (DISP) THEN
         IF (MODE.GT.0) CALL ASKYN(18HDisplay fit? (Y/N),18,*780)
C           display fit....
         CALL DSPFIT
      ENDIF

C     CALL ASKYN(22HType parameters? (Y/N),22,*800)
780   CALL TYPEIT(2)
      CALL TYPEIT(3)
c800   ans='n'
c      WRITE(6,401)ans
c401   FORMAT('Print parameters (y/n) <',A1,'>:',$)
c      CALL READA1(5,ans)
c      IF(ans.EQ.'n'.OR.ans.EQ.'N')CALL TYPEIT(3)

      RETURN
      END
      SUBROUTINE GFHELP(ANS)

C         ....on-line help....

      CHARACTER*40  ANS
      CHARACTER*80  LINE
      CHARACTER*200 FULLNAME
      COMMON /LUS/  IR,IW,IP,IG

C        convert ANS to upper case characters....
      DO 50 I=1,80
         IC=ICHAR(ANS(I:I))
         IF (IC.GE.97.AND.IC.LE.122) ANS(I:I)=CHAR(IC-32)
 50   CONTINUE

      IF (ANS(1:4).EQ.'HE/P' .OR. ANS(1:6).EQ.'HELP/P') THEN
C           print help....
         ILU = 3
         OPEN(ILU,FILE='gf2.hlp')
         ANS = 'HE SUM'
      ELSE
         ILU = IW
      ENDIF

C           replace "HE(LP)" with spaces....
      ANS(1:2)='  '
c      IF (ANS(3:4).EQ.'LP') ANS(3:4)='  '
C           then leading spaces are removed and 
C           the end of command pointer, J, is returned....
c      CALL SETEXT(ANS,'    ',J)
C           are there enough characters to specify a ?....
      IF (J.LE.1) THEN
         ANS = 'TOPICS'
      ELSEIF (J.LT.3) THEN
         GO TO 630
      ENDIF
  
      OPEN(11,FILE='/Users/magneg/Myprog/mama/doc/mama.hlp',STATUS='OLD',ERR=600)
C           clear text screen, scroll whole screen....
      IF (ILU.EQ.IW) THEN
         CALL TSCROL(0,0)
         CALL TXTCLR(0)
      ENDIF

C           search for indicator plus two or three letter command....
 510  READ(11,'(A)',END=610) LINE
      IF (LINE(1:6).NE.'>>>'//ANS(1:3)) GO TO 510

C           have found command... now copy file to terminal or print file....
 520  READ(11,'(A)',END=620) LINE
      IF (LINE(1:3).NE.'>>>') THEN
C           write line to terminal....
         DO 530 NC=80,2,-1
            IF (LINE(NC:NC).NE.' ') GO TO 540
 530     CONTINUE
 540     WRITE(ILU,'(1X,A)') LINE(1:NC)

      ELSEIF (ILU.EQ.IW .AND. LINE(1:8).EQ.'>>>>PAGE') THEN
C              end of page....
c         CALL INVERC
c         CALL CASK2('   ....Press any key for more, X to eXit help....',
c     +              ANS,NC,1)

          CALL CASK('....Type X to eXit, or return for more help....',ANS,NC)

c         CALL NORMC
         CALL TXTCLR(0)
         IF (ANS(1:1).EQ.'X' .OR. ANS(1:1).EQ.'x') GO TO 580

      ELSEIF (LINE(1:7).EQ.'>>>>END') THEN
C              end of command listing....
         GO TO 570

      ENDIF

C           get next line of help file....
      GO TO 520

C           ask for next topic....
 570  IF (ILU.EQ.IW) THEN
         REWIND (11)
         WRITE(IW,*) ' '
c572      CALL INVERC
c         CALL ASK(30H>Topic = ? (rtn to exit help) ,30,ANS,NC)
 572       CALL CASK('>Topic = ? (rtn to exit help) ',ANS,NC)

c         CALL NORMC
         IF (NC.EQ.1) THEN
            IF (ANS(1:1).EQ.'?') THEN
               ANS = 'TOP'
            ELSE
               GO TO 572
            ENDIF
         ENDIF
         CALL TXTCLR(0)
         IF (NC.EQ.0) GO TO 580
         DO 575 I=1,NC
            IC=ICHAR(ANS(I:I))
            IF (IC.GE.97.AND.IC.LE.122) ANS(I:I)=CHAR(IC-32)
 575     CONTINUE
         GO TO 510
      ENDIF

C           exit....
 580  IF (ILU.EQ.IW) CALL TSCROL(0,0)
 590  CLOSE(11,ERR=595)
 595  IF (ILU.NE.IW) CALL PR_AND_DEL_FILE(ILU)
      RETURN

C        error messages....
 600  WRITE(IW,*) 'File ',FULLNAME(1:IOFFSET+12),' not found.'
      GO TO 590
c 610  CALL INVERC
  610  WRITE(IW,*) 'Command ',ANS(1:3),' not found.'
c      CALL NORMC
      REWIND (11)
      ANS = 'TOP'
      GO TO 510
 620  WRITE(IW,*) '******* End of file encountered. ********'
      GO TO 570
 630  WRITE(IW,*) 'Need two or more characters of the command '
      WRITE(IW,*) 'Type HE<rtn> to get list of topics.'
      GO TO 590

      END
      SUBROUTINE GFINIT(MODE)

C        GF2 initialisation routine....
C        mode > 2 : included for use by other programs....
C        mode = 2 : check for existence of files gfinit.dat, .cmd....
C        mode = 1 : welcome and ask for initial estimates....

      REAL           FINEST(5), SWPARS(3)
      INTEGER        INFIX(3), INFIXRW, INFIXW
      COMMON /INEST/ FINEST,INFIX,SWPARS,INFIXRW,INFIXW
      DATA FINEST/10.0,0.0,0.0,0.0,0.25/, INFIX/3*0/,SWPARS/9.0,0.004,0.0/
      DATA INFIXW/1/,INFIXRW/1/

      DIMENSION IASC(0:9)
      INTEGER XDIM,YDIM
      CHARACTER TEX*4,APP*4,CH(4)*1
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
c      DATA MAXCH/8191/,XDIM/4096/,YDIM/512/          !dette gir gigantisk
                                                      !(ca.18 Mbyte) gf2.o

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/OL/I3,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      COMMON/sdod/ntelesc

      DATA DISP/.FALSE./,IYAXIS/1/,
     +     LDX/0/,HDX/4095/,LDY/0/,HDY/511/,LDZ/0.1/,HDZ/10000/,
     +     LOCH/0/,HICH/8191/,LOCNT/0/,HICNT/1000/,
     +     I3/2/,iRC/1/,m1/0/,m2/511/,Idistype/0/,ntelesc/8/,
     +     OLlow/0/,OLhigh/511/,OLlocnt/0/,OLhicnt/1000/

      COMMON/SAVEOUTLAY/OLhi,OLlo,OLlc,OLhc
      REAL OLhi(64),OLlo(64),OLlc(64),OLhc(64)

      CHARACTER*40 ANS
      COMMON /LUS/ IR,IW,IP,IG
      DATA IR/5/,IW/6/,IP/20/,IG/22/

      REAL*8         GAIN(6)
      INTEGER        ICAL, NTERMS
      COMMON /CALIB/ GAIN, ICAL, NTERMS
      DATA ICAL/1/,GAIN(2)/0.5/,NTERMS/2/

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS
      DATA IRELPOS/1/,NPKS/1/

      INTEGER         IWMODE
      CHARACTER*8     NWTSP
      REAL            WTSP(8192)
      COMMON /WTMODE/ IWMODE,NWTSP,WTSP
      DATA IWMODE/-1/

      INTEGER COLORMAP(20),Color(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Color
      REAL Limit(0:19)

      DATA COLORMAP /1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20/
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      DATA Istatus/0/,ITYPE/3/,IDEST/1/
      DATA fname(1,1)/'matrix1'/, fname(1,2)/'matrix2 '/,
     +     fname(2,1)/'singles1'/,fname(2,2)/'singles2'/

      COMMON/FREEZE/ifreeze
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3
      DATA iCE/0/,itext/1/,ifreeze/0/,UNITx0/'keV'/,UNITy0/'keV'/              


C Initialization starting
      XDIM= 4096
      YDIM=  512
      MAXCH=8191
      Idim(1,1,1)=XDIM      !matrix dimensions, 2 matrices and 2 axis
      Idim(1,2,1)=XDIM
      Idim(1,1,2)=YDIM
      Idim(1,2,2)=YDIM
      Idim(2,1,1)=MAXCH+1   !singles dimension
      Idim(2,2,1)=MAXCH+1

      IDEST=1               !Setting display markers for 2 matrices and 2 spectra
      ITYPE=3
      CALL SetMarker(1,1,1)
      IDEST=2
      ITYPE=3
      CALL SetMarker(1,1,1)
      IDEST=1
      ITYPE=1
      CALL SetMarker(1,1,0)
      IDEST=2
      ITYPE=1
      CALL SetMarker(1,1,0)
      IDEST=1
      ITYPE=3

C Calibration default. cal(i,j,k,l) i deduced from ITYPE
C i=1 is ITYPE=2,3 and i=2 is ITYPE=1 ,j=1/2,k=x/y-cal, (3-terms)
C ITYPE=1: singles spectrum. ITYPE=2 and 3 is 2-dimensional matrices
C j is destination IDEST or source ISP spectrum
      DO i=1,2
        DO j=1,2
          DO k=1,2
            DO l=1,3
              cal(i,j,k,l)=0.
            ENDDO
            cal(i,j,k,2)=1.
            IF(i.EQ.2.AND.k.EQ.2)cal(i,j,k,2)=0. ! y not in use for
          ENDDO                                  ! singles spectrum
        ENDDO
      ENDDO

C Making 0 - 511 as characterstring and put into APP(1)-APP(512)
      IASC(0)=48
      IASC(1)=49
      IASC(2)=50
      IASC(3)=51
      IASC(4)=52
      IASC(5)=53
      IASC(6)=54
      IASC(7)=55
      IASC(8)=56
      IASC(9)=57
   
      DO i=1,512
        N=1000
        II=i-1
        IISTAT=0
        JJ=1
        CH(1)=' '
        DO J=1,4
          IDIG=II/N
          CH(JJ)=CHAR(IASC(IDIG))
          IF(IDIG.EQ.0.AND.IISTAT.EQ.0)GO TO 11
          II=II-IDIG*N
          IISTAT=1
          JJ=JJ+1
 11       N=N/10
        ENDDO
        TEX=CH(1)//CH(2)//CH(3)//CH(4)
        LIN=LEN(TEX)
        APP(i)=TEX(1:LIN)
      ENDDO

      DO i=1,64
        OLlc(i)=0                  !Default values for 64 OutLay spectra
        OLhc(i)=511
        OLlo(i)=0
        OLhi(i)=1000 
      ENDDO

C Initialization finished
      CALL NORWAY
      Idistype=-3              !simplified display first time
      CALL DSPMA(0,0,0,*999)
      Idistype=0
      CALL CLEANUP

999   CONTINUE

      IF(MODE.GE.2) THEN
        OPEN(1,FILE='gfinit.dat',STATUS='OLD',ERR=300)
        READ (1,210) FINEST,INFIX
210     FORMAT(5F8.0/3I5)
        READ (1,220,ERR=585,END=585) SW1,SW2,SW3,INFIXW,INFIXRW
220     FORMAT(3F8.0/2I5)
        SWPARS(1)=SW1*SW1
        SWPARS(2)=SW2*SW2/1000.0
        SWPARS(3)=SW3*SW3/1000000.0
        CLOSE(1)
        OPEN(1,FILE='gfinit.cmd',STATUS='OLD',ERR=590)
        GO TO 350
300     OPEN(1,FILE='gfinit.cmd',STATUS='OLD',ERR=400)
350     CLOSE(1)
        CALL ASK2(29H    Press return for more....,29,ANS,NC,1)
        CALL ASK2(28HPress any key to continue...,28,ANS,K,1)
        ANS='CF gfinit'
        NC=9
        CALL COMFIL(ANS,NC)
      ENDIF
400   CONTINUE
585   NC=2
590   continue
      RETURN
      END

C=======================================================================

      SUBROUTINE GFSET

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      CHARACTER*40 ANS
      COMMON /LUS/ IR,IW,IP,IG

C       ask for limits for fit....
      itry=0
10    WRITE(IW,*) '  Limits for fit?  (hit T to type)'
      DO 70 N=1,2
         IF (.NOT.DISP) GO TO 30
         CALL RETIC(X,Y,ANS)
         IF (ANS(1:1).NE.'T' .AND. ANS(1:1).NE.'t') GO TO 60
30       CALL CASK('Limit = ?',ANS,K)
         CALL FFIN(ANS,K,CH,RJ1,RJ2,IALT_RET)
         IF (IALT_RET.EQ.1) GO TO 30
         MCH(N)=CH+0.5
         IF (MCH(N).GT.MAXCH) GO TO 40
         IF (MCH(N).GE.0) GO TO 70
40       WRITE(IW,*) 'Marker ch. outside spectrum - try again.'
         GO TO 30
60       MCH(N)=X
70    CONTINUE
      IF (MCH(2).GT.MCH(1)) GO TO 80
      LO=MCH(2)
      MCH(2)=MCH(1)
      MCH(1)=LO
80    IF (.NOT.DISP) GO TO 90
      CALL DSPMKR(1)
      CALL DSPMKR(2)

C       ask for peak positions....

90    IF (NPKS.LE.15) THEN
         WRITE(IW,*)' Peak positions? (hit T to type, R to restart)'
         DO 200 N=1,NPKS
110         IF (DISP) THEN
               CALL RETIC(X,Y,ANS)
               IF (ANS(1:1).EQ.'R' .OR. ANS(1:1).EQ.'r') GO TO 10
               PPOS(N)=X-0.5
            ENDIF
            IF (.NOT.DISP .OR.
     +          ANS(1:1).EQ.'T' .OR. ANS(1:1).EQ.'t') THEN
C               ....hit t for type....
120            CALL CASK('Peak position = ?',ANS,K)
               IF (ANS(1:1).EQ.'R' .OR. ANS(1:1).EQ.'r') GO TO 10
               CALL FFIN(ANS,K,PPOS(N),RJ1,RJ2,IALT_RET)
               IF (IALT_RET.EQ.1) GO TO 120
            ENDIF

            IF (IFIX(PPOS(N)).LT.MCH(1) .OR. 
     +          IFIX(PPOS(N)).GE.MCH(2)) THEN
               WRITE(IW,*)' Peaks must be within limits - try again.'
               itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF
               GO TO 110
            ENDIF
            IF (DISP) CALL DSPMKR(N+2)
200      CONTINUE

      ELSE
         WRITE(IW,*)
     +     ' Peak positions? (hit X when done, T to type, R to restart)'
         DO 300 N=1,15
210         IF (DISP) THEN
               CALL RETIC(X,Y,ANS)
               IF (ANS(1:1).EQ.'X' .OR. ANS(1:1).EQ.'x') GO TO 310
               IF (ANS(1:1).EQ.'R' .OR. ANS(1:1).EQ.'r') GO TO 10
               PPOS(N)=X-0.5
            ENDIF
            IF (.NOT.DISP .OR.
     +          ANS(1:1).EQ.'T' .OR. ANS(1:1).EQ.'t') THEN
C               ....hit t for type....
220            CALL CASK('Peak position=? (rtn when done)',ANS,K)
               IF (K.EQ.0) GO TO 310
               CALL FFIN(ANS,K,PPOS(N),RJ1,RJ2,IALT_RET)
               IF (IALT_RET.EQ.1) GO TO 220
            ENDIF

            IF (IFIX(PPOS(N)).LT.MCH(1) .OR. 
     +          IFIX(PPOS(N)).GE.MCH(2)) THEN
               WRITE(IW,*)' Peaks must be within limits - try again.'
               itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF
               GO TO 210
            ENDIF
            IF (DISP) CALL DSPMKR(N+2)
300      CONTINUE
310      NPKS = N - 1
         IF (NPKS.LE.0) RETURN
      ENDIF

C       ask for fixed pars....

      NPARS=3*(NPKS+2)
      DO I=1,NPARS
         IFIXED(I)=1
      ENDDO
      IRELPOS=1
      NFP=0
      CALL PARSET(-1)
      ANS = 'FX'
      NC=2
      CALL FIXORFREE(ANS,NC)
      RETURN
      END
      SUBROUTINE GRAX(X1,X2,DEX,NV,IYFLAG)

C           define tick-points for marking of axes....
C           a = low axis value....
C           b = high axis value....
C           dex = array of tick points....
C           nv = number of tick points....
C           kh = 1/2/3 for lin/sqrt/log axis....

      REAL DEX(14),DEX1(14),DEX2(14)
C Takes into account that A and B might be pos./neg. and not
C increasing, etc. Modified by Magne

      XA=X1
      XB=X2

      IF(XB.LT.XA)THEN
        WAIT=XA
        XA=XB
        XB=WAIT
      ENDIF

      IF(XA.GE.0.AND.XB.GE.0)THEN             !case (+1,+2) (normal)
        CALL MGRAX(XA,XB,DEX,NV,IYFLAG)   
        RETURN
      ENDIF

      IF(XA.LE.0.AND.XB.LT.0)THEN             !case (-2,-1)
        CALL MGRAX(ABS(XB),ABS(XA),DEX,NV,IYFLAG) 
        DO i=1,NV
          DEX(i)=-DEX(i)
        ENDDO  
        RETURN
      ENDIF

      IF(XA.LE.0.AND.XB.GE.0)THEN             !case (-1,+1)
        CALL MGRAX(0.,XB,DEX1,NV1,IYFLAG)
        CALL MGRAX(0.,ABS(XA),DEX2,NV2,IYFLAG)
        DEXX=DEX1(1)
        IF(DEX1(1).LT.DEX2(1))DEXX=DEX2(1)
        IF(NV1+NV2.GE.12)DEXX=DEXX*2.
C Going from 0 to positive
        DEX1(1)=0
        DO i=2,14
          DEX1(i)=DEX1(i-1)+DEXX
          IF(DEX1(i).GT.XB)GO TO 10
        ENDDO
  10    ih=i-1
C Going from 0 to negative
        DEX2(1)=0
        DO i=2,14 
          DEX2(i)=DEX2(i-1)-DEXX
          IF(DEX2(i).LT.XA)GO TO 11
        ENDDO
  11    il=i-1
C Putting together DEX(i)
        DO i=1,il-1
          DEX(i)=DEX2(il+1-i)
        ENDDO
        DEX(il)=0
        DO i=il+1,il+ih-1
          DEX(i)=DEX1(i+1-il)
        ENDDO
        NV=MIN(14,il+ih-1)
        RETURN
      ENDIF

      END


      SUBROUTINE MGRAX(A,B,DEX,NV,IYFLAG)

C           define tick-points for marking of axes....
C           a = low axis value....
C           b = high axis value....
C           dex = array of tick points....
C           nv = number of tick points....
C           kh = 1/2/3 for lin/sqrt/log axis....

      REAL DEX(14)
C Takes into account that A and B might be pos./neg. and not
C increasing, etc. Modified by Magne

      IF (IYFLAG.EQ.3) GO TO 40
C         linear or sqrt axis....
      X=B-A
      C=1.0
      IF(X.LT.1.)THEN
         DO K=1,10
            IF (X.GT.15.0) GO TO 18
            C=C/10.0
            X=X*10.0
         ENDDO
18       IF (X.LT.1.0) THEN
            TX=1
         ELSEIF(X.LT.15) THEN
            TX=2
         ELSEIF (X.LT.30) THEN
            TX=5
         ELSEIF (X.LT.75) THEN
            TX=10
         ELSE
            TX=10
         ENDIF
      ELSE
         DO K=1,10
            IF (X.LT.15.0) GO TO 20
            C=C*10.0
            X=X/10.0
         ENDDO
20       IF (X.LT.1.0) THEN
            TX=0.05
         ELSEIF(X.LT.1.5) THEN
            TX=0.1
         ELSEIF (X.LT.3.0) THEN
            TX=0.2
         ELSEIF (X.LT.7.5) THEN
            TX=0.5
         ELSE
            TX=1.0
         ENDIF
      ENDIF


      CTX=C*TX
      J=A/CTX
      C=CTX*J
      IF (C.LE.A) C=C+CTX
      DO 30 NV=1,14
         DEX(NV)=C
         C=C+CTX
         IF (C.GE.B) RETURN
30    CONTINUE
      NV=14
      RETURN

C        logarithmic axis....
  40   TX=ALOG(10.)
       J=ALOG(A)/TX
       K=ALOG(B-1.0)/TX
       C=10.0**J
       IF (K-J.LT.2) THEN
         DEX(1)=2.0*C
          DEX(2)=5.0*C
          DEX(3)=10.0*C
          DEX(4)=20.0*C
          DEX(5)=50.0*C
          NV=5
       ELSE
          NV=MIN(14,K-J)
          DO 60 I=1,NV
             C=C*10.0
             DEX(I)=C
 60       CONTINUE
       ENDIF

C New logarithmic approach (magne)
c  40   ratio=B/A
c       ndecaner=LOG10(ratio)
c       nlow=LOG10(A)
c       C=10.**nlow
c       DO nv=1,14
c          C=C*10.
c          DEX(i)=C
c          IF(C.GE.B)RETURN
c       ENDDO

      RETURN
      END
      SUBROUTINE GRIDLS(X,Y,SIGMAY,NPTS,MODE,FUNC,A,DELTAA,
     +SIGMAA,NA,YFIT,CHISQR)
       DIMENSION X(50000),Y(50000),SIGMAY(50000),A(5),DELTAA(5),
     +SIGMAA(5),YFIT(50000)
      INTEGER try

      NFREE=NPTS-NA
      IF(NFREE.EQ.0)NFREE=1
      FREE=NFREE
      CHISQR=0.
      IF(NFREE.LT.0)RETURN

      DO J=1,NA
C  EVALUATE CHI SQUARE AT FIRST TWO SEARCH POINTS
        DO I=1,NPTS
          XX=X(I)
          YFIT(I)=FUNC(XX,A)
        ENDDO
        CHISQ1=FCHISQ(Y,SIGMAY,NPTS,NFREE,MODE,YFIT)

        try=0
        DELTA=DELTAA(J)
   41   A(J)=A(J)+DELTA
        try=try+1
        ntry=try/1000
        IF(1000*ntry.EQ.try)THEN
          write(6,FMT='(A1,$)')'.'
          CALL FLUSH(6)
        ENDIF
        IF(try.GT.5000)THEN
          WRITE(6,*)'Warning, iteration stopped after 5000 tries'
          GO TO 81
        ENDIF

        DO I=1,NPTS
          XX=X(I)
          YFIT(I)=FUNC(XX,A)
        ENDDO
        CHISQ2=FCHISQ(Y,SIGMAY,NPTS,NFREE,MODE,YFIT)
        IF(CHISQ1-CHISQ2) 51,41,61

C  REVERSE DIRECTION OF SEARCH IF CHI SQUARE IS INCREASING
   51   DELTA=-DELTA
        A(J)=A(J)+DELTA
        DO I=1,NPTS
          XX=X(I)
          YFIT(I)=FUNC(XX,A)
        ENDDO
        SAVE=CHISQ1
        CHISQ1=CHISQ2
        CHISQ2=SAVE

C  INCREMENT A(J) UNTIL CHI SQUARE INCREASES
   61   try=try+1
        ntry=try/1000
        IF(1000*ntry.EQ.try)THEN
          write(6,FMT='(A1,$)')'.'
          CALL FLUSH(6)
        ENDIF
        IF(try.GT.5000)THEN
          WRITE(6,*)'Warning, iteration stopped after 5000 tries'
          GO TO 81
        ENDIF
        A(J)=A(J)+DELTA
        DO I=1,NPTS
          XX=X(I)
          YFIT(I)=FUNC(XX,A)
        ENDDO
        CHISQ3=FCHISQ(Y,SIGMAY,NPTS,NFREE,MODE,YFIT)
        IF(CHISQ3-CHISQ2) 71,81,81
   71   CHISQ1=CHISQ2
        CHISQ2=CHISQ3
        GO TO 61

C  FIND MIN OF PARABOLA DEFINED BY LAST THREE POINTS
   81   DELTA=DELTA*(1./(1.+(CHISQ1-CHISQ2)/(CHISQ3-CHISQ2))+0.5)
        A(J)=A(J)-DELTA
C Must be wrong to use FREE here, taken away, Magne, June 23. 2002
C Implemented by Andreas Schiller, June 26 2002
C        SIGMAA(J)=DELTAA(J)*SQRT(2./(FREE*(CHISQ3-2.*CHISQ2+CHISQ1)))
        SIGMAA(J)=DELTAA(J)*SQRT(2./(CHISQ3-2.*CHISQ2+CHISQ1))
      ENDDO

C  EVALUATE FIT AND CHI SQUARE FOR FINAL PARAMETERS
      DO I=1,NPTS
        XX=X(I)
        YFIT(I)=FUNC(XX,A)
      ENDDO
      CHISQR=FCHISQ(Y,SIGMAY,NPTS,NFREE,MODE,YFIT)
      RETURN
      END


      FUNCTION FCHISQ(Y,SIGMAY,NPTS,NFREE,MODE,YFIT)
      DIMENSION Y(50000),SIGMAY(50000),YFIT(50000)
      CHISQ=0.
      IF(NFREE) 13,13,20
   13 FCHISQ=0.
      GO TO 40

C  ACCUMULATE CHI SQUARE
c   20 DO 30 I=1,NPTS
c      IF(MODE)22,27,29
c   22 IF(Y(I))25,27,23
c   23 WEIGHT=1./Y(I)
c      GO TO 30
c   25 WEIGHT=1./(-Y(I))
c      GO TO 30
c   27 WEIGHT=1.
c      GO TO 30
c   29 WEIGHT=1./SIGMAY(I)**2
c   30 CHISQ=CHISQ+WEIGHT*(Y(I)-YFIT(I))**2
C Modified by Magne
   20  continue
       DO i=1,npts
         w=1.
         yy=ABS(Y(i))
         if(MODE.LT.0.AND.yy.NE.0.)        w=1./yy
         if(MODE.GT.0.AND.SIGMAY(i).NE.0.) w=1./SIGMAY(I)**2
         CHISQ=CHISQ+w*(Y(I)-YFIT(I))**2
       ENDDO
C  DIVIDE BY NUMBER OF DEGREES OF FREEDOM
      FREE=NFREE
      FCHISQ=CHISQ/FREE
   40 RETURN
      END


C======================================================================

      SUBROUTINE ININ(CIN,NC,IOUT1,IOUT2,IOUT3,*)

C           free format integer input routine....
C           up to three integers (IOUT1, IOUT2, IOUT3) decoded from CIN....
C           input fields separated by commas or spaces....
C           CIN = input character string          (input, up to char*80)....
C           NC  = no. of valid characters in CIN  (input, integer)....
C           IOUT1, IOUT2, IOUT3 = decoded numbers (output, integer)....
C           RETURN 1: invalid character in CIN....
C                    D.C. Radford   July 1985

      CHARACTER*(*) CIN
      INTEGER       NC, IOUT1, IOUT2, IOUT3, IOUT(3)
      CHARACTER*81  IN


      IN(1:NC)=CIN(1:NC)
      DO 10 N=1,3
         IOUT(N)=0
10    CONTINUE
      IF (NC.LT.1) GO TO 150
      ILO=1
      DO 100 N=1,3
15       IF (IN(ILO:ILO).EQ.' ') THEN
            ILO=ILO+1
            IF (ILO.GT.NC) GO TO 150
            GO TO 15
         ENDIF
         DO 20 I=ILO,NC
20          IF (IN(I:I).EQ.' ' .OR. IN(I:I).EQ.',') GO TO 30
         I=NC+1
30       IN(I:I)=','
         IHI=I-1
         IF (IHI.LT.ILO) GO TO 60
         DO 40 I=ILO,IHI
            IF ((IN(I:I).LT.'0' .OR. IN(I:I).GT.'9')
     +                  .AND. IN(I:I).NE.'-') GO TO 200
40       CONTINUE
         READ(IN(ILO:IHI),*)IOUT(N)
c50       FORMAT(I)
60       ILO=IHI+2
         IF (ILO.GT.NC) GO TO 150
100   CONTINUE
150   IOUT1=IOUT(1)
      IOUT2=IOUT(2)
      IOUT3=IOUT(3)
      RETURN
200   IOUT1=IOUT(1)
      IOUT2=IOUT(2)
      IOUT3=IOUT(3)
      RETURN 1
      END

C======================================================================

      SUBROUTINE ININ_FLG(CIN,NC,IOUT1,IOUT2,IOUT3,ERR_FLG)

C           free format integer input routine....
C           up to three integers (IOUT1, IOUT2, IOUT3) decoded from CIN....
C           input fields separated by commas or spaces....
C           CIN = input character string          (input, up to char*80)....
C           NC  = no. of valid characters in CIN  (input, integer)....
C           IOUT1, IOUT2, IOUT3 = decoded numbers (output, integer)....
C           ERR_FLG: FALSE for valid decode....
C                    TRUE for invalid character in CIN....
C                    D.C. Radford   Jan. 1992

      CHARACTER*(*) CIN
      INTEGER       NC, IOUT1, IOUT2, IOUT3
      LOGICAL       ERR_FLG


      ERR_FLG = .TRUE.
      CALL ININ(CIN,NC,IOUT1,IOUT2,IOUT3,*10)
      ERR_FLG = .FALSE.
10    RETURN
      END
      SUBROUTINE ARITHMETIC
      INTEGER XDIM,YDIM
      CHARACTER*40 ANS
      CHARACTER answ*1
      CHARACTER CH(2)*1
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      DIMENSION dydx(0:8191),yy(0:8191),xx(0:8191)
      CHARACTER func*3

C patched by Andreas Schiller, September 10 2003
C reason: make more standard repetitive format

C Added the following variable A.S.
      CHARACTER*8 F1STR

      imax=10
      jmax=10

      WRITE(6,1)
 1    FORMAT(/'Write your expression:            ',/,
     +        'adding spectra               1=1+2', /,      
     +        'adding constant              2=1+120.0',/,   
     +        'subtracting spectra          2=1-2',/,       
     +        'subtract constant            2=1-120.0',/,   
     +        'multiply spectra             2=1*2',/,       
     +        'multiply by constant         1=2*1.17',/,    
     +        'divide spectra               2=1/2',/,       
     +        'divide by constant           2=2/1.17',/,
     +        'multiply spectrum*matrix     1=1x1',/,
     +        'natural logarithm            2=2log',/,
     +        'derivate                     2=2der',/,
     +        'NOTE: Integer means spectra and real means constant')

C Reading in the answer as a string
      CALL CASK('Type your expression:',ANS,NC)
      IF(NC.LT.5)GO TO 99
         

C Scanning through the string and removing blanks
      NTOP=NC
      DO i=1,NC
        IF(ANS(i:i).EQ.' ')THEN
          NTOP=NTOP-1
          DO j=i,NTOP
            ANS(j:j)=ANS(j+1:j+1)          
          ENDDO
        ENDIF
      ENDDO
      DO i=NTOP+1,NC       
        ANS(i:i)=' '
      ENDDO
   
C Assumes manipulation only with spectra (no constants) (NTOP=5)
      CH(1) = ' '
      CH(2) = ' '
      func  = ' '
      I1    = 0
      I2    = 0
      IF(NTOP.EQ.5)THEN 
        READ(ANS(1:5),10,ERR=99)IDEST,CH(1),I1,CH(2),I2
 10     FORMAT(I1,A1,I1,A1,I1)
        IF(CH(1).NE.'=')GO TO 99
        IF(I2.GT.2.OR.I2.LT.1)GO TO 11 !It looks that you forgot
                                       !real for constant - interprets
                                       !as real and go to 11
        IF(IDEST.LT.1.OR.IDEST.GT.2.OR.
     +        I1.LT.1.OR.   I1.GT.2.OR.
     +        I2.LT.1.OR.   I2.GT.2)GO TO 99

C Adding
        IF(CH(2).EQ.'+')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                rMAT(IDEST,i,j)=rMAT(I1,i,j)+rMAT(I2,i,j)
                IF(rMAT(IDEST,i,j).NE.0.AND.j.GT.jmax)jmax=j
                IF(rMAT(IDEST,i,j).NE.0.AND.i.GT.imax)imax=i
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              rSPEC(IDEST,i)=rSPEC(I1,i)+rSPEC(I2,i)
              IF(rSPEC(IDEST,i).NE.0.AND.i.GT.imax)imax=i
            ENDDO
          ENDIF
        ENDIF

C Subtracting
        IF(CH(2).EQ.'-')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                rMAT(IDEST,i,j)=rMAT(I1,i,j)-rMAT(I2,i,j)         
                IF(rMAT(IDEST,i,j).NE.0.AND.j.GT.jmax)jmax=j
                IF(rMAT(IDEST,i,j).NE.0.AND.i.GT.imax)imax=i
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              rSPEC(IDEST,i)=rSPEC(I1,i)-rSPEC(I2,i)
              IF(rSPEC(IDEST,i).NE.0.AND.i.GT.imax)imax=i
            ENDDO
          ENDIF
        ENDIF

C Multiplying
        IF(CH(2).EQ.'*')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                rMAT(IDEST,i,j)=rMAT(I1,i,j)*rMAT(I2,i,j)
                IF(rMAT(IDEST,i,j).NE.0.AND.j.GT.jmax)jmax=j
                IF(rMAT(IDEST,i,j).NE.0.AND.i.GT.imax)imax=i
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              rSPEC(IDEST,i)=rSPEC(I1,i)*rSPEC(I2,i)
              IF(rSPEC(IDEST,i).NE.0.AND.i.GT.imax)imax=i
            ENDDO
          ENDIF
        ENDIF

C Multiplying matrix with spectrum
        IF(CH(2).EQ.'x')THEN
          iChange=1
          answ='x'
          WRITE(6,3)answ
   3      FORMAT('Multiply along x or y-axis        <',A1,'>:',$)
          CALL READA1(5,answ)
          IF(Istatus.NE.0)RETURN

          WRITE(6,4)I1
   4      FORMAT('Source single spectrum            <',I1,'>:',$)
          CALL READI(5,I1)
          IF(Istatus.NE.0)RETURN

          WRITE(6,5)I2
   5      FORMAT('Source matrix                     <',I1,'>:',$)
          CALL READI(5,I2)
          IF(Istatus.NE.0)RETURN
          ITYPE=3
          IF(answ.EQ.'x'.OR.answ.EQ.'X')THEN
            DO j=0,511 
              DO i=0,4095
                rMAT(IDEST,i,j)=rSPEC(I1,i)*rMAT(I2,i,j)
              ENDDO
            ENDDO
          ENDIF
          IF(answ.EQ.'y'.OR.answ.EQ.'Y')THEN
            DO j=0,511 
              DO i=0,4095
                rMAT(IDEST,i,j)=rSPEC(I1,j)*rMAT(I2,i,j)
              ENDDO
            ENDDO
          ENDIF
        ENDIF

C Dividing
        IF(CH(2).EQ.'/')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                x=rMAT(I2,i,j)
                IF(ABS(x).GT.0.00000001)THEN
                  x=rMAT(I1,i,j)/x
                  rMAT(IDEST,i,j)=x
                  IF(x.NE.0.AND.j.GT.jmax)jmax=j
                  IF(x.NE.0.AND.i.GT.imax)imax=i
                ELSE
                  rMAT(IDEST,i,j)=0
                ENDIF
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              x=rSPEC(I2,i)
              IF(ABS(x).GT.0.00000001)THEN
                x=rSPEC(I1,i)/x
                rSPEC(IDEST,i)=x
                IF(x.NE.0.AND.i.GT.imax)imax=i
              ELSE
                rSPEC(IDEST,i)=0
              ENDIF
            ENDDO
          ENDIF
        ENDIF
        IF(iChange.EQ.0)GO TO 99 
      ENDIF


C Assumes manipulation with constants (NTOP>5)
11    IF(NTOP.GT.5.OR.I2.GT.2.OR.I2.LT.1)THEN 
        READ(ANS(1:4),12,ERR=99)IDEST,CH(1),I1,CH(2)
12      FORMAT(I1,A1,I1,A1)
        READ(ANS(5:NTOP),*,ERR=97)const
97      READ(ANS(4:6),*,ERR=99)func !It was no constant, but maybe a function
        IF(CH(1).NE.'=')GO TO 99
        IF(IDEST.LT.1.OR.IDEST.GT.2.OR.
     +        I1.LT.1.OR.   I1.GT.2)GO TO 99

C Adding
        IF(CH(2).EQ.'+')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                x=rMAT(I1,i,j)+const
                rMAT(IDEST,i,j)=x
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              x=rSPEC(I1,i)+const
              rSPEC(IDEST,i)=x
            ENDDO
          ENDIF
        ENDIF

C Subtracting
        IF(CH(2).EQ.'-')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511 
              DO i=0,4095
                x=rMAT(I1,i,j)-const
                rMAT(IDEST,i,j)=x
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              x=rSPEC(I1,i)-const
              IF(x.NE.0)imax=i
              rSPEC(IDEST,i)=x
            ENDDO
          ENDIF
        ENDIF 

C Multiplying with constant
        IF(CH(2).EQ.'*')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511
              DO i=0,4095
                x=rMAT(I1,i,j)*const
                rMAT(IDEST,i,j)=x
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              x=rSPEC(I1,i)*const
              rSPEC(IDEST,i)=x
            ENDDO
          ENDIF  
        ENDIF

C Dividing with constant
        IF(CH(2).EQ.'/')THEN
          iChange=1
          IF(ITYPE.GT.1)THEN
            DO j=0,511
              DO i=0,4095
                IF(ABS(const).GT.0.00000001)THEN
                  x=rMAT(I1,i,j)/const
                  rMAT(IDEST,i,j)=x
                ELSE
                  rMAT(IDEST,i,j)=0
                ENDIF
              ENDDO
            ENDDO
          ELSE
            DO i=0,8191
              IF(ABS(const).GT.0.00000001)THEN
                x=rSPEC(I1,i)/const
                rSPEC(IDEST,i)=x
              ELSE
                rSPEC(IDEST,i)=0
              ENDIF
            ENDDO
          ENDIF   
        ENDIF
      ENDIF

C Section with functions applied to one spectrum/matrix
C Natural logarithm
      IF(func.EQ.'log'.OR.func.EQ.'LOG')THEN
        iChange=1
        IF(ITYPE.GT.1)THEN
          DO j=0,511
            DO i=0,4095
              y=rMAT(I1,i,j)
              IF(y.GT.0)THEN
                x=log(y)
                rMAT(IDEST,i,j)=x
              ELSE
                rMAT(IDEST,i,j)=0
              ENDIF
            ENDDO
          ENDDO
        ELSE
          DO i=0,8191
            y=rSPEC(I1,i)
            IF(y.GT.0)THEN
              x=log(y)
              rSPEC(IDEST,i)=x
            ELSE
              rSPEC(IDEST,i)=0
            ENDIF
          ENDDO
        ENDIF  
      ENDIF

C Derivate spectrum
      IF(func.EQ.'der'.OR.func.EQ.'DER')THEN
        iChange=1
        imax=2               !number of datapoints in fit for derivate
C Asking for the method to be applied
        WRITE(6,*)' '
        WRITE(6,*)'The algorithm steps through channel by channel'
        WRITE(6,*)'and calculates the derivate at that channel. '
        WRITE(6,*)'You can choose between the following methods: '
        WRITE(6,*)'---------------------------------------------------- '
        WRITE(6,*)'dy(i)/dx = (y(i) - y(i-1)) / (x(i) - x(i-1))     (1)'
        WRITE(6,*)'dy(i)/dx = (y(i+1) - y(i)) / (x(i+1) - x(i))     (2)'
        WRITE(6,*)'dy(i)/dx = (y(i+1)-y(i-1)) / (x(i+1)-x(i-1))     (3)'
        WRITE(6,*)'A least square fit of the linear or quadratic '
        WRITE(6,*)'function y(i) = b0 + b1*x(i) + b2*x(i)*x(i) is'
        WRITE(6,*)'performed for channels around the center-channel'
        WRITE(6,*)'giving dy(i)/dx = b1 + 2*b2*x(i).                (4)'
        WRITE(6,*)'---------------------------------------------------- '
        mode=4
        WRITE(6,20)mode
 20     FORMAT('Choose your method                                <',I1,'>:',$)
        CALL READI(5,mode)
        WRITE(6,*) ' '
        IF(Istatus.NE.0.OR.mode.LT.1.or.mode.GT.4)THEN
          WRITE(6,*) 'Illegal parameter, valid region:'
          WRITE(6,*) '0 < method < 5'
          RETURN
        ENDIF

        IF(mode.EQ.4)THEN
          iPol=1
          imax=4
          IF(imax.LT.3)imax=3
          WRITE(6,22)iPol
 22       FORMAT('Degree of polynom (linear = 1, quadratic = 2)     <',I1,'>:',$)
          CALL READI(5,iPol)
          imax=MAX(imax,iPol+1)
          WRITE(6,24)imax
 24       FORMAT('Number of datapoints                             <',I2,'>:',$)
          CALL READI(5,imax)
          IF(Istatus.NE.0.OR.iPol.LT.1.or.iPol.GT.2.
     +    OR.imax.GT.100.OR.imax.LT.2.OR.iPol.GE.imax)THEN
            WRITE(6,*) 'Illegal parameters, valid region:' 
            WRITE(6,*) '0 < polynom <   3'
            WRITE(6,*) '1 < points  < 101'
            WRITE(6,*) 'polynom < points'
            RETURN
          ENDIF
          IF(iPol.EQ.1)mode=4
          IF(iPol.EQ.2)mode=5
        ENDIF

        iDer=1
        WRITE(6,26)iDer
 26     FORMAT('Derivate with respect to channels (dx=dch) (1)',/,
     +         'or energies (dx=dE(keV)) - if calibrated   (2)    <',I1,'>:',$)
        CALL READI(5,iDer)

        IF(ITYPE.GT.1)THEN
          answ='x'
          WRITE(6,28)answ
 28       FORMAT('Derivate along x or y-axis                        <',A1,'>:',$)
          CALL READA1(5,answ)
          IF(Istatus.NE.0)RETURN
          IF(answ.EQ.'x'.OR.answ.EQ.'X')THEN
            DO i=0,4095
              xx(i)=i
              IF(iDer.EQ.2)xx(i)=cal(1,I1,1,1)+cal(1,I1,1,2)*FLOAT(i)+ cal(1,I1,1,3)*FLOAT(i)*FLOAT(i)
            ENDDO
            DO j=0,511 
              JT=(j/50)*50
              IF(JT.EQ.j)THEN
                write(6,FMT='(A1,$)')'.'
                call flush(6)
              ENDIF
              DO i=0,4095
                yy(i)=rMAT(I1,i,j)
              ENDDO
              CALL Derivate(dydx,yy,xx,4096,mode,imax)
              DO i=0,4095
                x=dydx(i)
                rMAT(IDEST,i,j)=x
              ENDDO
            ENDDO
          ENDIF
          IF(answ.EQ.'y'.OR.answ.EQ.'Y')THEN
            DO j=0,511
              xx(j)=j
              IF(iDer.EQ.2)xx(j)=cal(1,I1,2,1)+cal(1,I1,2,2)*FLOAT(j)+ cal(1,I1,2,3)*FLOAT(j)*FLOAT(j)
            ENDDO
            DO i=0,4095 
              IT=(i/400)*400
              IF(IT.EQ.i)THEN
                write(6,FMT='(A1,$)')'.'
                call flush(6)
              ENDIF
              DO j=0,511
                yy(j)=rMAT(I1,i,j)
              ENDDO
              CALL Derivate(dydx,yy,xx,512,mode,imax)
              DO j=0,511
                x=dydx(j)
                rMAT(IDEST,i,j)=x
              ENDDO
            ENDDO
          ENDIF
          WRITE(6,*)' '
        ELSE
          DO i=0,8191
            xx(i)=i
            IF(iDer.EQ.2)xx(i)=cal(2,I1,1,1)+cal(2,I1,1,2)*FLOAT(i)+ cal(2,I1,1,3)*FLOAT(i)*FLOAT(i)
          ENDDO
          DO i=0,8191
            yy(i)=rSPEC(I1,i)
          ENDDO
          CALL Derivate(dydx,yy,xx,8192,mode,imax)
          DO i=0,8191
            x=dydx(i)
            rSPEC(IDEST,i)=x
          ENDDO
        ENDIF  
        IF(iChange.EQ.0)GO TO 99 
      ENDIF

C Checking if consistent calibration and dimensions  
      IF(NTOP.EQ.5)THEN                                  !case:matrices/spectra
        IF(ITYPE.GT.1)THEN 
          Itesting=IDEST+I1+I2
          IF(Itesting.NE.3.OR.Itesting.NE.6)THEN 
            ax=cal(1,1,1,1)+cal(1,1,1,2)+cal(1,1,1,3)    !matrices
            bx=cal(1,2,1,1)+cal(1,2,1,2)+cal(1,2,1,3)
            ay=cal(1,1,2,1)+cal(1,1,2,2)+cal(1,1,2,3)
            by=cal(1,2,2,1)+cal(1,2,2,2)+cal(1,2,2,3)
            IF((ax.NE.bx).OR.(ay.NE.by))WRITE(6,*)
     +      'Warning, different cal. for matrix 1 and 2'
          ELSE
            ax=cal(1,1,1,1)+cal(1,1,1,2)+cal(1,1,1,3)    !singles
            bx=cal(1,2,1,1)+cal(1,2,1,2)+cal(1,2,1,3)
            IF(ax.NE.bx)WRITE(6,*)
     +      'Warning, different cal. for spec. 1 and 2'
          ENDIF
        ENDIF
      ENDIF

      IF(NTOP.GT.5)THEN                        !case: constant    
        IF(IDEST.NE.I1)THEN  
          IF(ITYPE.GT.1)THEN 
            ax=cal(1,1,1,1)+cal(1,1,1,2)+cal(1,1,1,3)
            bx=cal(1,2,1,1)+cal(1,2,1,2)+cal(1,2,1,3)
            ay=cal(1,1,2,1)+cal(1,1,2,2)+cal(1,1,2,3)
            by=cal(1,2,2,1)+cal(1,2,2,2)+cal(1,2,2,3)
            IF((ax.NE.bx).OR.(ay.NE.by))WRITE(6,*)
     +      'Warning, different cal. for matrix 1 and 2'
          ELSE
            ax=cal(1,1,1,1)+cal(1,1,1,2)+cal(1,1,1,3)
            bx=cal(1,2,1,1)+cal(1,2,1,2)+cal(1,2,1,3)
            IF(ax.NE.bx)WRITE(6,*)
     +      'Warning, different cal. for spec. 1 and 2'
          ENDIF
        ENDIF
      ENDIF

C Updating the calibration and dimensions
      IF(ITYPE.GT.1)THEN
        I12=1
        IF(IDEST.EQ.1)I12=2
        IF((cal(1,I12,1,2)+cal(1,I12,2,2)).NE.2.)THEN !looks like I12 is calibr.
          IF(I1.EQ.I12.OR.I2.EQ.I12)THEN
            cal(1,IDEST,1,1)=cal(1,I12,1,1)
            cal(1,IDEST,1,2)=cal(1,I12,1,2)
            cal(1,IDEST,1,3)=cal(1,I12,1,3)
            cal(1,IDEST,2,1)=cal(1,I12,2,1)
            cal(1,IDEST,2,2)=cal(1,I12,2,2)
            cal(1,IDEST,2,3)=cal(1,I12,2,3)
          ENDIF
        ENDIF
        XDIM=Idim(1,I1,1) !Choosing highest dimension
        YDIM=Idim(1,I1,2)
        IF(I1.GT.0.AND.I2.GT.0)THEN
          XDIM=MAX0(Idim(1,1,1),Idim(1,2,1))
          YDIM=MAX0(Idim(1,1,2),Idim(1,2,2))
          IF(imax.LE.Idim(1,1,1).AND.Idim(1,1,1).LE.Idim(1,2,1))XDIM=Idim(1,1,1)
          IF(imax.LE.Idim(1,2,1).AND.Idim(1,2,1).LE.Idim(1,1,1))XDIM=Idim(1,2,1)
          IF(jmax.LE.Idim(1,1,2).AND.Idim(1,1,2).LE.Idim(1,2,2))YDIM=Idim(1,1,2)
          IF(jmax.LE.Idim(1,2,2).AND.Idim(1,2,2).LE.Idim(1,1,2))YDIM=Idim(1,2,2)    
        ENDIF 
        CALL SetMarker(1,1,1)
      ELSE
        I12=1
        IF(IDEST.EQ.1)I12=2
        IF(cal(2,I12,1,2).NE.1.)THEN                 !looks like I12 is calibr.
          IF(I1.EQ.I12.OR.I2.EQ.I12)THEN
            cal(2,IDEST,1,1)=cal(2,I1,1,1)
            cal(2,IDEST,1,2)=cal(2,I1,1,2)
            cal(2,IDEST,1,3)=cal(2,I1,1,3)
          ENDIF
        ENDIF
        MAXCH=Idim(2,I1,1)-1
        IF(I1.GT.0.AND.I2.GT.0)THEN
          MAXCH=MAX0(Idim(2,1,1)-1,Idim(2,2,1)-1)
          IF(imax.LE.Idim(2,1,1).AND.Idim(2,1,1).LE.Idim(2,2,1))MAXCH=Idim(2,1,1)-1
          IF(imax.LE.Idim(2,2,1).AND.Idim(2,2,1).LE.Idim(2,1,1))MAXCH=Idim(2,2,1)-1
        ENDIF
        CALL SetMarker(1,2,0)

      ENDIF

C Updating comment in the heading of spectrum file
      xcomm(1:3)='AR:'
C changed the next three lines A.S.
      WRITE(F1STR,991)NTOP
      write(xcomm(4:4+NTOP),FMT=F1STR,ERR=997)ans
991   FORMAT('(A',I5.5,')')

997   I12=1
      IF(IDEST.EQ.1)I12=2
      IF(IDEST.NE.I1.AND.IDEST.NE.I2)THEN 
        IF(ITYPE.GT.1)THEN
          comm(1,IDEST) =comm(1,I12) !Taking over comments if everything is new
          fname(1,IDEST)=fname(1,I12)!Taking over name if everything is new
        ELSE
          comm(2,IDEST) =comm(2,I12)
          fname(2,IDEST)=fname(2,I12)
        ENDIF
      ENDIF
      CALL AddComment(xcomm,4+NTOP)

      RETURN

 99   Istatus=2
      WRITE(6,*)'Sorry, illegal syntax of expression: ',ANS
      RETURN
      END


      SUBROUTINE Derivate(dydx,y,x,dim,mode,imax)
C Routine to derivate spectra. The program calls the very
C old and nice SUBROUTINE MATINV(). User can choose between
C 5 algorithms.
C Magne Guttormsen, Oslo Cyclotron Laboratory, April 1998
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      DIMENSION dydx(0:8191),y(0:8191),x(0:8191)
      REAL*8 XMAT(3,3),sx1,sx2,sx3,sx4,sx0y,sx1y,sx2y
      INTEGER dim

C Initializing
      DO i=0,dim-1
        dydx(i)=0.
      ENDDO

C Finding mLow and mHigh markers
      mLow =0
      mHigh=dim-1
      DO i=0,dim-1
         IF(y(i).NE.0.AND.mLow.EQ.0)mLow=i
      ENDDO
      DO i=dim-1,0,-1
         IF(y(i).NE.0.AND.mHigh.EQ.dim-1)mHigh=i
      ENDDO
 
C The three simple methods
      IF(mode.EQ.1)THEN
         DO i=mLow+1,mHigh
            dx=x(i)-x(i-1)
            dy=y(i)-y(i-1)
            IF(dx.NE.0)dydx(i)=dy/dx
         ENDDO
         dydx(mLow)=dydx(mLow+1)
      ENDIF
      IF(mode.EQ.2)THEN
         DO i=mLow,mHigh-1
            dx=x(i+1)-x(i)
            dy=y(i+1)-y(i)
            IF(dx.NE.0)dydx(i)=dy/dx
         ENDDO
         dydx(mHigh)=dydx(mHigh-1)
      ENDIF
      IF(mode.EQ.3)THEN
         DO i=mLow+1,mHigh-1
            dx=x(i+1)-x(i-1)
            dy=y(i+1)-y(i-1)
            IF(dx.NE.0)dydx(i)=dy/dx
         ENDDO
         dydx(mLow) =dydx(mLow+1)
         dydx(mHigh)=dydx(mHigh-1)
      ENDIF

C The advanced method (see p.277 in M.R. Spiegel Prob & Stat)
C The number of points to fit is imax 
C Here is mode = 4 linear and mode = 5 quadratic
      IF(mode.EQ.4)THEN                     ! Linear fit
         DO i=mLow,mHigh
            sx1=0.
            sx2=0.
            sx0y=0.
            sx1y=0.
            dxdy=0.
            xi=(imax-1.)/2.
            xxi1=FLOAT(i)-xi
            xxi2=FLOAT(i)+xi
            i1=xxi1+0.5
            i2=xxi2+0.5
            IF(xxi1.LT.0)i1=xxi1-0.5
            IF(xxi2.LT.0)i2=xxi2-0.5
            IF(i1.LT.mLow)THEN
               i2=i2+(mLow-i1)
               i1=i1+(mLow-i1)
            ENDIF
            IF(i2.GT.mHigh)THEN
               i1=i1-(i2-mHigh)
               i2=i2-(i2-mHigh)
            ENDIF
            DO ii=i1,i2
               sx1=sx1+x(ii)
               sx2=sx2+x(ii)*x(ii)
               sx0y=sx0y+y(ii)
               sx1y=sx1y+x(ii)*y(ii)
            ENDDO
            XMAT(1,1)=imax
            XMAT(2,1)=sx1
            XMAT(1,2)=sx1
            XMAT(2,2)=sx2
            CALL MATINV(XMAT,2,3)
            a0=XMAT(1,1)*sx0y+XMAT(2,1)*sx1y
            a1=XMAT(1,2)*sx0y+XMAT(2,2)*sx1y
            dydx(i) = a1
         ENDDO
      ENDIF
      
      IF(mode.EQ.5)THEN                   ! Quadratic fit
         DO i=mLow,mHigh
            sx1=0.
            sx2=0.
            sx3=0.
            sx4=0.
            sx0y=0.
            sx1y=0.
            sx2y=0.
            xi=(imax-1.)/2.
            xxi1=FLOAT(i)-xi
            xxi2=FLOAT(i)+xi
            i1=xxi1+0.5
            i2=xxi2+0.5
            IF(xxi1.LT.0)i1=xxi1-0.5
            IF(xxi2.LT.0)i2=xxi2-0.5
            IF(i1.LT.mLow)THEN
               i2=i2+(mLow-i1)
               i1=i1+(mLow-i1)
            ENDIF
            IF(i2.GT.mHigh)THEN
               i1=i1-(i2-mHigh)
               i2=i2-(i2-mHigh)
            ENDIF
            DO ii=i1,i2
               sx1=sx1+x(ii)
               sx2=sx2+x(ii)*x(ii)
               sx3=sx3+x(ii)*x(ii)*x(ii)
               sx4=sx4+x(ii)*x(ii)*x(ii)*x(ii)
               sx0y=sx0y+y(ii)
               sx1y=sx1y+x(ii)*y(ii)
               sx2y=sx2y+x(ii)*x(ii)*y(ii)
            ENDDO
            XMAT(1,1)=imax
            XMAT(2,1)=sx1
            XMAT(3,1)=sx2
            XMAT(1,2)=sx1
            XMAT(2,2)=sx2
            XMAT(3,2)=sx3
            XMAT(1,3)=sx2
            XMAT(2,3)=sx3
            XMAT(3,3)=sx4
            CALL MATINV(XMAT,3,3)
            a0=XMAT(1,1)*sx0y+XMAT(2,1)*sx1y+XMAT(3,1)*sx2y
            a1=XMAT(1,2)*sx0y+XMAT(2,2)*sx1y+XMAT(3,2)*sx2y
            a2=XMAT(1,3)*sx0y+XMAT(2,3)*sx1y+XMAT(3,3)*sx2y
            dydx(i) = a1 + 2.0*a2*x(i)
         ENDDO
      ENDIF

      RETURN
      END

           
       SUBROUTINE AVERAGE(W,A1)
C REPLACES COUNTS IN SPECTRUM W(I) BY THE AVERAGE OVER FWHM=0.12
C AT 662 KEV, ETC.(OSLO 4/3-1988 /M. GUTTORMSEN)
       DIMENSION W(0:511),X(0:511),Y(0:511)
       NL=1
       IFW=0
       EGAM=A1
       IFW=.12*(SQRT(662.*EGAM))/A1
       IF(IFW.LT.2)IFW=2
       EGAM=(IFW/2)*A1
       IFW=.12*(SQRT(662.*EGAM))/A1
       IF(IFW.LT.2)IFW=2
       NH=NL+IFW
       L=0

   22  TEMP=0
       L=L+1
       DO 20 I=NL,NH
   20  TEMP=W(I)+TEMP
       Y(L)=TEMP/(NH-NL+1)
       X(L)=(NL+NH)/2.0
       NL=NH+1
       EGAM=(NL+IFW/2)*A1
       IFW=0.12*(SQRT(662.*EGAM))/A1
       IF(IFW.LT.2)IFW=2
       NH=NL+IFW
       IF(NH.LT.511) GO TO 22

       DO I=0,511
        DO J=0,L
         IF(I.LT.X(J)) THEN
          JJ=J-1
          GO TO 40
         ENDIF
        ENDDO
   40   CONTINUE
        IF(I.LE.X(1).OR.I.GE.X(L))THEN
         GO TO 41
        ENDIF
       W(I)=Y(JJ)+(Y(JJ+1)-Y(JJ))*(I-X(JJ))/(X(JJ+1)-X(JJ))
   41  CONTINUE
       ENDDO
       END


      SUBROUTINE CALIBRATE
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      IR=5
      IW=6
      IID=IDEST
      IIT=ITYPE
      WRITE(6,*)'Choose spectrum type and spectrum number'
      WRITE(6,2)
   2  FORMAT(/,
     1          '      singles spectrum               1',/,
     2          '      set of spectra NA-1, NA-2,...  2',/,
     3          '      2-dimensional spectrum         3')
      WRITE(6,3)IIT
   3  FORMAT(/'Please, choose your type       <',I1,'>:',$)
      CALL READI(5,IIT)
 
      WRITE(6,1)IID
   1  FORMAT( 'Spectrum to calibrate          <',I1,'>:',$)
      CALL READI(5,IID)
      IF(IID.LE.0.OR.IID.GE.3.OR.IIT.LE.0.OR.IIT.GE.4)THEN
        Istatus=2
      ENDIF
      IF(Istatus.NE.0)RETURN

      IDEST=IID
      ITYPE=IIT

      IF(ITYPE.GT.1)THEN
        WRITE(IW,23)cal(1,IDEST,1,1)
 23     FORMAT(/'Cal. coeff. a0 (keV) on x-axis    <',F11.1,'>:',$)
        CALL READF(IR,cal(1,IDEST,1,1))
        WRITE(IW,24)cal(1,IDEST,1,2)
 24     FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis <',F11.3,'>:',$)
        CALL READF(IR,cal(1,IDEST,1,2))
        WRITE(IW,25)cal(1,IDEST,1,3)
 25     FORMAT( 'Cal. coeff. a2 (keV/ch2) on x-axis<',E11.2,'>:',$)
        CALL READF(IR,cal(1,IDEST,1,3))
        IF(Istatus.NE.0)RETURN
        WRITE(IW,26)cal(1,IDEST,2,1)
 26     FORMAT(/'Cal. coeff. a0 (keV) on y-axis    <',F11.1,'>:',$)
        CALL READF(IR,cal(1,IDEST,2,1))
        WRITE(IW,27)cal(1,IDEST,2,2)
 27     FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis <',F11.3,'>:',$)
        CALL READF(IR,cal(1,IDEST,2,2))
        WRITE(IW,28)cal(1,IDEST,2,3)
 28     FORMAT( 'Cal. coeff. a2 (keV/ch2) on y-axis<',E11.2,'>:',$)
        CALL READF(IR,cal(1,IDEST,2,3))
        IF(Istatus.NE.0)RETURN

        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
        WRITE(IW,29)XDIM
 29     FORMAT(/'Dimension along x-axis of matrix <',I4,'>:',$)
        CALL READI(IR,XDIM)
        WRITE(IW,30)YDIM
 30     FORMAT( 'Dimension along y-axis of matrix <',I4,'>:',$)
        CALL READI(IR,YDIM)
        IF(Istatus.NE.0)RETURN
        IF(XDIM.GT.4096)XDIM=4096
        IF(YDIM.GT. 512)YDIM=512
        IF(XDIM.NE.Idim(1,IDEST,1))CALL SetMarker(1,0,0)
        IF(YDIM.NE.Idim(1,IDEST,2))CALL SetMarker(0,1,0)

      ELSE

        WRITE(IW,23)  cal(2,IDEST,1,1)
        CALL READF(IR,cal(2,IDEST,1,1))
        WRITE(IW,24)  cal(2,IDEST,1,2)
        CALL READF(IR,cal(2,IDEST,1,2))
        WRITE(IW,25)  cal(2,IDEST,1,3)
        CALL READF(IR,cal(2,IDEST,1,3))
        IF(Istatus.NE.0)RETURN

        IMAXCH=Idim(2,IDEST,1)
        WRITE(6,5)IMAXCH
  5     FORMAT(/'Dimension of singles spectrum <',I5,'>:',$)
        CALL READI(5,IMAXCH)
        MAXCH=IMAXCH-1
        IF(MAXCH.GT.8191)MAXCH=8191
        IF(IMAXCH.NE.Idim(2,IDEST,1))CALL SetMarker(1,0,0)
      ENDIF
      END


      SUBROUTINE COMP
      INTEGER XDIM,YDIM 
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      WRITE(6,*)'Compression factors must be integer. With a factor'
      WRITE(6,*)'of e.g. 3, channels 0,1,2,3 goes to 0,0,0,1'
      ICX=1
      ICY=1
 
      IF(ITYPE.GT.1)THEN
        WRITE(6,3)ICX
   3    FORMAT(/'Compression along x-axis <',I3,'>:',$)
        CALL READI(5,ICX)
        WRITE(6,4)ICY
   4    FORMAT( 'Compression along y-axis <',I3,'>:',$)
        CALL READI(5,ICY)
      
        IF(Istatus.NE.0)RETURN
        DO J=0,511
          DO I=0,4095
            rMAT(IDEST,I,J)=0
          ENDDO
        ENDDO
        DO J=0,511
          jt=((j+1)/30)*30
          IF(jt.EQ.j+1)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF
          JJ=J/ICY
          DO I=0,4095
            II=I/ICX
           rMAT(IDEST,II,JJ)=rMAT(IDEST,II,JJ)+rMAT(ISP,I,J)
          ENDDO
        ENDDO
        XDIM=Idim(1,ISP,1)/ICX
        YDIM=Idim(1,ISP,2)/ICY
        WRITE(6,*)' '
        WRITE(6,5)XDIM-1,YDIM-1
   5    FORMAT('New dimension (0:',I4,',0:',I4,')')

        ax0=cal(1,ISP,1,1)
        ax1=cal(1,ISP,1,2)
        ax2=cal(1,ISP,1,3)
        ay0=cal(1,ISP,2,1)
        ay1=cal(1,ISP,2,2)
        ay2=cal(1,ISP,2,3)

C Remember compression makes nontrivial changes in a0 and a1 (not a2)          
        b=(ICX-1.)/2.
        cal(1,IDEST,1,1)=ax0+ax1*b+ax2*b*b
        cal(1,IDEST,1,2)=ICX*(ax1+2.*ax2*b)
        cal(1,IDEST,1,3)=ICX*ICX*ax2

        b=(ICY-1.)/2.
        cal(1,IDEST,2,1)=ay0+ay1*b+ay2*b*b
        cal(1,IDEST,2,2)=ICY*(ay1+2.*ay2*b)
        cal(1,IDEST,2,3)=ICY*ICY*ay2

C Updating comment in the heading of spectrum file
        xcomm(1:3)='CO:'
        write(xcomm(4:7),991,ERR=997)ICX
991     FORMAT(I4)
        xcomm(8:8)='-'
        write(xcomm(9:12),991,ERR=997)ICY
        comm(1,IDEST)(1:60)=comm(1,ISP)(1:60)
997     CALL AddComment(xcomm,12)
        fname(1,IDEST)(1:8)=fname(1,ISP)(1:8)
        CALL SetMarker(1,1,2)

      ELSE
        WRITE(6,3)ICX
        CALL READI(5,ICX)
        IF(Istatus.NE.0)RETURN
        DO I=0,8191
          rSPEC(IDEST,I)=0
        ENDDO
        DO I=0,8191
          II=I/ICX
          rSPEC(IDEST,II)=rSPEC(IDEST,II)+rSPEC(ISP,I)
        ENDDO
          
        ax0=cal(2,ISP,1,1)
        ax1=cal(2,ISP,1,2)
        ax2=cal(2,ISP,1,3)
        b=(FLOAT(ICX)-1.)/2.
        cal(2,IDEST,1,1)=ax0+ax1*b+ax2*b*b
        cal(2,IDEST,1,2)=ICX*(ax1+2.*ax2*b)
        cal(2,IDEST,1,3)=ICX*ICX*ax2 
        MAXCH=(Idim(2,ISP,1)-1)/ICX
        WRITE(6,55)MAXCH
  55    FORMAT('New dimension (0:',I4,')')

C Updating comment in the heading of spectrum file
        xcomm(1:3)='CO:'
        write(xcomm(4:7),991,ERR=998)ICX
        comm(2,IDEST)(1:60)=comm(2,ISP)(1:60)
998     CALL AddComment(xcomm,7)
        fname(2,IDEST)(1:8)=fname(2,ISP)(1:8)
        CALL SetMarker(1,2,0)
      ENDIF
      END


      SUBROUTINE CUTPLANE
      INTEGER XDIM,YDIM,MX,MY,SX,SY
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
        
      IF(ITYPE.EQ.1)ITYPE=3
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(Istatus.NE.0)RETURN
             
      ISP=1
      IF(IDEST.EQ.1)ISP=2

C READING IN VARIOUS PARAMETERS TO BE USED
      AX0=cal(1,ISP,1,1)
      AX1=cal(1,ISP,1,2) 
      AY0=cal(1,ISP,2,1)
      AY1=cal(1,ISP,2,2)
      IF(AX0+AX1.EQ.1.)THEN
        AX0=11.
        AX1=20.
      ENDIF
      IF(AY0+AY1.EQ.1.)THEN
        AY0=9660.
        AY1=-120.
      ENDIF

      FACX=0.
      FACY=-1.
      WRITE(6,*)'The following default values correspond to the'
      WRITE(6,*)'transformation  Ex -> Ex  and  Ey -> Ey-Ex.'
      WRITE(6,*)'The calibrations on x- and y-axis are conserved.'

      WRITE(6,10)AX0
  10  FORMAT(/'Cal. coeff. a0 (keV) on x-axis   <',F8.1,'>:',$)
      CALL READF(5,AX0)
      WRITE(6,11)AX1
  11  FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis<',F8.1,'>:',$)
      CALL READF(5,AX1)

      WRITE(6,12)AY0
  12  FORMAT(/'Cal. coeff. a0 (keV) on y-axis   <',F8.1,'>:',$)
      CALL READF(5,AY0)
      WRITE(6,13)AY1
  13  FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis<',F8.1,'>:',$)
      CALL READF(5,AY1)

      IF(Istatus.NE.0)RETURN

      WRITE(6,14)FACX
  14  FORMAT(/'Give factor in transf.Ex=Ex+f*Ey, f=<',F5.1,'>:',$)
      CALL READF(5,FACX)
      WRITE(6,15)FACY
  15  FORMAT( 'Give factor in transf.Ey=Ey+f*Ex, f=<',F5.1,'>:',$)
      CALL READF(5,FACY)

      EXMAX=8000.0
      WRITE(6,16)EXMAX
  16  FORMAT(/'Give upper energy on x-axis (keV)<',F8.1,'>:',$)
      CALL READF(5,EXMAX)
      EYMAX=EXMAX
      WRITE(6,17)EYMAX
  17  FORMAT( 'Give upper energy on y-axis (keV)<',F8.1,'>:',$)
      CALL READF(5,EYMAX)
      IF(Istatus.NE.0)RETURN
      IMAX=((EXMAX-AX0)/AX1+0.5)
      JMAX=((EYMAX-AY0)/AY1+0.5)
      IMIN=(-AX0/AX1+0.5)
      JMIN=(-AY0/AY1+0.5)
      IF(IMIN.GT.IMAX)THEN
        I=IMIN
        IMIN=IMAX
        IMAX=I
      ENDIF
      IF(JMIN.GT.JMAX)THEN
        J=JMIN
        JMIN=JMAX
        JMAX=J
      ENDIF

      IF(IMAX.GT.4095)IMAX=4095
      IF(JMAX.GT.511 )JMAX=511
      IF(IMIN.LT.0   )IMIN=0
      IF(JMIN.LT.0   )JMIN=0
      WRITE(6,18)IMIN,IMAX,JMIN,JMAX
  18  FORMAT(/'Data taken from Chx= ',I4,'-',I4,
     +' and Chy= ',I4,'-',I4,/)

      DO J=0,511
        DO I=0,4095
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO

      XDIM=8
      YDIM=8
      DO J=JMIN,JMAX
        DO I=IMIN,IMAX
          EEX=AX0+AX1*I
          EEY=AY0+AY1*J
          EX=EEX+FACX*EEY
          EY=EEY+FACY*EEX
C WE NOW DISTRIBUTE THE COUNTS INTO APPROPRIATE CHANNELS, GENERALLY 4.
C FINDING FIRST THE MAIN CHANNEL (MX,MY) AND PUT SOME FRACTION INTO THE 3
C OTHER SIDE-CHANNELS (SX,MY), (MX,SY) AND (SX,SY)
          CX=(EX-AX0)/AX1
          CY=(EY-AY0)/AY1
          MX=CX+0.5
          MY=CY+0.5
          FX=CX-MX
          FY=CY-MY
          SX=MX+1
          SY=MY+1
          IF(FX.LT.0)SX=MX-1
          IF(FY.LT.0)SY=MY-1
          FX=ABS(FX)
          FY=ABS(FY)

C CALCULATING THE M1AREAS THAT A SQUARE AROUND (Ex,Ey) COVERS THE 4 CH.
          AX =FX     *(1.-FY)
          AY =(1.-FX)*FY
          AXY=FX     *FY

C CALCULATING THE NUMBER OF COUNTS TO BE PUT IN
          ITOT=rMAT(ISP,I,J)
          IX =AX *ITOT
          IY =AY *ITOT
          IXY=AXY*ITOT
          IM=ITOT-IX-IY-IXY

          IF(MX.GE.0.AND.MX.LE.4095.AND.MY.GE.0.AND.MY.LE. 511)THEN
            IF(MX.GT.XDIM)XDIM=MX  !Finding x- and y-dimensions
            IF(MY.GT.YDIM)YDIM=MY
            rMAT(IDEST,MX,MY)=rMAT(IDEST,MX,MY)+IM
            IF(SX.GE.0.AND.SX.LE.511)
     +      rMAT(IDEST,SX,MY)=rMAT(IDEST,SX,MY)+IX
            IF(SY.GE.0.AND.SY.LE.511 )
     +      rMAT(IDEST,MX,SY)=rMAT(IDEST,MX,SY)+IY
          ENDIF
          IF(SX.GE.0.AND.SX.LE.4095.AND.SY.GE.0.AND.SY.LE. 511)THEN
            rMAT(IDEST,SX,SY)=rMAT(IDEST,SX,SY)+IXY
          ENDIF
        ENDDO
      ENDDO
      cal(1,IDEST,1,1)=cal(1,ISP,1,1)
      cal(1,IDEST,1,2)=cal(1,ISP,1,2)
      cal(1,IDEST,1,3)=cal(1,ISP,1,3)
      cal(1,IDEST,2,1)=cal(1,ISP,2,1)
      cal(1,IDEST,2,2)=cal(1,ISP,2,2)
      cal(1,IDEST,2,3)=cal(1,ISP,2,3)

C Updating comment in the heading of spectrum file
      xcomm(1:3)='CU:'
      write(xcomm(4:11),991,ERR=997)FACx
991   FORMAT(F8.1)
      xcomm(12:12)='-'
      write(xcomm(13:20),991,ERR=997)FACy
997   fname(1,IDEST)='CU'//fname(1,ISP)(1:6)
      comm(1,IDEST)=comm(1,ISP)
      CALL AddComment(xcomm,20)
      CALL SetMarker(1,1,1)
      END


      SUBROUTINE ELASTICM
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      INTEGER XDIM,YDIM  
      CHARACTER APP*4
      CHARACTER ANS*1
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      DIMENSION Fi(0:8191),Ff(0:8191)

      A0f=0.
      A1f=0.
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(Istatus.NE.0)RETURN

C Zeroing matrices
      IF(ITYPE.GT.1)THEN
        DO j=0,511
           DO i=0,4095
             rMAT(IDEST,i,j)=0
           ENDDO
        ENDDO
      ELSE
        DO i=0,8191
          rSPEC(IDEST,i)=0
        ENDDO
      ENDIF
      DO i=0,8191
        Fi(i)=0.
        Ff(i)=0.
      ENDDO

C Setting default values
      ANS='x'
      IF(ITYPE.GT.1)THEN
        WRITE(6,3)ANS
   3    FORMAT(/,'Stretch/compress along x or y axis <',A1,'>:',$)
        CALL READA1(5,ANS)
      ENDIF

      IF(ANS.EQ.'X'.OR.ANS.EQ.'x')THEN
        IF(ITYPE.GT.1)THEN
          A0i=cal(1,ISP,1,1)
          A1i=cal(1,ISP,1,2)
        ELSE
          A0i=cal(2,ISP,1,1)
          A1i=cal(2,ISP,1,2)
        ENDIF
        A0f=A0i
        A1f=A1i
        WRITE(6,4)A0i
   4    FORMAT(/'Old a0 on x-axis  <',F8.3,'>:',$)
        CALL READF(5,A0i)
        WRITE(6,5)A1i
   5    FORMAT( 'Old a1 on x-axis  <',F8.3,'>:',$)
        CALL READF(5,A1i)
        WRITE(6,6)A0f
   6    FORMAT(/'New a0 on x-axis  <',F8.3,'>:',$)
        CALL READF(5,A0f)
        WRITE(6,7)A1f
   7    FORMAT( 'New a1 on x-axis  <',F8.3,'>:',$)
        CALL READF(5,A1f)
        IF(Istatus.NE.0)RETURN
        IF(A0f.EQ.0..AND.A1f.EQ.0.)RETURN

C Matrices
        IF(ITYPE.GT.1)THEN
          DO j=0,511
            JT=(J/10)*10
            IF(JT.EQ.J)THEN
              write(6,FMT='(A1,$)')'.'
              call flush(6)
            ENDIF
            Sum=0.
            DO i=0,4095
              Fi(i)=rMAT(ISP,i,j)     ! Fi(i) and Ff(i) real type
              Sum=Sum+Fi(i)
            ENDDO
            IF(Sum.NE.0)THEN
              CALL ELASTIC(Fi,Ff,A0i,A1i,A0f,A1f,4096,4096)
              DO i=0,4095
                rMAT(IDEST,i,j)=Ff(i)
                Fi(i)=0.
              ENDDO
            ENDIF
          ENDDO
          cal(1,IDEST,1,1)=A0f
          cal(1,IDEST,1,2)=A1f
          cal(1,IDEST,1,3)=0.
          cal(1,IDEST,2,1)=cal(1,ISP,2,1)
          cal(1,IDEST,2,2)=cal(1,ISP,2,2)
          cal(1,IDEST,2,3)=cal(1,ISP,2,3)
C Finding new dimension
          E1=A0i+A1i*0   
          E2=A0i+A1i*Idim(1,ISP,1)
          IC1=(E1-A0f)/A1f  +10     
          IC2=(E2-A0f)/A1f  +10    
          XDIM=MAX0(IC1,IC2)
          XDIM=MIN0(XDIM,4096)
          IF(XDIM.LT.1)XDIM=64
C Updating comment in the heading of spectrum file
          xcomm(1:4)='ELx:'
          fname(1,IDEST)=fname(1,ISP)
          comm(1,IDEST)=comm(1,ISP)
          CALL AddComment(xcomm,4)
          CALL SetMarker(1,1,2)
          WRITE(6,*)' '
        ELSE
C Singles spectrum
          Sum=0.
          DO i=0,8191
            Fi(i)=rSPEC(ISP,i)
            Sum=Sum+Fi(i)
          ENDDO
          IF(Sum.NE.0)THEN
            CALL ELASTIC(Fi,Ff,A0i,A1i,A0f,A1f,8192,8192)
            DO i=0,8191
              rSPEC(IDEST,i)=Ff(i)
              Fi(i)=0.
            ENDDO
          ENDIF
        ENDIF
        cal(2,IDEST,1,1)=A0f
        cal(2,IDEST,1,2)=A1f
        cal(2,IDEST,1,3)=0.
C Finding new dimension
        E1=A0i+A1i*0   
        E2=A0i+A1i*Idim(2,ISP,1)
        IC1=(E1-A0f)/A1f  +10     
        IC2=(E2-A0f)/A1f  +10    
        MAXCH=MAX0(IC1,IC2)
        MAXCH=MIN0(MAXCH,8191)
        IF(MAXCH.LT.1)MAXCH=4095
C Updating comment in the heading of spectrum file
         xcomm(1:4)='ELx:'
         fname(2,IDEST)=fname(2,ISP)
         comm(2,IDEST)=comm(2,ISP)
         CALL AddComment(xcomm,4)
        CALL SetMarker(1,2,0)
      ENDIF      
           
      IF(ANS.EQ.'Y'.OR.ANS.EQ.'y')THEN
        A0i=cal(1,ISP,2,1)
        A1i=cal(1,ISP,2,2)
        A0f=A0i
        A1f=A1i

        WRITE(6,14)A0i
  14    FORMAT(/'Old a0 on y-axis  <',F8.3,'>:',$)
        CALL READF(5,A0i)
        WRITE(6,15)A1i
  15    FORMAT( 'Old a1 on y-axis  <',F8.3,'>:',$)
        CALL READF(5,A1i)
        WRITE(6,16)A0f
  16    FORMAT(/'New a0 on y-axis  <',F8.3,'>:',$)
        CALL READF(5,A0f)
        WRITE(6,17)A1f
  17    FORMAT( 'New a1 on y-axis  <',F8.3,'>:',$)
        CALL READF(5,A1f)
        IF(Istatus.NE.0)RETURN
        IF(A0f.EQ.0..AND.A1f.EQ.0.)RETURN

C Only matrices have y-axis with more than one channel
        DO i=0,4095          
          IT=(I/100)*100
          IF(IT.EQ.I)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF

          Sum=0.
          DO j=0,511
            Fi(j)=rMAT(ISP,i,j)
            Sum=Sum+Fi(j)
          ENDDO
          IF(Sum.NE.0)THEN
            CALL ELASTIC(Fi,Ff,A0i,A1i,A0f,A1f,512,512)
            DO j=0,511
               rMAT(IDEST,i,j)=Ff(j)
               Fi(j)=0.
            ENDDO
          ENDIF
        ENDDO
        cal(1,IDEST,2,1)=A0f
        cal(1,IDEST,2,2)=A1f
        cal(1,IDEST,2,3)=0.
        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
C Finding new dimension
        E1=A0i+A1i*0   
        E2=A0i+A1i*Idim(1,ISP,2)
        IC1=(E1-A0f)/A1f  +10     
        IC2=(E2-A0f)/A1f  +10    
        YDIM=MAX0(IC1,IC2)
        YDIM=MIN0(YDIM,512)
        IF(YDIM.LT.1)YDIM=64
C Updating comment in the heading of spectrum file
          xcomm(1:4)='ELy:'
          fname(1,IDEST)=fname(1,ISP)
          comm(1,IDEST)=comm(1,ISP)
          CALL AddComment(xcomm,4)
          CALL SetMarker(1,1,2)
        WRITE(6,*)' '
      ENDIF
      END


      SUBROUTINE ELASTIC(Fi,Ff,A0i,A1i,A0f,A1f,Di,Df)
C The most magnificant stretch- and compress-routine
C ever created by a human beeing. It is complicated, but works! 
C The routine streches or compresses spectrum from initial
C calibration (A0i,A1i) to final (A0f,A1f). The dimensions
C of the real spectra are Di and Df. First channel is 0, so
C that the spectra occupy (0:D-1) channels.
C August 1994, Oslo Cyclotron Laboratory, Magne Guttormsen
      INTEGER Di,Df
      DIMENSION Fi(0:Di-1),Ff(0:Df-1)
C Testing
      IF(A1i.EQ.0.OR.A1f.EQ.0)RETURN
C Zeroing final spectrum
      DO i=0,Df-1
        Ff(i)=0.  
      ENDDO

C Case where no action is taken
      IF(A0i.EQ.A0f.AND.A1i.EQ.A1f)THEN
        DO i=0,MIN0(Di-1,Df-1)
          Ff(i)=Fi(i)
        ENDDO
        RETURN
      ENDIF

C Taking counts in initial spectrum and find where
C to put it in final spectrum. Then it is distributed on
C the channel(s). The loop goes through all the
C channels i of the initial spectrum

      IF(ABS(A1i/A1f).LT.2)THEN
        DO i=0,Di-1
          IF(Fi(i).EQ.0)GO TO 99
          EiL=A0i+A1i*(i-0.5)      !Step 1.0 chs left and right
          EiH=A0i+A1i*(i+0.5)
          CHf1=(EiL-A0f)/A1f       !CHf1 and CHf2 define limits where
          CHf2=(EiH-A0f)/A1f       !to put the counts in final spc.
          CHlength=ABS(CHf1-CHf2)  !Number of channels (float)
          CountCH=Fi(i)/CHlength   !Number of counts pr.ch unit
          CHfL=CHf1
          CHfH=CHf2
          IF(CHfL.GT.CHfH)THEN
            CHfL=CHf2
            CHfH=CHf1
          ENDIF
          j1=CHfL+0.5              
          j2=CHfH+0.5              !filling with CHwidth*CountCH 
          IF(j1.GE.Df.OR.j2.LT.0)GO TO 99
          nch=j2-j1+1
          IF(nch.EQ.1)THEN         !One channel to fill
            IF(j1.GE.0)Ff(j1)=Ff(j1)+Fi(i)
            GO TO 99
          ENDIF
          IF(nch.GT.1)THEN  !Two or three channels to fill
            Counts=CountCH*(j1+0.5-CHfL) !Fraction of left channel
            IF(j1.GE.0)Ff(j1)=Ff(j1)+Counts       
            Counts=CountCH*(CHfH+0.5-j2) !Fraction of right channel
            IF(j2.LE.Df-1)Ff(j2)=Ff(j2)+Counts
            DO j=j1+1,j2-1           !Filling in for whole chs.
              IF(j.GE.0.AND.j.LE.Df-1)Ff(j)=Ff(j)+CountCH
            ENDDO
          ENDIF
  99      CONTINUE
        ENDDO
      ELSE

C The counts will be distributed in the streching procedure as a triangle,
C which has its left and right tail overlaping with the center of the 
C next triangle. The heighth and basis of the triangle is called h and b:
C               x         x          x
C             x   x     x   x      x   x
C           x       x x       x   x      x
C         x          0          0          x
C       x          x   x      x  x           x
C     x          x       x  x      x           x
C   x          x           0         x           x

        b=2.0*A1i/A1f   !basis of triangle
        h=2.0/b         !height of triangle in order to get area=1
        alpha=h/(b/2.)  !slope of triangle tails
        DO i=0,Di-1
          IF(Fi(i).EQ.0)GO TO 98
          EiL=A0i+A1i*(i-1.)      !Step 1.0 chs left and right
          EiH=A0i+A1i*(i+1.)
          CHf1=(EiL-A0f)/A1f       !CHf1 and CHf2 define limits where
          CHf2=(EiH-A0f)/A1f       !to put the counts in final spc.
          CHfL=CHf1
          CHfH=CHf2
          IF(CHfL.GT.CHfH)THEN
            CHfL=CHf2
            CHfH=CHf1
          ENDIF
          j1=CHfL+1             
          j2=CHfH              
          IF(j1.GE.Df.OR.j2.LT.0)GO TO 98
          w=0.
          DO j=j1,j2
            IF(j.LT.CHfL+(b/2.))THEN
              w=alpha*(j-CHfL)                !up going slope
            ELSE 
              w=h-alpha*(j-(CHfL+(b/2.)))     !down going slope
            ENDIF
            IF(w.LT.-0.1)WRITE(6,*)'Warning, weight w < 0 : ',w
            IF(w.LT.0)w=0.
            IF(j.GE.0.AND.j.LE.Df-1)Ff(j)=Ff(j)+w*Fi(i)
          ENDDO
  98      CONTINUE
        ENDDO
      ENDIF
      END


      SUBROUTINE EXPONENT(NC)
      REAL N,NC,MASS
      COMMON/CALxy/AX0,AX1,AY0,AY1
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      DOUBLE PRECISION GAMW(0:4095)

C SUBROUTINE CALLED FROM NUTE TO CALCULATE THE EXPONENT N(ch). IT MIGHT
C BE CONSTANT (IF NC.NE.0) OR VARIABEL ACCORDING TO AXEL

      IF(NC.LT.0)THEN
        WRITE(6,*)'Exponent cannot be negative'
        Istatus=1
        RETURN
      ENDIF

      IF(NC.GT.0)THEN
        DO I=0,4095
           N(I)=NC
           EXPN(I)=(AX0+FLOAT(I)*AX1)**NC
        ENDDO
        RETURN
      ENDIF

C METHOD OF AXEL. USES THE TAIL OF A GIANT RESSONANCE WITH A WITDH OF
C 5000 KEV. WE PUT N=4 UP TO EX=3000 KEV. NB! THE FOLLOWING FORMULA HAS
C BEEN CALCULATED IN MEV-UNITS IN ORDER TO AVOID USE OF DOUBLE PRECISION
      IF(NC.EQ.0)THEN
        I3MEV=((3000.-AX0)/AX1 +0.5)
        E3MEV=(AX0+FLOAT(I3MEV)*AX1)/1000.
        FWHM=5.
        ER=80.*(MASS**(-1./3.))

        DO I=0,4095
          E1=(AX0+FLOAT(I)*AX1)/1000.
          N(I)=4.0
          IF(I.GE.I3MEV.AND.I.LT.10*I3MEV)THEN
            GAMW(I)=E1**4*FWHM/
     +      ((ER**2-E1**2)**2+(E1**2)*(FWHM**2))
            C=GAMW(I3MEV)/E3MEV**4
            N(I)=LOG(GAMW(I)/C)/LOG(E1)
          ENDIF
          EXPN(I)=(AX0+FLOAT(I)*AX1)**N(I)
        ENDDO

C WRITING THE N-VALUES IN THE CASE OF AXEL'S APPROACH
        ER=ER*1000.
        FWHM=FWHM*1000.
        WRITE(6,10)ER,FWHM
  10    FORMAT(/,' ASSUMED GIANT DIPOLE RESONANCE AT',F7.0,' keV',
     +' WITH A WIDTH OF',F6.0,' keV.')
        WRITE(6,11)
  11    FORMAT(' EXPONENT AS A FUNCTION OF GAMMA-ENERGY n(E):')
        EDELTA=1000.
        EG4=-EDELTA
        DO I=1,5
          EG1=EG4+EDELTA
          EG2=EG1+EDELTA
          EG3=EG2+EDELTA
          EG4=EG3+EDELTA
          I1=(EG1-AX0)/AX1+0.5
          I2=(EG2-AX0)/AX1+0.5
          I3=(EG3-AX0)/AX1+0.5
          I4=(EG4-AX0)/AX1+0.5
          IF(I1.LT.1)I1=1
          IF(I2.LT.1)I2=1
          IF(I3.LT.1)I3=1
          IF(I4.LT.1)I4=1
         WRITE(6,12)N(I1),EG1,N(I2),EG2,N(I3),EG3,N(I4),EG4
  12      FORMAT(2X,4(2X,F4.2,'(',F6.0,' keV)'))
        ENDDO
      ENDIF
      RETURN
      END


      SUBROUTINE FILLNEG
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF

      IF(Istatus.NE.0)RETURN
      NEGN1=0
      xNEGS1=0
      NEGN2=0
      xNEGS2=0


      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)

        WRITE(6,5)XDIM
 5      FORMAT(/'Dimension along x-axis <',I4,'>:',$)
        CALL READI(5,XDIM)
        WRITE(6,6)YDIM
 6      FORMAT( 'Dimension along y-axis <',I4,'>:',$)
        CALL READI(5,YDIM)
        DO J=0,511
          DO I=0,4095
            xx=rMAT(ISP,I,J)
            IF(xx.LT.0)THEN
              NEGN1=NEGN1+1
              xNEGS1=xNEGS1+xx
            ENDIF
          ENDDO
        ENDDO
        CALL FILL
        DO J=0,511
          DO I=0,4095
            xx=rMAT(IDEST,I,J)
            IF(xx.LT.0)THEN
              NEGN2=NEGN2+1
              xNEGS2=xNEGS2+xx
            ENDIF
          ENDDO
        ENDDO
        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='FN:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)

      ELSE
        MAXCH=Idim(2,ISP,1)-1
        IMAXCH=MAXCH+1
        WRITE(6,7)IMAXCH
 7      FORMAT(/'Dimension of spectrum <',I4,'>:',$)
        CALL READI(5,IMAXCH)
        MAXCH=IMAXCH-1
        DO I=0,8191
          xx=rSPEC(ISP,I)
          IF(xx.LT.0)THEN
            NEGN1=NEGN1+1
            xNEGS1=xNEGS1+xx
          ENDIF
        ENDDO
        CALL FILL
        DO I=0,8191
          xx=rSPEC(IDEST,I)
          IF(xx.LT.0)THEN
            NEGN2=NEGN2+1
            xNEGS2=xNEGS2+xx
          ENDIF
        ENDDO
        cal(2,IDEST,1,1)=cal(2,ISP,1,1)
        cal(2,IDEST,1,2)=cal(2,ISP,1,2)
        cal(2,IDEST,1,3)=cal(2,ISP,1,3)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='FN:'
        fname(2,IDEST)=fname(2,ISP)
        comm(2,IDEST)=comm(2,ISP)
        CALL AddComment(xcomm,3)
      ENDIF 

      WRITE(6,3)NEGN1,INT(xNEGS1)
  3   FORMAT(/'Before number of neg. ch. was:',I7,', with total counts:',I10)
      WRITE(6,4)NEGN2,INT(xNEGS2)
  4   FORMAT( 'After  number of neg. ch. is: ',I7,', with total counts:',I10)
      END
    

      SUBROUTINE FILL
      DIMENSION WEIGHT(-100:100,-100:100)
      INTEGER XDIM,YDIM,DELX,DELY
      REAL NEG, POS
      CHARACTER APP*4,ANS*1
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER answ*1
      ISP=1
      IF(IDEST.EQ.1)ISP=2

C Deleting very negative numbers first
      izero = 0
      IF(ITYPE.GT.1)THEN
        zmax = -1000000000.
        zmin =  1000000000.
        DO i = 0,XDIM-1
          DO j = 0,YDIM-1
            IF(rMAT(ISP,i,j).GT.zmax)zmax=rMAT(ISP,i,j)
            IF(rMAT(ISP,i,j).LT.zmin)zmin=rMAT(ISP,i,j)
          ENDDO
        ENDDO
        IF(zmin.GT.zmax)zmin=zmax
        WRITE(6,50)zmin,zmax
50      FORMAT(/,'Lowest and highest counts are (min,max) = (',E9.2,E9.2,')')
        answ='n'
        IF(zmin.LT.0.AND.ABS(zmin).GT.(0.1*ABS(zmax)))answ='y'
        WRITE(6,51)
51      FORMAT('You may now delete the most negative numbers before filling')
        WRITE(6,52)answ
52      FORMAT('Do you want to delete these negative counts     <',A1,'>:',$)
        CALL READA1(5,answ)
        IF(answ.EQ.'y'.OR.answ.EQ.'Y')THEN  
          izero = 1
          zmin = -(0.1*ABS(zmax))        
          WRITE(6,53)zmin
53        FORMAT('Counts < Limit will be deleted, Limit = <',E9.2,'>:',$)
          CALL READF(5,zmin)
        ENDIF
        IF(Istatus.NE.0)RETURN
      ELSE
        zmax = -1000000000.
        zmin =  1000000000.
        DO i = 0,MAXCH
            IF(rSPEC(ISP,i).GT.zmax)zmax=rSPEC(ISP,i)
            IF(rSPEC(ISP,i).LT.zmin)zmin=rSPEC(ISP,i)
        ENDDO
        IF(zmin.GT.zmax)zmin=zmax
        WRITE(6,60)zmin,zmax
60      FORMAT(/,'Lowest and highest counts are (min,max) = (',E9.2,E9.2,')')
        answ='n'
        IF(zmin.LT.0.AND.ABS(zmin).GT.ABS(zmax))answ='y'
        WRITE(6,61)
61      FORMAT('You may now delete the most negative numbers before filling')
        WRITE(6,62)answ
62      FORMAT('Do you want to delete these negative counts     <',A1,'>:',$)
        CALL READA1(5,answ)
        IF(answ.EQ.'y'.OR.answ.EQ.'Y')THEN  
          izero = 1
          zmin = -ABS(zmax)        
          WRITE(6,63)zmin
63        FORMAT('Counts < Limit will be deleted, Limit = <',E9.2,'>:',$)
          CALL READF(5,zmin)
        ENDIF
        IF(Istatus.NE.0)RETURN
      ENDIF

      IF(ITYPE.GT.1)THEN
        IXL=(XDIM/10.)+.5
        IXH=(XDIM-IXL)
        IYL=(YDIM/10.)+.5
        IYH=(YDIM-IYL)
        IF(IXL.LT.1)IXL=1
        IF(IXH.LT.1)IXH=1
        IF(IYL.LT.1)IYL=1
        IF(IYH.LT.1)IYH=1

        FWXL=1.
        FWXH=FWXL*SQRT(float(IXH/IXL))
        FWYL=1.
        FWYH=1.
        IF(XDIM.LT.2.OR.YDIM.LT.2)THEN
          WRITE(6,*)'Too small matrix'
          Istatus=1
          RETURN
        ENDIF
C New estimate from gamma-energies - if known (1MeV = 6% and 8MeV = 3 %)
        a0cal = cal(1,ISP,1,1)
        a1cal = cal(1,ISP,1,2)
        IF(a0cal + a1cal.NE.1)THEN
          Energ1 = a0cal + a1cal*FLOAT(IXL)
          Energ2 = a0cal + a1cal*FLOAT(IXH)
          fwh1 = 0.06 + ((0.03-0.06)*(Energ1-1000.)/(8000.-1000.))
          fwh2 = 0.06 + ((0.03-0.06)*(Energ2-1000.)/(8000.-1000.))
          FWXL = fwh1*(Energ1-a0cal)/a1cal
          FWXH = fwh2*(Energ2-a0cal)/a1cal
        ENDIF
      ELSE
        IXL=((MAXCH+1.)/10.)+.5
        IXH=((MAXCH+1.)-IXL)
        IF(IXL.LT.1)IXL=1
        IF(IXH.LT.1)IXH=1
        IYL=0
        IYH=0
        FWXL=1.
        FWXH=FWXL*SQRT(float(IXH/IXL))
        FWYL=0
        FWYH=0
        IF(MAXCH.LE.1)THEN
          WRITE(6,*)'Too short spectrum'
          Istatus=1
          RETURN
        ENDIF
C New estimate from gamma-energies - if known
        a0cal = cal(2,ISP,1,1)
        a1cal = cal(2,ISP,1,2)
        IF(a0cal+a1cal.NE.1)THEN
          Energ1 = a0cal + a1cal*FLOAT(IXL)
          Energ2 = a0cal + a1cal*FLOAT(IXH)
          fwh1 = 0.06 + ((0.03-0.06)*(Energ1-1000.)/(8000.-1000.))
          fwh2 = 0.06 + ((0.03-0.06)*(Energ2-1000.)/(8000.-1000.))
          FWXL = fwh1*(Energ1-a0cal)/a1cal
          FWXH = fwh2*(Energ2-a0cal)/a1cal
        ENDIF
      ENDIF

 
 34   CONTINUE
      WRITE(6,10)IXL,FWXL
 10   FORMAT(/'Write FWHMx (ch) around ch x= ',I4,' <',F6.1,'>:',$)
      CALL READF(5,FWXL)
      WRITE(6,11)IXH,FWXH
 11   FORMAT( 'Write FWHMx (ch) around ch x= ',I4,' <',F6.1,'>:',$)
      CALL READF(5,FWXH)
      IF(Istatus.NE.0)RETURN

      IF(ITYPE.GT.1)THEN
        WRITE(6,20)IYL,FWYL
 20     FORMAT(/'Write FWHMy (ch) around ch y= ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWYL)
        WRITE(6,21)IYH,FWYH
 21     FORMAT( 'Write FWHMy (ch) around ch y= ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWYH)
      ELSE
        FWYL=0.
        FWYH=0.
      ENDIF
      IF(Istatus.NE.0)RETURN
      
      IF(ITYPE.GT.1)THEN
C Finding parametrization of fwhm.: FWHM = A + B * SQRT(ch)
        AY=0
        BY=0
        IF(IXL.NE.IXH)THEN
          BX=(FWXL-FWXH)/(SQRT(float(IXL))-SQRT(float(IXH)))
        ELSE
          BX=0
        ENDIF
        AX=FWXL-BX*SQRT(float(IXL))
        IF(ITYPE.GT.1)THEN
          IF(IYL.NE.IYH)THEN
            BY=(FWYL-FWYH)/(SQRT(float(IYL))-SQRT(float(IYH)))
          ELSE
            BY=0
          ENDIF
          AY=FWYL-BY*SQRT(float(IYL))
        ENDIF
        WRITE(6,*)'FWHM have been expressed by A + B * SQRT(ch):'
        WRITE(6,22)AX,BX,AY,BY
 22     FORMAT('Ax=',F8.4,'  Bx=',F8.4,'     Ay=',F8.4,' By=',F8.4)

C Displaying probability matrix at (xl,yl) and (xh,yh)
        IX=IXL
        IY=IYL
        CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
        WRITE(6,31)IX,IY
 31     FORMAT('Probability-matrix around (x,y)=(',I4,',',I4,'):')
        DO J=-4,4
          WRITE(6,30)(WEIGHT(I,J),I=-7,7)
        ENDDO

        IX=IXH
        IY=IYH
        IF(Istatus.NE.0)RETURN
        CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
        WRITE(6,32)IX,IY
 32     FORMAT(/' Probability-matrix around (x,y)=(',I4,',',I4,'):')
        DO J=-4,4
          WRITE(6,30)(WEIGHT(I,J),I=-7,7)
        ENDDO
 30     FORMAT(1X,15F5.3)

        ANS='y'
        WRITE(6,33)ANS
 33     FORMAT(/,'Probability-matrix OK? (y/n) <',A1,'>:',$)
        CALL READA1(5,ANS)
        IF(ANS.EQ.'N'.OR.ANS.EQ.'n') GO TO 34
        IF(Istatus.NE.0)RETURN

C COPYING SOURCE SPECTRUM TO DESTINATION SPECTRUM
        DO J=0,511
          DO I=0,4095
            rMAT(IDEST,I,J)=rMAT(ISP,I,J)
            IF(izero.EQ.1.AND.rMAT(IDEST,I,J).LT.zmin)rMAT(IDEST,I,J)=0
          ENDDO
        ENDDO

C   STARTING TO ELIMINATE NEGATIVE NUMBERS
        DO J=0,YDIM-1
          JT=(J/10)*10
          IF(JT.EQ.J)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF
          DO I=0,XDIM-1
            IT=(I/10)*10
            IF(IT.EQ.I.OR.JT.EQ.J)THEN
              CALL GAUSSR(I,J,AX,BX,AY,BY,DELX,DELY,WEIGHT)
            ENDIF
   40       NEG=rMAT(IDEST,I,J)
            IF(NEG.GE.0)GO TO 41


C FINDING CHANNEL WITH LARGEST WEIGHTED POSITIVE VALUE
            TEST=0.
            DO JJ=-DELY,DELY
              DO II=-DELX,DELX
                III=I+II
                JJJ=J+JJ
      IF(III.LT.0.OR.III.GE.XDIM.OR.JJJ.LT.0.OR.JJJ.GE.YDIM)THEN
                  GO TO 42
                ENDIF
                W=WEIGHT(II,JJ)*rMAT(IDEST,III,JJJ)
                IF(W.GT.TEST)THEN
                  TEST=W
                  POS=rMAT(IDEST,III,JJJ)
                  IP=III
                  JP=JJJ
                ENDIF
  42            CONTINUE
              ENDDO
            ENDDO
            IF(TEST.EQ.0)GO TO 41

C FILLING FROM CH (IP,JP) INTO (I,J)
            IF(ABS(NEG).GT.POS)THEN
              rMAT(IDEST,I,J)=NEG+POS
              rMAT(IDEST,IP,JP)=0
              GO TO 40
            ENDIF
            IF(ABS(NEG).LE.POS)THEN
              rMAT(IDEST,I,J)=0
              rMAT(IDEST,IP,JP)=POS+NEG
            ENDIF

  41      CONTINUE
          ENDDO
        ENDDO
      ELSE
C Finding parametrization of fwhm.: FWHM = A + B * SQRT(ch)
        J=0
        AY=0
        BY=0
        BX=(FWXL-FWXH)/(SQRT(float(IXL))-SQRT(float(IXH)))
        AX=FWXL-BX*SQRT(float(IXL))
        WRITE(6,*)'FWHM have been expressed by A + B * SQRT(ch):'
        WRITE(6,122)AX,BX
 122    FORMAT('Ax=',F8.4,'  Bx=',F8.4)

C Displaying probability matrix at (xl,yl) and (xh,yh)
        IX=IXL
        IY=IYL
        CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
        WRITE(6,131)IX
 131    FORMAT('Probability-function around (x)=(',I4,'):')
        WRITE(6,130)(WEIGHT(I,0),I=-7,7)     
        IX=IXH
        IY=IYH
        IF(Istatus.NE.0)RETURN
        CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
        WRITE(6,131)IX
        WRITE(6,130)(WEIGHT(I,0),I=-7,7)
 130    FORMAT(1X,15F5.3)
        ANS='y'
        WRITE(6,133)ANS
 133    FORMAT(/,'Probability-function OK? (y/n) <',A1,'>:',$)
        CALL READA1(5,ANS)
        IF(ANS.EQ.'N'.OR.ANS.EQ.'n') GO TO 34
        IF(Istatus.NE.0)RETURN

C COPYING SOURCE SPECTRUM TO DESTINATION SPECTRUM
        DO I=0,8191
          rSPEC(IDEST,I)=rSPEC(ISP,I)
          IF(izero.EQ.1.AND.rSPEC(IDEST,I).LT.zmin)rSPEC(IDEST,I)=0
        ENDDO

C   STARTING TO ELIMINATE NEGATIVE NUMBERS
        DO I=0,MAXCH
          IT=(I/10)*10
          IF(IT.EQ.I)THEN
            CALL GAUSSR(I,0,AX,BX,AY,BY,DELX,DELY,WEIGHT)
           ENDIF
  140     NEG=rSPEC(IDEST,I)
          IF(NEG.GE.0)GO TO 141

C FINDING CHANNEL WITH LARGEST WEIGHTED POSITIVE VALUE
          TEST=0. 
          DO II=-DELX,DELX
            III=I+II
            IF(III.LT.0.OR.III.GE.(MAXCH+1))GO TO 142
            W=WEIGHT(II,0)*rSPEC(IDEST,III)
            IF(W.GT.TEST)THEN
              TEST=W
              POS=rSPEC(IDEST,III)
              IP=III
            ENDIF
  142       CONTINUE
          ENDDO
          IF(TEST.EQ.0)GO TO 141

C FILLING FROM CH (IP) INTO (I)
          IF(ABS(NEG).GT.POS)THEN
            rSPEC(IDEST,I)=NEG+POS
            rSPEC(IDEST,IP)=0
            GO TO 140
          ENDIF
          IF(ABS(NEG).LE.POS)THEN
            rSPEC(IDEST,I)=0
            rSPEC(IDEST,IP)=POS+NEG
          ENDIF
  141     CONTINUE
        ENDDO
      ENDIF
      END

             

      SUBROUTINE FITan
C ROUTINE TO FIND BY LEAST SQUARE FIT THE EXPONENT N FROM  FIRST-GEN. SPECTRA.
C THE IDEA IS TO FIND THIS FOR ONE AND THE SAME LANDING REGION.
C THE EXPERIMENTAL GAMMA-SPECTRA ARE FIRST NOMALIZED T, AND
C THEN A LINEAR TRANSFORMATION IS MADE WITH Ex->Ex AND Ey->
C OF EACH Ey IS NORMALIZED TO A FUNCTION F(Ey), BEFORE THE FIT OF A(1)Ex**n
C IS MADE. THE SPECTRUM R(I,J) IS USED AS HELP-SPECTRUM, AND WILL BE ZEROED.

      INTEGER XDIM,YDIM,RDIM,MX,MY,SX,SY
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/CALxy/AX0,AX1,AY0,AY1
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      COMMON/response1/R(0:511,0:511),RDIM,A0,A1,FWHM
      REAL N,MASS,NC,P(2),FEX(0:4095),AI(4096),NI(4096),EEGG(4096)
      EXTERNAL FUNC2,FUNC3,FUNC5
      DIMENSION FIT(4096)
      DIMENSION X(4096),Y(4096),SIGMAY(4096),
     +A(5),DELTAA(5),SIGMAA(5),CH(500)

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Dest. spectr. for manipulated data <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,3)ISP
 3    FORMAT( 'Source spectrum                    <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(Istatus.NE.0)RETURN
      XDIM=Idim(1,ISP,1)
      YDIM=Idim(1,ISP,2)
      MASS=172.
      EGAP=1830.
      NC=4.0
      XJ=4.
      FWXG=500.
      NA=2
      JTYPE=1
      IANS=0

C ZEROING SPECTRA
  999 CONTINUE
      WRITE(6,*)'Zeroing destination spectrum and response matrix'
      DO J=0,511
        DO I=0,4095
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO
      DO J=0,511
        DO I=0,511
          R(I,J)=0.
        ENDDO
      ENDDO


C FIRST NORMALIZE SOURCE SPECTRUM AND PUT IT TEMPOR. IN IDEST
      WRITE(6,*)'Deleting negative counts and normalizing'
      DO J=0,YDIM-1
        SUM=0
        DO I=0,XDIM-1
          IF(rMAT(ISP,I,J).GT.0)SUM=SUM+rMAT(ISP,I,J)
        ENDDO
        DO I=0,XDIM-1
          IF(SUM.NE.0.AND.rMAT(ISP,I,J).GE.0)THEN
            rMAT(IDEST,I,J)=rMAT(ISP,I,J)/SUM
          ELSE
            rMAT(IDEST,I,J)=0
          ENDIF
        ENDDO
      ENDDO
      IF(IANS.EQ.1)GO TO 9991

C READING IN VARIOUS PARAMETERS TO BE USED
      bx=cal(1,ISP,1,1)+cal(1,ISP,1,2)+cal(1,ISP,1,3)
      by=cal(1,ISP,2,1)+cal(1,ISP,2,2)+cal(1,ISP,2,3)
      IF(bx+by.EQ.2.)THEN
        AX0=11.
        AX1=20.
        AY0=9660.
        AY1=-120.
      ELSE
        AX0=cal(1,ISP,1,1)
        AX1=cal(1,ISP,1,2)
        AY0=cal(1,ISP,2,1)
        AY1=cal(1,ISP,2,2)
      ENDIF

      FACX=0.
      FACY=-1.
      WRITE(6,*)' '
      WRITE(6,*)'The following default values correspond to'
      WRITE(6,*)'an experiment on 172Yb from june 1989.'
      WRITE(6,10)AX0
  10  FORMAT(/'Cal. coeff. a0 (keV) on x-axis   <',F8.1,'>:',$)
      CALL READF(5,AX0)
      WRITE(6,11)AX1
  11  FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis<',F8.1,'>:',$)
      CALL READF(5,AX1)

      WRITE(6,12)AY0
  12  FORMAT(/'Cal. coeff. a0 (keV) on y-axis   <',F8.1,'>:',$)
      CALL READF(5,AY0)
      WRITE(6,13)AY1
  13  FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis<',F8.1,'>:',$)
      CALL READF(5,AY1)

      WRITE(6,*)'Give limits for the transformation of the matrix'
      EXUPPER=8000.0
      WRITE(6,14)EXUPPER
  14  FORMAT(/'Give upper energy on x-axis (keV)<',F8.1,'>:',$)
      CALL READF(5,EXUPPER)
      EYUPPER=EXUPPER
      WRITE(6,15)EYUPPER
  15  FORMAT( 'Give upper energy on y-axis (keV)<',F8.1,'>:',$)
      CALL READF(5,EYUPPER)
      IF(Istatus.NE.0)RETURN
     
      IUPPER=((EXUPPER-AX0)/AX1+0.5)
      JUPPER=((EYUPPER-AY0)/AY1+0.5)
      ILOWER=(-AX0/AX1+0.5)
      JLOWER=(-AY0/AY1+0.5)
      IF(ILOWER.GT.IUPPER)THEN
        I=ILOWER
        ILOWER=IUPPER
        IUPPER=I
      ENDIF
      IF(JLOWER.GT.JUPPER)THEN
        J=JLOWER
        JLOWER=JUPPER
        JUPPER=J
      ENDIF

      IF(IUPPER.GT.511)IUPPER=511
      IF(JUPPER.GT.511)JUPPER=511
      IF(ILOWER.LT.0  )ILOWER=0
      IF(JLOWER.LT.0  )JLOWER=0
      WRITE(6,16)ILOWER,IUPPER,JLOWER,JUPPER
  16  FORMAT(/' Data taken from Chx= ',I4,'-',I4,' and Chy= ',I4,'-',I4,/)
      WRITE(6,*)'Transforming Ex -> Ex and Ey -> Ey - Ex'
9991  CONTINUE
      DO J=JLOWER,JUPPER
        DO I=ILOWER,IUPPER
          EEX=AX0+AX1*I
          EEY=AY0+AY1*J
          EX=EEX+FACX*EEY
          EY=EEY+FACY*EEX

C WE NOW DISTRIBUTE THE COUNTS INTO APPROPRIATE CHANNELS, GENERALLY 4.
C FINDING FIRST THE MAIN CHANNEL (MX,MY) AND PUT SOME FRACTION INTO THE 3
C OTHER SIDE-CHANNELS (SX,MY), (MX,SY) AND (SX,SY)
          CX=(EX-AX0)/AX1
          CY=(EY-AY0)/AY1
          MX=CX+0.5
          MY=CY+0.5
          FX=CX-MX
          FY=CY-MY
          SX=MX+1
          SY=MY+1
          IF(FX.LT.0)SX=MX-1
          IF(FY.LT.0)SY=MY-1
          FX=ABS(FX)
          FY=ABS(FY)

C CALCU THAT A SQUARE AROUND (Ex,Ey) COVERS THE 4 CH.
          AX =FX     *(1.-FY)
          AY =(1.-FX)*FY
          AXY=FX     *FY

C CALCULATING THE NUMBER OF COUNTS TO BE PUT IN
          ITOT=rMAT(IDEST,I,J)
          IX =(AX *ITOT)
          IY =(AY *ITOT)
          IXY=(AXY*ITOT)
          IM=ITOT-IX-IY-IXY

          IF(MX.GE.0.AND.MX.LE.511.AND.MY.GE.0.AND.MY.LE.511)THEN
            R(MX,MY)=R(MX,MY)+IM
            IF(SX.GE.0.AND.SX.LE.511)
     +      R(SX,MY)=R(SX,MY)+IX
            IF(SY.GE.0.AND.SY.LE.511 )
     +      R(MX,SY)=R(MX,SY)+IY
          ENDIF
         IF(SX.GE.0.AND.SX.LE.511.AND.SY.GE.0.AND.SY.LE.511)THEN
            R(SX,SY)=R(SX,SY)+IXY
          ENDIF
        ENDDO
      ENDDO

C PUTTING IT TEMPORARELY INTO MATRIX rMAT(IDEST,I,J) AND ZEROING R(I,J)
      DO J=0,511
        DO I=0,511
          rMAT(IDEST,I,J)=R(I,J)
          R(I,J)=0
        ENDDO
      ENDDO

C CALCULATING THE NORMALIZ. FUNCTION F(Ex). WE HAVE P(Ex,Eg)= F(Ex)*
C Eg**n * Rho(Ex-Eg). FOR EXC. ENERGIES BELOW Egap, WE ESTIMATE THE
C MISSING FRACTION FROM THE EXPERIMENTAL SPECTRUM
      IF(IANS.EQ.1)GO TO 131
      WRITE(6,*)'Give values to be used for the Fermi-gas estimate'
      WRITE(6,17)MASS
  17  FORMAT(/'Mass number',13X,'                    <',F4.0,'>:',$)
      CALL READF(5,MASS)
      GAP=1000.*2.*12.*MASS**(-0.5)
      WRITE(6,18)GAP,EGAP
  18  FORMAT(/'Pairing gap (2*12/sqrt(A)=',F5.0,')',12X,'<',F5.0,'>:',$)
      CALL READF(5,EGAP)
      EXMIN=EGAP+200.
      WRITE(6,*)'The highest gamma-energy to be used is'
      WRITE(6,*)'limited by the final exc. energy (Ex-Eg).'
      WRITE(6,*)'This value must be equal or higher than Egap.'
      WRITE(6,19)EXMIN
  19  FORMAT(/'Lower final exc. energy (keV) >=Egap <',F6.0,'>:',$)
      CALL READF(5,EXMIN)
      EXMINF=EXMIN+200.

      WRITE(6,20)XJ
  20  FORMAT(/'Give average spin populated',18X,'<',F4.1,'>:',$)
      CALL READF(5,XJ)

      WRITE(6,21)FWXG
  21  FORMAT(/'Energy FWHM    for Ex-Eg (keV)',12X,'<',F6.1,'>:',$)
      CALL READF(5,FWXG)

  131 CONTINUE
      WRITE(6,22)NC
  22  FORMAT(/'Exponent n                 <',F4.2,'>:',$)
      CALL READF(5,NC)
      IF(NC.GT.0)THEN
        DO I=0,4095
           N(I)=NC
           EXPN(I)=(AX0+FLOAT(I)*AX1)**NC
        ENDDO
      ELSE
        WRITE(6,*)'Exponent must be positive'
        GO TO 131
      ENDIF
      AA=MASS/8000.
      WRITE(6,23)AA
  23  FORMAT( 'Level density parameter a <',F6.3,'>:',$)
      CALL READF(5,AA)
      IF(Istatus.NE.0)RETURN
      P(2)=AA
      P(1)=1.

C CALCULATING F(Ex)
      FRGAS=0.01
      SUM=0
      DO J=JLOWER,JUPPER
        EX =J*AY1+AY0
        EXL=EX-FWXG/2.
        EXH=EX+FWXG/2.
        IF(EXL.LT.0)EXL=0.
        IMAX=((EX-EXMIN-AX0)/AX1+0.5)
        FEX(J)=0.
        GAS=0.
        GSB=0.
        DO I=0,IMAX
          XX=AX1*I+AX0
          IF(XX.GT.500.)FEX(J)=FEX(J)+FUNC1(XX,P)
          IF(XX.GT.500.)GAS=GAS+rMAT(ISP,I,J)
        ENDDO
        DO I=IMAX+1,IUPPER
          IF(XX.GT.500.)GSB=GSB+rMAT(ISP,I,J)
        ENDDO
C CORRECT FOR DECAY TO STATES BELOW FERMI-GAS. (TAKEN FROM EXP. SPECTRA)
        FRAC=0.
        IF(GAS.GT.0.)FRAC=GSB/GAS
        FRAC=1.+FRAC
        FEX(J)=FEX(J)*FRAC

C FINDING FRACTION IN FERMI GAS. WEIGHTED WITH CHANNELS IN FERMI GAS
        IF(GAS+GSB.GT.0)THEN
          SUM=SUM+IMAX
           FRGAS=FRGAS+FLOAT(IMAX)*GAS/(GAS+GSB)
        ENDIF
      ENDDO
      IF(SUM.GT.0)FRGAS=FRGAS/SUM
      WRITE(6,25)FRGAS
  25  FORMAT(/'Average  weight in Fermi gas region <',F6.4,'>:',$)
      CALL READF(5,FRGAS)

      DO J=JLOWER,JUPPER
        EX=J*AY1+AY0
        FEX(J)=FEX(J)/FRGAS
        IF(FEX(J).GT.0)WRITE(6,24)J,EX,FEX(J)
  24    FORMAT('y ch.=',I5,' Exc.=',F5.0,
     +    ' F(Ex)=',E12.5)
      ENDDO

C CORRECT FOR F(Ex) AND GET SOMETHING PROPORTIONAL TO Eg**N
      DO J=JLOWER,JUPPER
        DO I=ILOWER,IUPPER
          EG= FLOAT(I)*AX1+AX0
          EXF=FLOAT(J)*AY1+AY0
          EXI=EXF+EG
          FAC=0.
          XX=(EXI-AY0)/AY1
          IF(XX.GT.0.AND.XX.LT.511.)THEN
            I1=XX
            I2=I1+1
            FAC=FEX(I1)+(FEX(I2)-FEX(I1))*(I1-XX)
          ENDIF
          IF(FAC.LE.0)FAC=0.
          R(I,J)=rMAT(IDEST,I,J)*FAC
        ENDDO
      ENDDO
  99  CONTINUE


C BLOCKS FOR EITHER FIT n ON X-AXIS (JTYPE=1) OR a ON Y-AXIS (JTYPE=2)
      IF(JTYPE.EQ.1)THEN

C ZEROING DESTINATION MATRIX
      DO J=0,511
        DO I=0,4095
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO

C PREPARING FOR FIT. FINDING LIMITS FOR FIT
        IMIN=((800.-AX0)/AX1+0.5)
        EGMIN=AX1*IMIN+AX0
        WRITE(6,101)EGMIN,IMIN
 101    FORMAT(/'Lower ch. for fit on x-axis (Eg=',F5.0,
     +  ' keV)   <',I4,'>:',$)
        CALL READI(5,IMIN)
        EGMIN=AX1*IMIN+AX0
 
 103    CONTINUE
        WRITE(6,102)EXMINF
 102    FORMAT( 'Lower final excitation energy (keV) >=Egap <',F6.0,
     +  '>:',$)
        CALL READF(5,EXMINF)
        IF(EXMINF.LT.EXMIN)THEN
          WRITE(6,104)EXMIN
 104      FORMAT('Too low, must be higher or equal ',F7.1, 'keV')
          GO TO 103
        ENDIF

        JMIN=((EXMINF-AY0)/AY1+0.5)
        JMAX=((EYUPPER-EGMIN-AY0)/AY1+0.5)
        IF(JMIN.GT.JMAX)THEN
          JWAIT=JMIN
          JMIN=JMAX
          JMAX=JWAIT
        ENDIF
        JMIN=JMIN+4
        IF(JMIN.LT.0)JMIN=0
        IF(JMAX.GE.YDIM-1)JMAX=YDIM-1

        EYMIN=AY1*JMIN+AY0
        EYMAX=AY1*JMAX+AY0
        WRITE(6,*)'Spectra to be fitted, give low and high y-channel'
        WRITE(6,105)EYMIN,JMIN
 105    FORMAT(/'Lower ch. (excit. ',F8.2,' keV)  <',I4,'>:',$)
        CALL READI(5,JMIN)
        WRITE(6,106)EYMAX,JMAX
 106    FORMAT( 'Higher ch. (excit. ',F8.2,' keV) <',I4,'>:',$)
        CALL READI(5,JMAX)
        IF(JMIN.GT.JMAX)THEN
          WRITE(6,*)'Lower ch. > Higher ch.'
          Istatus=1
          RETURN
        ENDIF
        IF(Istatus.NE.0)RETURN

C ALL LIMITS NOW DETERMINED FOR FIT. STARTING THE FIT PROCEDURE
 132    A1=3.
        A2=NC
        WRITE(6,107)A2
 107    FORMAT(/'Starting value for exponent n  <',F5.2,'>:',$)
        CALL READF(5,A2)

        WRITE(6,108)NA
 108    FORMAT( 'Number of parameters in fit (max=2)<',I1,'>:',$)
        CALL READI(5,NA)
        IF(Istatus.NE.0)RETURN

        cal(1,ISP,1,1)=  AX0
        cal(1,ISP,1,2)=  AX1
        cal(1,ISP,2,1)=  AY0
        cal(1,ISP,2,2)=  AY1
        cal(1,IDEST,1,1)=AX0
        cal(1,IDEST,1,2)=AX1
        cal(1,IDEST,2,1)=AY0
        cal(1,IDEST,2,2)=AY1

C*********************************************************************
C   FITIING LOOP STARTS
C*********************************************************************
 109    PROG=0.0001
        MODE=1
        DO J=JMIN,JMAX
          M=0
          A(1)=A1
          A(2)=A2
          EGMAX=EYUPPER-(J*AY1+AY0)
          IMAX=((EGMAX-AX0)/AX1+0.5)

C SETTING UP THE HISTOGRAM TO BE FITIED, BOTH X(I) AND Y(I)
          EXF=J*AY1+AY0
          IF(IMAX.LE.IMIN+NA+1)THEN
            WRITE(6,*)'Too few data for fit'
            GO TO 100
          ENDIF
          NPTS=0
          THRSX=10.E+10
          THRSY=10.E+10
          DO I=IMIN,IMAX
            IF(R(I,J).GT.0)THEN
              NPTS=NPTS+1
              EGG=AX1*I+AX0
              EEGG(NPTS)=EGG
              X(NPTS)=ALOG(EGG)
              Y(NPTS)=ALOG(R(I,J))
              EXL=EXF-FWXG/2.
              EXH=EXF+FWXG/2.

              IF(FUNC5(P).NE.0)THEN
                NI(NPTS)=ALOG(R(I,J)/FUNC5(P))/ALOG(EGG)
              ELSE
                NI(NPTS)=0
              ENDIF

              U=(FLOAT(J)*AY1+AY0)-EGAP-300.
              IF(U.GT.100.) THEN
                DIVID=EXPN(I)*(2.*XJ+1.)*SQRT(P(2))
               AI(NPTS)=((ALOG(R(I,J)*U*U/DIVID))**2)/(4.*U)
              ELSE
                AI(NPTS)=0
              ENDIF

              SIGMAY(NPTS)=0.1
              IF(THRSX.GT.X(NPTS))THRSX=X(NPTS)
              IF(THRSY.GT.Y(NPTS))THRSY=Y(NPTS)
            ENDIF
          ENDDO

C SHIFTING THE DATA-POINTS DOWN TO ORIGO
          DO I=1,NPTS
            X(I)=X(I)-THRSX
            Y(I)=Y(I)-THRSY
           ENDDO

C ESTIMATE PARAMETERS TO BE FITIED
          DO I=1,2
            SIGMAA(I)=A(I)/10.
            DELTAA(I)=A(I)/10.
          ENDDO
          CHISQR=999999.
          BEST  =999999.
          NBAD  =0

C     STARTING FIT **********************************************
          WRITE(6,120)
 120      FORMAT('  LOOP     CHISQR       A(1)         A(2)')
          IF(M.LT.4)WRITE(6,*)' '
          WRITE(6,121)M,CHISQR,(A(JJ),JJ=1,NA)
 123      CALL GRIDLS(X,Y,SIGMAY,NPTS,MODE,FUNC2,A
     +    ,DELTAA,SIGMAA,NA,FIT,CHISQR)
          M=M+1
          WRITE(6,121)M,CHISQR,(A(JJ),JJ=1,NA)
 121      FORMAT(I4,3(1X,E12.5))
          CH(M)=CHISQR
          IF(M.LT.2) GO TO 123
          VER=ABS(CH(M)-CH(M-1))/CH(M-1)
          IF(CHISQR.LT.BEST)THEN
            BEST=CHISQR
            AA1=A(1)
            AA2=A(2)
            SIGAA1=SIGMAA(1)
            SIGAA2=SIGMAA(2)
          ENDIF
          IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
          IF(NBAD.GT.4)GO TO 124
          IF(M.GE.500)GO TO 124
          IF(VER.GT.PROG) GO TO 123
 124      CONTINUE

C     FIT IS FINISHED *********************************************
          A(1)=AA1
          SIGMAA(1)=SIGAA1
          A(2)=AA2
          SIGMAA(2)=SIGAA2

          WRITE(6,111)
 111      FORMAT('       Eg     ln(Eg)    ln(Q/N)      Fit   ',
     +    ' n=ln... a=(ln..)**2')
          AVN=0
          AVA=0
          SUMN=0
          SUMA=0
          DO I=1,NPTS                           
            X1=X(I)+THRSX
            Y1=Y(I)+THRSY
            F1=FIT(I)+THRSY
            WRITE(6,110)EEGG(I),X1,Y1,F1,NI(I),AI(I)
             IF(NI(I).GT.0)THEN
              SUMN=SUMN+1
              AVN=AVN+NI(I)
            ENDIF
            IF(AI(I).GT.0)THEN
              SUMA=SUMA+1
              AVA=AVA+AI(I)
            ENDIF
          ENDDO
          AVN=AVN/SUMN
          AVA=AVA/SUMA
 110      FORMAT(F10.1,3F10.3,2F10.5)
          WRITE(6,112)AVN,AVA
 112      FORMAT(' (Average n and a from ln-calc.:',8X,2F10.5,')')

          WRITE(6,129)J,EXF,IMIN,IMAX,BEST
 129       FORMAT(/' Results for y-ch:',I3,' (Exf=',F6.0,
     +    ' keV) and x-chs:',I3,' -',I3,',  Chisqr.=',F8.3)
          WRITE(6,128)
 128      FORMAT(3('--------------------------'))
          AXX=A(1)+THRSX
          WRITE(6,127)  AXX,SIGMAA(1)
          WRITE(6,126)  A(2),SIGMAA(2)
 127      FORMAT(' Normalisation parameter A(1)=',E10.4,' +/-',E10.4)
 126      FORMAT(' Exponent n              A(2)= ',F9.5,' +/-',F9.5)
          WRITE(6,128)

C PUTTING THE DATA INTO MATRIX IDEST. MULTIPLYING X AND Z
C WITH 25 AND 250, RESPECTIVELY
          DO I=0,XDIM-1
            DIF=50.
            DO II=1,NPTS
              DIFX=ABS(FLOAT(I)-25.*X(II))
              IF(DIFX.LT.DIF)THEN
                DIF=DIFX
                I1=II
              ENDIF
            ENDDO
            IF(25.*X(I1).GT.I)I1=I1-1
            I2=I1+1
            IF(I1.GE.1.AND.I2.LE.NPTS)THEN
              X1=25.*X(I1)
              X2=25.*X(I2)
              rMAT(IDEST,I,J)=250.*
     +        (Y(I1)+(Y(I2)-Y(I1))*(I-X1)/(X2-X1))
             ENDIF
          ENDDO

 100      IANS=0
          WRITE(6,*)'Next y-ch. with same parameters:  0'
          WRITE(6,*)'New F(Ex)-function                1'
          WRITE(6,*)'New initial fit parameters:       2'
          WRITE(6,*)'Fit parameter a on Y-axis:        3'
          WRITE(6,*)'Return to main menu:              4'
          WRITE(6,130)IANS
  130      FORMAT(/'Please, type your choice (0,,,,4) <',I1,'>:',$)
          CALL READI(5,IANS)
          IF(IANS.EQ.1)GO TO 999
          IF(IANS.EQ.2)GO TO 132
          IF(IANS.EQ.3)THEN
            JTYPE=2
            GO TO 99
          ENDIF
          IF(IANS.EQ.4)GO TO 64
        ENDDO

      ELSE

C       PREPARING FOR FIT. FINDING LIMITS FOR FIT
C ZEROING DESTINATION MATRIX
        DO J=0,511
          DO I=0,4095
            rMAT(IDEST,I,J)=0
          ENDDO
        ENDDO

        IMIN=((800.-AX0)/AX1+0.5)
        EGMIN=AX1*IMIN+AX0
        WRITE(6,201)EGMIN,IMIN
 201    FORMAT(/'Lower ch. on x-axis (Eg=',F5.0,
     +  ' keV)           <',I4,'>:',$)
        CALL READI(5,IMIN)
        EGMIN=AX1*IMIN+AX0

        JJ=JMIN
        IF(AY1.LT.0)JJ=JMAX
        EGMAX=EYUPPER-(JJ*AY1+AY0)
        IMAX=((EGMAX-AX0)/AX1+0.5)
        EGMAX=AX1*IMAX+AX0
        WRITE(6,202)EGMAX,IMAX
 202    FORMAT( 'Higher ch. on x-axis (Eg=',F5.0,
     +  ' keV)          <',I4,'>:',$)
        CALL READI(5,IMAX)
        EGMAX=AX1*IMAX+AX0

 203    CONTINUE
        JJ1=((EXMINF-AY0)/AY1+0.5)
        WRITE(6,204)EXMINF,JJ1
 204    FORMAT(/'Y-ch. for lower exc. energy ',F8.2,
     +  ' keV)    <',I4,'>:',$)
        CALL READI(5,JJ1)
        YTEST=AY1*JJ1+AY0
        IF(YTEST.LT.EXMIN)THEN
          WRITE(6,205)EXMIN
 205      FORMAT('Too low energy, must be higher than ',F7.1, 'keV')
          GO TO 203
        ENDIF
 

 232    CONTINUE
        A2=AA
        WRITE(6,207)A2
 207    FORMAT(/'Starting value for level density param. a  <',
     +  F5.3,'>:',$)
        CALL READF(5,A2)

        WRITE(6,208)NA
 208    FORMAT(/'Number of parameters in fit (max=2)',12X,'<',I1,'>:',$)
        CALL READI(5,NA)
        IF(Istatus.NE.0)RETURN

C********************************************************************
C   FITIING LOOP STARTS
C********************************************************************
        PROG=0.0001
        MODE=1
        DO I=IMIN,IMAX
          M=0
        
C SETTING UP THE HISTOGRAM TO BE FITIED, BOTH X(I) AND Y(I)
          EG=I*AX1+AX0
          JJ2=((EYUPPER-EG-AY0)/AY1+0.5)
          J1=MIN(JJ1,JJ2)
          J2=MAX(JJ1,JJ2)
          IF(J1.LT.0)J1=0
          IF(J2.GE.YDIM-1)J2=YDIM-1

          IF(J2.LE.J1+NA+1)THEN
            WRITE(6,*)'Too few data for fit'
            GO TO 200
          ENDIF
          NPTS=0

          DO J=J1,J2

            IF(R(I,J).GT.0)THEN
              NPTS=NPTS+1
              EGG=AX1*I+AX0
              EXF=FLOAT(J)*AY1+AY0
              X(NPTS)=EXF
              Y(NPTS)=ALOG(R(I,J))
              EXL=EXF-FWXG/2.
              EXH=EXF+FWXG/2.

              IF(FUNC5(P).NE.0)THEN
                NI(NPTS)=ALOG(R(I,J)/FUNC5(P))/ALOG(EGG)
              ELSE
                NI(NPTS)=0
              ENDIF

              U=(FLOAT(J)*AY1+AY0)-EGAP-300.
               IF(U.GT.100.) THEN
                DIVID=EXPN(I)*(2.*XJ+1.)*SQRT(P(2))
               AI(NPTS)=((ALOG(R(I,J)*U*U/DIVID))**2)/(4.*U)
              ELSE
                AI(NPTS)=0
              ENDIF

              SIGMAY(NPTS)=.1
              IF(THRSX.GT.X(NPTS))THRSX=X(NPTS)
              IF(THRSY.GT.Y(NPTS))THRSY=Y(NPTS)
            ENDIF

          ENDDO

          A(1)=1.
          A(2)=AA
          EXPSUM=0.
          TEOSUM=0.
          DO JJ=1,NPTS
            EXPSUM=EXPSUM+Y(JJ)
            XX=X(JJ)
            TEOSUM=TEOSUM+FUNC3(XX,A)
          ENDDO
          XPT=NPTS
          XPTLNA1=TEOSUM-EXPSUM
          A(1)=1./EXP(XPTLNA1/XPT)

C ESTIMATE PARAMETERS TO BE FITIED
          DO J=1,2
            SIGMAA(J)=A(J)/10.
            DELTAA(J)=A(J)/10.
          ENDDO
          CHISQR=999999.
          BEST  =999999.
          NBAD  =0

C     STARTING FIT **********************************************
          WRITE(6,220)
 220      FORMAT('  LOOP     CHISQR       A(1)         A(2)')
          IF(M.LT.4)WRITE(6,*)' '
          WRITE(6,221)M,CHISQR,(A(JJ),JJ=1,NA)
 223      CALL GRIDLS(X,Y,SIGMAY,NPTS,MODE,FUNC3,A
     +    ,DELTAA,SIGMAA,NA,FIT,CHISQR)
          M=M+1
          WRITE(6,221)M,CHISQR,(A(JJ),JJ=1,NA)
 221      FORMAT(I4,3(1X,E12.5))
          CH(M)=CHISQR
          IF(M.LT.2) GO TO 223
          VER=ABS(CH(M)-CH(M-1))/CH(M-1)
          IF(CHISQR.LT.BEST)THEN
            BEST=CHISQR
            AA1=A(1)
            AA2=A(2)
            SIGAA1=SIGMAA(1)
            SIGAA2=SIGMAA(2)
          ENDIF
          IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
           IF(NBAD.GT.4)GO TO 224
          IF(M.GE.500) GO TO 224
          IF(VER.GT.PROG) GO TO 223
 224      CONTINUE

C     FIT IS FINISHED *********************************************
          A(1)=AA1
          SIGMAA(1)=SIGAA1
          A(2)=AA2
          SIGMAA(2)=SIGAA2

          WRITE(6,211)
 211      FORMAT('     Exf     ln(Q/N)      Fit   ',
     +    ' n=ln... a=(ln..)**2')
          AVN=0
          AVA=0
          SUMN=0
          SUMA=0
          DO J=1,NPTS
            WRITE(6,110)X(J),Y(J),FIT(J),NI(J),AI(J)
            IF(NI(J).GT.0)THEN
              SUMN=SUMN+1
              AVN=AVN+NI(J)
            ENDIF
            IF(AI(J).GT.0)THEN
              SUMA=SUMA+1
              AVA=AVA+AI(J)
            ENDIF
          ENDDO
          AVN=AVN/SUMN
          AVA=AVA/SUMA
 210      FORMAT(F10.1,2F10.3,2F10.5)
          WRITE(6,212)AVN,AVA
 212      FORMAT(' (Aver. n and a from ln-calc.:',2F10.5,')')

          WRITE(6,229)I,EG,J1,J2,BEST
 229       FORMAT(/' Results for x-ch:',I3,' (Eg =',F6.0,
     +    ' keV) and y-chs:',I3,' -',I3,',  Chisqr.=',F8.3)
          WRITE(6,228)
 228      FORMAT(3('--------------------------'))
          WRITE(6,227)  A(1),SIGMAA(1)
          WRITE(6,226)  A(2),SIGMAA(2)
 227      FORMAT(' Normalisation parameter A(1)=',E10.4,' +/-',E10.4)
 226      FORMAT(' Level density param. a  A(2)= ',F9.5,' +/-',F9.5)
          WRITE(6,228)

C PUTTING THE DATA INTO MATRIX IDEST

          DO II=1,NPTS
            JJ=((X(II)-AY0)/AY1)+0.5
            rMAT(IDEST,I,JJ)=Y(II)
          ENDDO

 200      IANS=0
          WRITE(6,*)'Next x-ch. with same parameters:  0'
          WRITE(6,*)'New F(Ex)-function:               1'
          WRITE(6,*)'New start fit parameters:         2'
          WRITE(6,*)'Fit parameter n on x-axis:        3'
          WRITE(6,*)'Return to main menu:              4'
          WRITE(6,230)IANS
 230      FORMAT(/'Please, type your choice (0,,,,4) <',I1,'>:',$)
          CALL READI(5,IANS)
          IF(IANS.EQ.1)GO TO 999
          IF(IANS.EQ.2)GO TO 232
          IF(IANS.EQ.3)THEN
            JTYPE=1
            GO TO 99
          ENDIF
          IF(IANS.EQ.4)GO TO 64
        ENDDO

      ENDIF

C RESETTING HELPING SPECTRUM R(I,J) TO ZERO
  64  CONTINUE
      DO J=0,511
        DO I=0,511
          R(I,J)=0.
        ENDDO
      ENDDO
      RDIM=0
C Updating comment in the heading of spectrum file
      xcomm(1:3)='AN:'
      fname(1,IDEST)(1:8)='AN'//fname(1,ISP)(1:6)
      comm(1,IDEST)=comm(1,ISP)
      CALL AddComment(xcomm,3)

      RETURN
      END



      SUBROUTINE GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER APP*4
      INTEGER XDIM,YDIM,DELX,DELY
      DIMENSION WEIGHT(-100:100,-100:100)

      DO I=-100,100
        DO J=-100,100
          WEIGHT(I,J)=0.
        ENDDO
      ENDDO

      FWX=AX+BX*SQRT(float(IX))+0.5
      FWY=AY+BY*SQRT(float(IY))+0.5
      IF(FWX.LT.0)FWX=0.
      IF(FWY.LT.0)FWY=0.
      SX=FWX/2.35             !SIGMAx
      SY=FWY/2.35             !SIGMAy
      XN=1.4142*SX            !sqrt(2)=1.4142
      YN=1.4142*SY
      DELX=3.03*SX+0.5        !3.03 gives exp(-(DELX/(1.4142*SX))**2)=0.010
      DELY=3.03*SY+0.5        !which means walking out to 0.010 of max = 1
      IF(DELX.GT.100)DELX=100 !3.25 gives 0.005 and 3.72 gives 0.001
      IF(DELY.GT.100)DELY=100

      SUM=0

      DO I=-DELX,DELX
        X1=0.
        IF(XN.NE.0.)X1=(FLOAT(I)/XN)**2
        DO J=-DELY,DELY
          Y1=0.
          IF(YN.NE.0.)Y1=(FLOAT(J)/YN)**2
          XY1=X1+Y1
          IF(XY1.LT.4.605.AND.XY1.GT.0.0001)THEN
            H=EXP(-XY1)                             ! 4.605 gives H=0.010
          ELSE                                      ! 5.298 gives H=0.005
            H=0.                                    ! 6.907 gives H=0.001
          ENDIF
          IF(XY1.LE.0.0001)H=1
          WEIGHT(I,J)=H
          SUM=SUM+H
        ENDDO
      ENDDO
      IF(SUM.EQ.0)THEN
        SUM=1.
        WEIGHT(0,0)=1.
      ENDIF
      DO I=-DELX,DELX
        DO J=-DELY,DELY
          IF(SUM.GT.0.00000001)WEIGHT(I,J)=WEIGHT(I,J)/SUM
        ENDDO
      ENDDO
      END


      SUBROUTINE INTERCH
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60

      IF(ITYPE.EQ.1)ITYPE=3
      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=IDEST
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(Istatus.NE.0)RETURN

      MAXDIM=512
      DO I=0,MAXDIM-1
        DO J=I,MAXDIM-1
          IWAIT1=rMAT(ISP,I,J)
          IWAIT2=rMAT(ISP,J,I)
          rMAT(IDEST,I,J)=IWAIT2
          rMAT(IDEST,J,I)=IWAIT1
        ENDDO
      ENDDO

      ay0=cal(1,ISP,2,1)
      ay1=cal(1,ISP,2,2)
      ay2=cal(1,ISP,2,3)

      ax0=cal(1,ISP,1,1)
      ax1=cal(1,ISP,1,2)
      ax2=cal(1,ISP,1,3)

      cal(1,IDEST,1,1)=ay0
      cal(1,IDEST,1,2)=ay1
      cal(1,IDEST,1,3)=ay2

      cal(1,IDEST,2,1)=ax0
      cal(1,IDEST,2,2)=ax1
      cal(1,IDEST,2,3)=ax2

      YDIM=Idim(1,ISP,1)
      XDIM=Idim(1,ISP,2)
      IF(XDIM.GT.512)XDIM=512
      IF(YDIM.GT.512)YDIM=512

      WRITE(6,*)'x- and y-axis have been interchanged.'

C Updating comment in the heading of spectrum file
      xcomm(1:3)='XY:'
      fname(1,IDEST)='XY'//fname(1,ISP)(1:6)
      comm(1,IDEST)=comm(1,ISP)
      CALL AddComment(xcomm,3)
      CALL SetMarker(1,1,1)

      END

 
      SUBROUTINE LANDSCAPE
      EXTERNAL FUNC4,EXPONENT
      CHARACTER APP*4
      DIMENSION FIT(50000)
      DIMENSION X(50000),Y(50000),SIGMAY(50000),A(5),DELTAA(5),SIGMAA(5),CH(500)
      INTEGER XDIM,YDIM
      REAL N,MASS,NC
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/CALxy/AX0,AX1,AY0,AY1
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      COMMON/CTOTFIT/XEN(50000),YEN(50000),NPTS,EXV,FX,EXMIN,ISP1

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Dest. spectr. for theoretical data <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,3)ISP
 3    FORMAT( 'Source spectrum                    <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1
      IF(Istatus.NE.0)RETURN

C     SETTING DEFAULT VALUES AND
C     READING IN VARIOUS PARAMETERS TO BE USED
      ISP=1
      IF(IDEST.EQ.1)ISP=2

      ISP1=ISP
      MASS=172.
      EGAP=1830.
      NC=4.
      XJ=4.
      FWXG=500.
      FX=0.
      EXV=0.
      NA=2
      XDIM=Idim(1,ISP,1)
      YDIM=Idim(1,ISP,2)
      SUM=0.
      DO J=0,YDIM-1
        DO I=0,XDIM-1
          SUM=SUM+rMAT(ISP,I,J)
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO
      IF(SUM.EQ.0)THEN
        WRITE(6,*)'Forgotten to read in source spectrum'
        Istatus=1
        RETURN
      ENDIF

C NORMALIZE SOURCE SPECTRUM
      WRITE(6,*)'Deleting negative counts and normalizing...'
      ySUM=0
      DO J=0,YDIM-1
        xSUM=0
        DO I=0,XDIM-1
          IF(rMAT(ISP,I,J).GT.0)xSUM=xSUM+rMAT(ISP,I,J)
        ENDDO
        DO I=0,XDIM-1
          IF(xSUM.NE.0.AND.rMAT(ISP,I,J).GE.0)THEN
            rMAT(ISP,I,J)=rMAT(ISP,I,J)/xSUM
            ySUM=ySUM+rMAT(ISP,I,J)
          ELSE
            rMAT(ISP,I,J)=0
           ENDIF
        ENDDO
      ENDDO

      bx=cal(1,ISP,1,1)+cal(1,ISP,1,2)+cal(1,ISP,1,3)
      by=cal(1,ISP,2,1)+cal(1,ISP,2,2)+cal(1,ISP,2,3)
      IF(bx+by.EQ.2.)THEN
        AX0=11.
        AX1=20.
        AY0=9660.
        AY1=-120.
      ELSE
        AX0=cal(1,ISP,1,1)
        AX1=cal(1,ISP,1,2)
        AY0=cal(1,ISP,2,1)
        AY1=cal(1,ISP,2,2)
      ENDIF

  99  CONTINUE
      WRITE(6,10)AX0
  10  FORMAT(//'Cal. coeff. a0 (keV) on x-axis    <',F8.1,'>:',$)
      CALL READF(5,AX0)
      WRITE(6,11)AX1
  11  FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis <',F8.1,'>:',$)
      CALL READF(5,AX1)

      WRITE(6,12)AY0
  12  FORMAT( /'Cal. coeff. a0 (keV) on y-axis    <',F8.1,'>:',$)
      CALL READF(5,AY0)
      WRITE(6,13)AY1
  13  FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis <',F8.1,'>:',$)
      CALL READF(5,AY1)
      IF(Istatus.NE.0)RETURN

      WRITE(6,14)MASS
  14  FORMAT(/'Mass number',14X,'                    <',F4.0,'>:',$)
      CALL READF(5,MASS)
      AD=MASS/8000.
      AA=AD

      GAP=1000.*2.*12.*MASS**(-0.5)
      WRITE(6,15)GAP,EGAP
  15  FORMAT(/'Pairing gap (2*12/sqrt(A)=',F5.0,')',12X,'<',F5.0,'>:',$)
      CALL READF(5,EGAP)

      JMIN=((EGAP -AY0)/AY1+0.5)
      JMAX=((8000.-AY0)/AY1+0.5)
      IF(JMIN.GT.JMAX)THEN
        JWAIT=JMIN
        JMIN=JMAX
        JMAX=JWAIT
      ENDIF
      IF(JMIN.LT.0)JMIN=0
      IF(JMAX.GE.YDIM-1)JMAX=YDIM-1
      EYMIN=AY1*JMIN+AY0
      EYMAX=AY1*JMAX+AY0
      WRITE(6,*)'Spectra to be fitted, give low and high y-channel'
      WRITE(6,16)EYMIN,JMIN
  16  FORMAT(/'Lower ch. (excitation ',F8.2,' keV)',9X,' <',I4,'>:',$)
      CALL READI(5,JMIN)
      WRITE(6,17)EYMAX,JMAX
  17  FORMAT( 'Higher ch. (excitation ',F8.2,' keV)',8X,' <',I4,'>:',$)
      CALL READI(5,JMAX)
      IF(JMIN.GT.JMAX)THEN
         WRITE(6,*)'Lower channel > Higher channel'
         GO TO 99
      ENDIF
      IF(Istatus.NE.0)RETURN

 999  CONTINUE

      EXMIN=EGAP+400.
      WRITE(6,*)'The highest gamma-energy to be fitted is'
      WRITE(6,*)'limited by the final excitation energy (Ex-Eg).'
      WRITE(6,*)'This value must be equal or higher than Egap.'
      WRITE(6,18)EXMIN
  18  FORMAT(/'Lower final excit. energy (keV) >=Egap     <',
     1F6.0,'>:',$)
      CALL READF(5,EXMIN)

      IMIN=((800.-AX0)/AX1+0.5)
      EGMIN=AX1*IMIN+AX0
      WRITE(6,19)EGMIN,IMIN
  19  FORMAT(/'Lower ch. for fit on x-axis (Eg=',F5.0,
     +' keV)   <',I4,'>:',$)
      CALL READI(5,IMIN)

      WRITE(6,*)'Give exponent for: Egam**n. Use n=4.0 to 5.0, or'
      WRITE(6,20)NC
  20  FORMAT('n=0 according to appr. of Axel',15X,'<',F4.2,'>:',$)
      CALL READF(5,NC)
      CALL EXPONENT(NC)

      WRITE(6,21)AD,AA
  21  FORMAT('Starting level dens. par. a (A/8000=',F6.3,')',
     +'<',F6.3,'>:',$)
      CALL READF(5,AA)

      WRITE(6,22)XJ
  22  FORMAT('Give average spin populated',18X,'<',F4.1,'>:',$)
      CALL READF(5,XJ)

      WRITE(6,23)FWXG
  23  FORMAT('Energy FWHM for Ex-Eg (keV)',16X,'<',F6.1,'>:',$)
      CALL READF(5,FWXG)

      WRITE(6,24)NA
  24  FORMAT('Number of parameters in fit (max=2)',12X,'<',I1,'>:',$)
      CALL READI(5,NA)
      IF(Istatus.NE.0)RETURN

C SETTING UP THE HISTOGRAM TO BE FITIED, BOTH X(I) AND Y(I)
      NPTS=0
      DO J=JMIN,JMAX
        EX =J*AY1+AY0
        IMAX=((EX-EXMIN-AX0)/AX1+0.5)
        DO I=IMIN,IMAX
          NPTS=NPTS+1
          IF(NPTS.LE.50000)THEN
            X(NPTS)=NPTS
            XEN(NPTS)=AX1*I+AX0
            YEN(NPTS)=AY1*J+AY0
            Y(NPTS)=rMAT(ISP,I,J)
          ENDIF
        ENDDO
      ENDDO

      IF(NPTS.GT.50000)NPTS=50000
      WRITE(6,26)NPTS
  26  FORMAT('Number of datapoints in fit (max=50000)= ',I5)

      IF(NPTS.LT.NA+4)THEN
        WRITE(6,*)'Too few datapoints for fit'
        GO TO 25
      ENDIF

C ESTIMATE PARAMETERS TO BE FITTED
      A(1)=1.
      A(2)=AA
      EXPSUM=0.
      TEOSUM=0.
      DO JJ=1,NPTS
        EXPSUM=EXPSUM+Y(JJ)
        XX=JJ
        TEOSUM=TEOSUM+FUNC4(XX,A)
      ENDDO
      A(1)=EXPSUM/TEOSUM

      DO I=1,2
        SIGMAA(I)=A(I)/10.
      ENDDO

      DO I=1,NPTS
        SIGMAY(I)=100.
      ENDDO

      DELTAA(1)=A(1)/10.
      DELTAA(2)=A(2)/100.
      IF(Istatus.NE.0)RETURN
      
      cal(1,ISP,1,1)=  AX0
      cal(1,ISP,1,2)=  AX1
      cal(1,ISP,2,1)=  AY0
      cal(1,ISP,2,2)=  AY1
      cal(1,IDEST,1,1)=AX0
      cal(1,IDEST,1,2)=AX1
      cal(1,IDEST,2,1)=AY0
      cal(1,IDEST,2,2)=AY1
      

C*********************************************************************
C   FITIING LOOP STARTS
C*********************************************************************
      M     =0
      PROG  =0.00005
      MODE  =1
      CHISQR=999999.
      BEST  =999999.
      NBAD  =0

C     STARTING FIT **********************************************
      WRITE(6,30)
  30  FORMAT('  LOOP   CHISQR     A(1)       A(2)')
      IF(M.LT.4)WRITE(6,*)' '
      WRITE(6,31)M,CHISQR,(A(JJ),JJ=1,NA)
  33  CALL GRIDLS(X,Y,SIGMAY,NPTS,MODE,FUNC4,A
     +,DELTAA,SIGMAA,NA,FIT,CHISQR)
      M=M+1
      WRITE(6,31)M,CHISQR,(A(JJ),JJ=1,NA)
  31  FORMAT(1X,I3,3(1X,E10.5))
      CH(M)=CHISQR
      IF(M.LT.2) GO TO 33
      VER=ABS(CH(M)-CH(M-1))/CH(M-1)
      IF(CHISQR.LT.BEST)THEN
        BEST=CHISQR
        AA1=A(1)
        AA2=A(2)
        SIGAA1=SIGMAA(1)
        SIGAA2=SIGMAA(2)
      ENDIF
      IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
      IF(NBAD.GT.4)GO TO 34
      IF(M.GE.500)GO TO 34
      IF(VER.GT.PROG) GO TO 33
  34  CONTINUE

C     FIT IS FINISHED *********************************************
      A(1)=AA1
      SIGMAA(1)=SIGAA1
      A(2)=AA2
      SIGMAA(2)=SIGAA2

      WRITE(6,39)NC,BEST
  39  FORMAT(/' Results: n= ',F4.1,' (0 means Axel) with Chisqr1.=',
     +F8.3)
      WRITE(6,40)
  40  FORMAT(3('--------------------------'))
      WRITE(6,41)  A(1),SIGMAA(1)
      WRITE(6,42)  A(2),SIGMAA(2)
  41  FORMAT(' Normalisation parameter A(1)=',E10.4,' +/-',E10.4)
  42  FORMAT(' Level density parameter A(2)= ',F9.5,' +/-',F9.5,
     +' /keV ')
      WRITE(6,40)

      EXPSUM=0.
      TEOSUM=0.
      DO JJ=1,NPTS
        EXPSUM=EXPSUM+Y(JJ)
        XX=JJ
        TEOSUM=TEOSUM+FUNC4(XX,A)
      ENDDO

      TRUE=0.
      XCHI=0.
      XNORM=EXPSUM/TEOSUM
      A(1)=A(1)*XNORM
      DO JJ=1,NPTS
        I=((XEN(JJ)-AX0)/AX1+0.5)
        J=((YEN(JJ)-AY0)/AY1+0.5)
        XX=JJ
        YY=FUNC4(XX,A)
        rMAT(IDEST,I,J)=YY
        SIG2=10.
        IF(YY.GT.1)SIG2=100.**2
       IF(rMAT(ISP,I,J).GT.0.OR.rMAT(IDEST,I,J).GT.0)THEN
          TRUE=TRUE+1.
          XCHI=XCHI+((ABS(rMAT(ISP,I,J)-rMAT(IDEST,I,J)))**2)/SIG2
        ENDIF
      ENDDO

      XCHI=XCHI/(TRUE-NA-1.)
      ITRUE=TRUE
      IEXP=EXPSUM+0.5
      WRITE(6,58)IEXP,A(1),XCHI,ITRUE,NPTS
  58  FORMAT(' After renormalization to ',I6,' counts: A(1)= ',E10.4,/,
     +' Chisqr2.= ',F8.3,' (based on ',I4,' out of ',I4,' points)')

  25  IDUM=1
      WRITE(6,57)
  57  FORMAT(/'Press 1 for new try, or 0 for return to mama')
      CALL READI(5,IDUM)
      IF(IDUM.EQ.1)GO TO 999

C Updating comment in the heading of spectrum file
      xcomm(1:11)='TF:'//fname(1,ISP)(1:8)
      fname(1,IDEST)='TF'//fname(1,ISP)(1:6)
      comm(1,IDEST)=''
      CALL AddComment(xcomm,11)

      RETURN
      END


      SUBROUTINE MAKEPART
      INTEGER XDIM,YDIM 
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2 
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF     
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ITYPE.GT.1)THEN
        IXL=0
        IXH=Idim(1,ISP,1)-1
        IYL=0
        IYH=Idim(1,ISP,2)-1
        WRITE(6,3)IXL
   3    FORMAT(/'Lower marker on x-axis   <',I5,'>:',$)
        CALL READI(5,IXL)
        WRITE(6,4)IXH
   4    FORMAT( 'Higher marker on x-axis  <',I5,'>:',$)
        CALL READI(5,IXH)
        WRITE(6,5)IYL
   5    FORMAT(/'Lower marker on y-axis   <',I5,'>:',$)
        CALL READI(5,IYL)
        WRITE(6,6)IYH
   6    FORMAT( 'Higher marker on y-axis  <',I5,'>:',$)
        CALL READI(5,IYH)
        IF(IXL.GT.IXH)THEN
          WRITE(6,*)' Lower x-marker > x-higher marker'
          Istatus=1
        ENDIF
        IF(IYL.GT.IYH)THEN
          WRITE(6,*)' Lower y-marker > y-higher marker'
          Istatus=1
        ENDIF

        IF(Istatus.NE.0)RETURN
        
        XDIM=IXH-IXL+1
        YDIM=IYH-IYL+1
        IF(XDIM.GT.4096)XDIM=4096
        IF(YDIM.GT.512) YDIM=512
        DO J=0,YDIM-1
          DO I=0,XDIM-1
            I1=I+IXL
            J1=J+IYL
        IF(I1.GE.0.AND.I1.LE.4095.AND.J1.GE.0.AND.J1.LE.511)THEN
              rMAT(IDEST,I,J)=rMAT(ISP,I1,J1)
            ENDIF
          ENDDO
        ENDDO
        
        ax0=cal(1,ISP,1,1)
        ax1=cal(1,ISP,1,2)
        ax2=cal(1,ISP,1,3)
        cal(1,IDEST,1,1)=ax0+IXL*ax1+IXL*IXL*ax2
        cal(1,IDEST,1,2)=ax1+2.*IXL*ax2
        cal(1,IDEST,1,3)=ax2

        ay0=cal(1,ISP,2,1)
        ay1=cal(1,ISP,2,2)
        ay2=cal(1,ISP,2,3)
        cal(1,IDEST,2,1)=ay0+IYL*ay1+IYL*IYL*ay2
        cal(1,IDEST,2,2)=ay1+2.*IYL*ay2
        cal(1,IDEST,2,3)=ay2
        CALL SetMarker(1,1,1)
        WRITE(6,7)XDIM-1,YDIM-1
    7   FORMAT('New dimension (0:',I4,',0:',I4,')')

C Updating comment in the heading of spectrum file
        xcomm(1:3)='PA:'
        fname(1,IDEST)=fname(1,ISP)
        write(xcomm(4:22),991,ERR=997)IXL,'-',IXH,',',IYL,'-',IYH
991     FORMAT(I4,A1,I4,A1,I4,A1,I4)
        comm(1,IDEST)=comm(1,ISP)
997     CALL AddComment(xcomm,22)
      ELSE

        IXL=0
        IXH=Idim(2,ISP,1)-1
        WRITE(6,3)IXL
        CALL READI(5,IXL)
        WRITE(6,4)IXH
        CALL READI(5,IXH)
        IF(IXL.GT.IXH)THEN
          WRITE(6,*)' Lower marker > higher marker'
          Istatus=1
        ENDIF
        IF(Istatus.NE.0)RETURN

        MAXCH=IXH-IXL
        IF(MAXCH.GT.8191)MAXCH=8191
        DO I=0,MAXCH
          I1=I+IXL
          IF(I1.GE.0.AND.I1.LE.8191)THEN
             rSPEC(IDEST,I)=rSPEC(ISP,I1)
          ENDIF
        ENDDO
        ax0=cal(2,ISP,1,1)
        ax1=cal(2,ISP,1,2)
        ax2=cal(2,ISP,1,3)
        cal(2,IDEST,1,1)=ax0+IXL*ax1+IXL*IXL*ax2
        cal(2,IDEST,1,2)=ax1+2.*IXL*ax2
        cal(2,IDEST,1,3)=ax2
        CALL SetMarker(1,2,0)       
        WRITE(6,8)MAXCH
    8   FORMAT('New dimension (0:',I4,')')

C Updating comment in the heading of spectrum file
        xcomm(1:3)='PA:'
        fname(2,IDEST)=fname(2,ISP)
        write(xcomm(4:12),992,ERR=998)IXL,'-',IXH
992     FORMAT(I4,A1,I4)
        comm(2,IDEST)=comm(2,ISP)
998     CALL AddComment(xcomm,12)
      ENDIF
      END
                       

      SUBROUTINE NORMALIZE
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      WRITE(6,1)IDEST
   1  FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=IDEST
      WRITE(6,2)ISP
   2  FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(Istatus.NE.0)RETURN
        
      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)
        DO J=0,511
          SUM=0
          DO I=0,4095
            SUM=SUM+rMAT(ISP,I,J)
          ENDDO
          DO I=0,4095
            IF(SUM.NE.0)THEN
             rMAT(IDEST,I,J)=rMAT(ISP,I,J)/SUM
            ELSE
              rMAT(IDEST,I,J)=0
             ENDIF
          ENDDO
        ENDDO
        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)

C Updating comment in the heading of spectrum file
        xcomm(1:3)='NO:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)

      ELSE
        MAXCH=Idim(2,ISP,1)-1
        SUM=0
        DO I=0,8191
          SUM=SUM+rSPEC(ISP,I)
        ENDDO
        DO I=0,4095
          IF(SUM.NE.0)THEN
            rSPEC(IDEST,I)=rSPEC(ISP,I)/SUM
          ELSE
            rSPEC(IDEST,I)=0
          ENDIF
        ENDDO
        cal(2,IDEST,1,1)=cal(2,ISP,1,1)
        cal(2,IDEST,1,2)=cal(2,ISP,1,2)
        cal(2,IDEST,1,3)=cal(2,ISP,1,3)

C Updating comment in the heading of spectrum file
        xcomm(1:3)='NO:'
        fname(2,IDEST)=fname(2,ISP)
        comm(2,IDEST)=comm(2,ISP)
        CALL AddComment(xcomm,3)

      ENDIF
      END


      SUBROUTINE NUTE
      CHARACTER APP*4
      EXTERNAL FUNC1,EXPONENT
      DIMENSION FIT(4096)
      DIMENSION X(4096),Y(4096),SIGMAY(4096),A(5),DELTAA(5),SIGMAA(5),CH(500)
      REAL N,MASS,NC
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/CALxy/AX0,AX1,AY0,AY1
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      INTEGER XDIM,YDIM
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
     
      WRITE(6,2)IDEST
 2    FORMAT('Dest. spectr. for theoretical fit <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,3)ISP
 3    FORMAT( 'Source spectrum                   <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(Istatus.NE.0)RETURN
      XDIM=Idim(1,ISP,1)
      YDIM=Idim(1,ISP,2)
 
C     SETTING DEFAULT VALUES AND
C     READING IN VARIOUS PARAMETERS TO BE USED
      SUM=0.
      DO J=0,YDIM-1
        DO I=0,XDIM-1
          SUM=SUM+rMAT(ISP,I,J)
          rMAT(IDEST,I,J)=0
        ENDDO
      ENDDO
      IF(SUM.EQ.0)THEN
        WRITE(6,*)'Forgotten to read in source spectrum'
        Istatus=1
        RETURN
      ENDIF
      MASS=172.
      EGAP=1830.
      NC=4.
      AA=0.012
      XJ=4.
      FWXG=500.
      NA=2
      
      bx=cal(1,ISP,1,1)+cal(1,ISP,1,2)+cal(1,ISP,1,3)
      by=cal(1,ISP,2,1)+cal(1,ISP,2,2)+cal(1,ISP,2,3)
      IF(bx+by.EQ.2.)THEN
        AX0=11.
        AX1=20.
        AY0=9660.
        AY1=-120.
      ELSE
        AX0=cal(1,ISP,1,1)
        AX1=cal(1,ISP,1,2)
        AY0=cal(1,ISP,2,1)
        AY1=cal(1,ISP,2,2)
      ENDIF

  99  CONTINUE
      WRITE(6,10)AX0
  10  FORMAT(//'Cal. coeff. a0 (keV) on x-axis    <',F11.1,'>:',$)
      CALL READF(5,AX0)
      WRITE(6,11)AX1
  11  FORMAT(  'Cal. coeff. a1 (keV/ch) on  x-axis<',F11.1,'>:',$)
      CALL READF(5,AX1)

      WRITE(6,12)AY0
  12  FORMAT(/'Cal. coeff. a0 (keV) on y-axis   <',F11.1,'>:',$)
      CALL READF(5,AY0)
      WRITE(6,13)AY1
  13  FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis<',F11.1,'>:',$)
      CALL READF(5,AY1)

      WRITE(6,14)MASS
  14  FORMAT(/'Mass number',5X,'                    <',F4.0,'>:',$)
      CALL READF(5,MASS)

      GAP=1000.*2.*12.*MASS**(-0.5)
      WRITE(6,15)GAP,EGAP
  15  FORMAT('Pairing gap (2*12/sqrt(A)=',F5.0,')',4X,'<',F5.0,'>:',$)
      CALL READF(5,EGAP)
      IF(Istatus.NE.0)RETURN

      JMIN=((EGAP -AY0)/AY1+0.5)
      JMAX=((8000.-AY0)/AY1+0.5)
      IF(JMIN.GT.JMAX)THEN
        JWAIT=JMIN
        JMIN=JMAX
        JMAX=JWAIT
      ENDIF
      IF(JMIN.LT.0)JMIN=0
      IF(JMAX.GE.YDIM-1)JMAX=YDIM-1
      EYMIN=AY1*JMIN+AY0
      EYMAX=AY1*JMAX+AY0
      WRITE(6,*)'Spectra to be fitted, give low and high y-channel'
      WRITE(6,16)EYMIN,JMIN
  16  FORMAT(/'Lower ch. (excitation ',F8.2,' keV)',8X,' <',I4,'>:',$)
      CALL READI(5,JMIN)
      WRITE(6,17)EYMAX,JMAX
  17  FORMAT( 'Higher ch. (excitation ',F8.2,' keV)',8X,'<',I4,'>:',$)
      CALL READI(5,JMAX)
      IF(JMIN.GT.JMAX)THEN
         WRITE(6,*)'Lower ch. > Higher ch.'
         GO TO 99
      ENDIF
      IF(Istatus.NE.0)RETURN

      EXMIN=EGAP+200.
      WRITE(6,*)'The highest gamma-energy to be fitted is'
      WRITE(6,*)'limited by the final exc. energy (Ex-Eg).'
      WRITE(6,*)'This value must be equal or higher than Egap.'
      WRITE(6,18)EXMIN
  18  FORMAT(/'Lower final excit. energy (keV) >=Egap <',F6.0,'>:',$)
    
      CALL READF(5,EXMIN)

      IMIN=((800.-AX0)/AX1+0.5)
      EGMIN=AX1*IMIN+AX0
      WRITE(6,19)EGMIN,IMIN
  19  FORMAT(/'Lower ch. for fit on x-axis (Eg=',F5.0,
     +' keV)   <',I4,'>:',$)
      CALL READI(5,IMIN)

      WRITE(6,*)'Give exponent for: Egam**n. Use n=4.0 to 5.0, or'
      WRITE(6,20)NC
  20  FORMAT('n=0 according to appr. of Axel',12X,'<',F4.2,'>:',$)
      CALL READF(5,NC)
      CALL EXPONENT(NC)

      AD=MASS/8000.
      WRITE(6,21)AD,AA
  21  FORMAT('Init. level density param. a (A/8000=',F5.3,')',
     +' <',F5.3,'>:',$)
      CALL READF(5,AA)

      WRITE(6,22)XJ
  22  FORMAT('Give average spin populated',6X,'<',F4.1,'>:',$)
      CALL READF(5,XJ)

      WRITE(6,23)FWXG
  23  FORMAT('Energy FWHM  for Ex-Eg (keV)<',F6.1,'>:',$)
      CALL READF(5,FWXG)

      WRITE(6,24)NA
  24  FORMAT('Number of parameters in fit (max=2)<',I1,'>:',$)
      CALL READI(5,NA)
      IF(Istatus.NE.0)RETURN

      cal(1,ISP,1,1)=  AX0
      cal(1,ISP,1,2)=  AX1
      cal(1,ISP,2,1)=  AY0
      cal(1,ISP,2,2)=  AY1
      cal(1,IDEST,1,1)=AX0
      cal(1,IDEST,1,2)=AX1
      cal(1,IDEST,2,1)=AY0
      cal(1,IDEST,2,2)=AY1

C******************************************************* 
C   FITIING LOOP STARTS
C******************************************************* 

      PROG=0.0001
      MODE=1
      CHITOT=0
      DO J=JMIN,JMAX
        M=0
C SETTING UP THE HISTOGRAM TO BE FITIED, BOTH X(I) AND Y(I)
        EX =J*AY1+AY0
        EXL=EX-FWXG/2.
        EXH=EX+FWXG/2.
         IF(EXL.LT.0)EXL=0.
        IMAX=((EX-EXMIN-AX0)/AX1+0.5)
        IF(IMAX.LE.IMIN+NA+1)THEN
          WRITE(6,*)'Too few data for fit'
          GO TO 25
        ENDIF
        NPTS=0
        DO I=IMIN,IMAX
          NPTS=NPTS+1
          X(NPTS)=AX1*I+AX0
          Y(NPTS)=rMAT(ISP,I,J)
        ENDDO

C ESTIMATE PARAMETERS TO BE FITIED
        A(1)=1.0
        A(2)=AA
        DO I=1,2
          SIGMAA(I)=A(I)/10.
        ENDDO
        DELTAA(2)=A(2)/100.
        EXPSUM=0.
        TEOSUM=0.
        DO I=1,NPTS
          EXPSUM=EXPSUM+Y(I)
        ENDDO
        YAVE=EXPSUM/(NPTS+1)
        DO I=1,NPTS
          SIGMAY(I)=SQRT(3.*9.*YAVE)
          XX=X(I)
          TEOSUM=TEOSUM+FUNC1(XX,A)
        ENDDO
        FACTOR=EXPSUM/TEOSUM
        A(1)=A(1)*FACTOR
        DELTAA(1)=A(1)/10.
        CHISQR=999999.
        BEST=999999.
        NBAD=0

C     STARTING FIT **********************************************
        WRITE(6,30)
  30    FORMAT('  LOOP   CHISQR     A(1)       A(2)')
        IF(M.LT.4)WRITE(6,*)' '
        WRITE(6,31)M,CHISQR,(A(JJ),JJ=1,NA)
  33    CALL GRIDLS(X,Y,SIGMAY,NPTS,MODE,FUNC1,A
     +  ,DELTAA,SIGMAA,NA,FIT,CHISQR)
        M=M+1
        WRITE(6,31)M,CHISQR,(A(JJ),JJ=1,NA)
  31    FORMAT(I4,3(1X,E10.5))
        CH(M)=CHISQR
        IF(M.LT.2) GO TO 33
        VER=ABS(CH(M)-CH(M-1))/CH(M-1)
        IF(CHISQR.LT.BEST)THEN
          BEST=CHISQR
          AA1=A(1)
          AA2=A(2)
          SIGAA1=SIGMAA(1)
          SIGAA2=SIGMAA(2)
         ENDIF
        IF(CH(M).GT.CH(M-1))NBAD=NBAD+1
        IF(NBAD.GT.4)GO TO 34
        IF(M.GE.500)GO TO 34
        IF(VER.GT.PROG) GO TO 33
  34    CONTINUE

C     FIT IS FINISHED *********************************************
        A(1)=AA1
        SIGMAA(1)=SIGAA1
        A(2)=AA2
        SIGMAA(2)=SIGAA2

        WRITE(6,39)J,EX,IMIN,IMAX,BEST
  39    FORMAT(/' Results for y-ch:',I3,' (Exi=',F6.0,
     +  ' keV) and x-chs:',I3,' -',I3,',  Chisqr.=',F8.3)
        CHITOT=CHITOT+BEST

        WRITE(6,40)
  40    FORMAT(3('--------------------------'))
        WRITE(6,41)  A(1),SIGMAA(1)
        WRITE(6,42)  A(2),SIGMAA(2)
  41    FORMAT(' Normalisation parameter A(1)=',E10.4,' +/-',E10.4)
  42    FORMAT(' Level density parameter A(2)= ',F9.5,' +/-',F9.5,
     +  ' /keV ')
        WRITE(6,40)
        EXPSUM=0.
        TEOSUM=0.
        DO I=1,NPTS
          EXPSUM=EXPSUM+Y(I)
          XX=X(I)
          TEOSUM=TEOSUM+FUNC1(XX,A)
        ENDDO
        IEXP=EXPSUM+0.5
        ITEO=TEOSUM+0.5

        ASUM=0.
        CENT=0.
        DO I=0,IMAX
          XX=AX1*I+AX0
          rMAT(IDEST,I,J)=FUNC1(XX,A)+0.5
          CENT=CENT+XX*FUNC1(XX,A)
          ASUM=ASUM+FUNC1(XX,A)
        ENDDO
        CENT=CENT/ASUM
    
        WRITE (1,50)CENT
  50    FORMAT(' Average theor. gamma-energy in f.g.=',F7.1,' keV')
        EXFINAL=EX-CENT
        WRITE(6,51)EXFINAL
  51    FORMAT(' Final average excit. energy in f.g.=',F7.1,' keV')

        IF(A(2).GT.0.AND.EX-CENT-EGAP-300..GT.0)THEN
           TT=SQRT((EX-CENT-EGAP-300.)/A(2))
        ELSE
          TT=0
        ENDIF
        WRITE(6,52)TT
  52    FORMAT(' Temperature                        =',F7.1,' keV')
        WRITE(6,56)IEXP,ITEO
  56    FORMAT(' Areas in fit-region:  Exp.:',
     +  I6,' Theor.:',I6)

        LOOPS=J-JMIN+1
        CHIAV=CHITOT/LOOPS
        WRITE(6,53)LOOPS,CHIAV
  53    FORMAT(' Average chisq. after ',I2,' spectra is ',F8.3)

  25    IF(J.LT.JMAX)THEN
          WRITE(6,57)
  57      FORMAT(/'Press return for fit of next y-ch, or 0 for stop:')
          IDUM=1
          CALL READI(5,IDUM)
          IF(IDUM.EQ.0)THEN
C Updating comment in the heading of spectrum file
            xcomm(1:11)='NU:'//fname(1,ISP)(1:8)
            fname(1,IDEST)='NU'//fname(1,ISP)(1:6)
            comm(1,IDEST)=''
            CALL AddComment(xcomm,11)
            RETURN
          ENDIF
        ENDIF
      ENDDO
      RETURN
      END


      SUBROUTINE PUTCONST
      INTEGER XDIM,YDIM 
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      CONST=0
      IXL=0
      IXH=4095
      IYL=0
      IYH=511

      IF(ITYPE.GT.1)THEN
        WRITE(6,1)IDEST
   1    FORMAT('Destination spectrum <',I1,'>:',$)
        CALL READI(5,IDEST)
        IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
        IF(Istatus.NE.0)RETURN
        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
        WRITE(6,3)IXL
   3    FORMAT(/'Lower marker on x-axis <',I5,'>:',$)
        CALL READI(5,IXL)
        WRITE(6,4)IXH
   4    FORMAT( 'Higher marker on x-axis<',I5,'>:',$)
        CALL READI(5,IXH)
        WRITE(6,5)IYL
   5    FORMAT(/'Lower marker on y-axis <',I5,'>:',$)
        CALL READI(5,IYL)
        WRITE(6,6)IYH
   6    FORMAT( 'Higher marker on y-axis<',I5,'>:',$)
        CALL READI(5,IYH)
        WRITE(6,7)CONST
   7    FORMAT(/'Type constant <',F3.0,'>:',$)
        CALL READF(5,CONST)
        IF(Istatus.NE.0)RETURN
        IF(IXL.GT.4095.OR.IXH.GT.4095.OR.IYL.GT.511.OR.IYH.GT.511)THEN
          WRITE(6,*)'x > 4095 or y > 511'
          RETURN
        ENDIF
        DO J=IYL,IYH
          DO I=IXL,IXH
            rMAT(IDEST,I,J)=CONST
          ENDDO
        ENDDO
      ELSE
        WRITE(6,1)IDEST
        CALL READI(5,IDEST)
        IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
        IF(Istatus.NE.0)RETURN
        MAXCH=Idim(2,IDEST,1)-1
        WRITE(6,3)IXL
        CALL READI(5,IXL)
        WRITE(6,4)IXH
        CALL READI(5,IXH)
        WRITE(6,7)CONST
        CALL READF(5,CONST)
        IF(Istatus.NE.0)RETURN
        DO I=IXL,IXH
          rSPEC(IDEST,I)=CONST
        ENDDO
      ENDIF

C Updating comment in the heading of spectrum file
      xcomm(1:3)='PC:'
      CALL AddComment(xcomm,3)
      END


      SUBROUTINE PROJ
      COMMON/FREEZE/ifreeze
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      INTEGER XDIM,YDIM
      CHARACTER APP*4,ANS*1
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT

      ISP=IDEST
      WRITE(6,1)IDEST
   1  FORMAT('Destination singles spectrum    <',I1,'>:',$)
      CALL READI(5,IDEST)
      WRITE(6,2)ISP
   2  FORMAT( 'Source matrix                   <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1
      IF(Istatus.NE.0)RETURN
      DO I=0,8191
        rSPEC(IDEST,I)=0
      ENDDO
      IF(ANS.NE.'x'.AND.ANS.NE.'X'.AND.ANS.NE.'y'.AND.ANS.NE.'Y')ANS='x'
      WRITE(6,3)ANS
   3  FORMAT('Projection down to x or y axis  <',A1,'>:',$)
      CALL READA1(5,ANS)
      IISTAT=0

      IF(ANS.EQ.'X'.OR.ANS.EQ.'x')THEN
        IF(J1.EQ.0.AND.J2.EQ.0)THEN
          J1=0
          J2=Idim(1,ISP,2)-1
        ENDIF
        IF(ITYPE.EQ.3)THEN
          J1=LDY
          J2=HDY
        ENDIF
        WRITE(6,4)J1
   4    FORMAT('Lower marker on y-axis       <',I4,'>:',$)
        CALL READI(5,J1)
        WRITE(6,5)J2
   5    FORMAT('Higher marker on y-axis      <',I4,'>:',$)
        CALL READI(5,J2)
        IF(J1.GT.511.OR.J2.GT.511)Istatus=1
        IF(Istatus.NE.0)RETURN
        IISTAT=1
        IXY=1
        DO I=0,4095
          DO J=J1,J2
            rSPEC(IDEST,I)=rSPEC(IDEST,I)+rMAT(ISP,I,J)
          ENDDO
        ENDDO
        cal(2,IDEST,1,1)=cal(1,ISP,1,1)
        cal(2,IDEST,1,2)=cal(1,ISP,1,2)
        cal(2,IDEST,1,3)=cal(1,ISP,1,3)
        ITYPE=1
        MAXCH=Idim(1,ISP,1)-1

C Updating comment in the heading of spectrum file
        comm(2,IDEST)(1:60)=''
        xcomm(1:12)=fname(1,ISP)(1:8)//'PMx:'
        write(xcomm(13:16),991,ERR=997)J1
991     FORMAT(I4)
        xcomm(17:17)='-'
        write(xcomm(18:21),991,ERR=997)J2
        CALL AddComment(xcomm,21)
997     fname(2,IDEST)='PM'//fname(1,ISP)(1:6)

      ENDIF

      IF(ANS.EQ.'Y'.OR.ANS.EQ.'y')THEN
        IISTAT=1
        IF(I1.EQ.0.AND.I2.EQ.0)THEN
          I1=0
          I2=Idim(1,ISP,1)-1
        ENDIF
        IF(ITYPE.EQ.3)THEN
          I1=LDX
          I2=HDX
        ENDIF
        WRITE(6,6)I1
   6    FORMAT('Lower marker on x-axis       <',I4,'>:',$)
        CALL READI(5,I1)
        WRITE(6,7)I2
   7    FORMAT('Higher marker on x-axis      <',I4,'>:',$)
        CALL READI(5,I2)
        IF(Istatus.NE.0)RETURN
        IISTAT=1
        IXY=2
        DO J=0,511
          IF(I1.GT.4095.OR.I2.GT.4095)Istatus=1
          IF(Istatus.NE.0)RETURN
          DO I=I1,I2
            rSPEC(IDEST,J)=rSPEC(IDEST,J)+rMAT(ISP,I,J)
          ENDDO
        ENDDO
        cal(2,IDEST,1,1)=cal(1,ISP,2,1)
        cal(2,IDEST,1,2)=cal(1,ISP,2,2)
        cal(2,IDEST,1,3)=cal(1,ISP,2,3)
        ITYPE=1
        MAXCH=Idim(1,ISP,2)-1

C Updating comment in the heading of spectrum file
        comm(2,IDEST)(1:60)=''
        xcomm(1:12)=fname(1,ISP)(1:8)//'PMy:'
        write(xcomm(13:16),991,ERR=998)I1
        xcomm(17:17)='-'
        write(xcomm(18:21),991,ERR=998)I2
        CALL AddComment(xcomm,21)
998     fname(2,IDEST)='PM'//fname(1,ISP)(1:6)
      ENDIF

      IF(IISTAT.EQ.0)Istatus=2
      IF(Istatus.NE.0)RETURN
      
C Trying to find out if PM is made in a serie - then displaymarkers are kept the same
      IF(IDEST.NE.IDESTold.OR.HICH.NE.HICHold.OR.IXY.NE.IXYold.OR.
     +   HICNT.EQ.1000.OR.HICH.EQ.8191)THEN
        IF(ifreeze.EQ.1)THEN
          CALL SetMarker(0,0,0)
        ELSE
          CALL SetMarker(2,2,0)
        ENDIF
      ELSE
        CALL SetMarker(0,0,0)
      ENDIF
   
      WRITE(6,8)IDEST
   8  FORMAT('Projection is stored in singles spectrum',I2)
      IDESTold=IDEST               !Remember for next PM
      HICHold =HICH
      IXYold  =IXY
      RETURN
      END


      SUBROUTINE RANDOMIZE
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      INTEGER time
      
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)

      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1
      r=rand(time())

C   STARTING THE SMOOTHING PROCEDURE
      IF(ITYPE.GT.1)THEN
        DO J=0,YDIM-1                 ! 3-dim matrices
          JT=(J/30)*30
          IF(JT.EQ.J)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF
          DO I=0,XDIM-1
            r=rand(0) 
            z=Finvert(r)
            rMAT(IDEST,I,J)=rMAT(ISP,I,J)+z*SQRT(ABS(rMAT(ISP,I,J)))
          ENDDO
        ENDDO
        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='RA:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
        WRITE(6,*)' '
      ELSE
        DO I=0,MAXCH                  ! 1-dim spectra
          r=rand(0) 
          z=Finvert(r)
          rSPEC(IDEST,I)=rSPEC(ISP,I)+z*SQRT(ABS(rSPEC(ISP,I)))
        ENDDO
        cal(2,IDEST,1,1)=cal(2,ISP,1,1)
        cal(2,IDEST,1,2)=cal(2,ISP,1,2)
        cal(2,IDEST,1,3)=cal(2,ISP,1,3)

C Updating comment in the heading of spectrum file
        xcomm(1:3)='RA:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
      ENDIF
      END


      FUNCTION Finvert(y0)
C Inverting the monoton increasing function r=F(z) -> z=Finv(r) 
C This means to find the z-value giving the value y0 
C The function F is the cummulative Gauss function F=1/2(1+erf(z/sqrt(2)))
      REAL xl,xh,yl,yh,x,y,y0
      xl =-3.0
      xh = 3.0
      x  = 0.0
      yl = 0.0
      yh = 1.0
      y  = 0.5
      DO WHILE (ABS(y-y0).GT.0.001)
        x = xl + (xh-xl)*(y0-yl)/(yh-yl)
        y = 0.5*(1.+erf(x/1.414213562))
        IF(y.GT.y0)THEN
          yl=y
          xl=x
        ELSE
          yh=y
          xh=x
        ENDIF
      ENDDO
      Finvert=x
      RETURN
      END


      SUBROUTINE REPLACE
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      REAL Mmin, Mmax

      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(Istatus.NE.0)RETURN

C Asking for the method to be applied
      WRITE(6,*)' '
      WRITE(6,*)'With this command you may replace the counts in the'
      WRITE(6,*)'spectrum/matrix with a given value. The options are:'
      WRITE(6,*)'Replace counts if they are below a certain value, or,'
      WRITE(6,*)'if the counts are in-between two values, or if the'
      WRITE(6,*)'counts exceed a certain value. The defaults are:'
      WRITE(6,*)'Choose (1), replace-value = 0 and Max = 0 which will'
      WRITE(6,*)'delete all negative numbers.'
      WRITE(6,*)'You may also change floating point values -> integers.'
      WRITE(6,*)'----------------------------------------------------- '
      WRITE(6,*)'      Counts < Max is replaced........... choose: (1)'
      WRITE(6,*)'Min < Counts < Max is replaced........... choose: (2)'
      WRITE(6,*)'Min < Counts       is replaced........... choose: (3)'
      WRITE(6,*)'Replace floating counts by integers...... choose: (4)'
      WRITE(6,*)'Return to MAMA........................... choose: (5)'
      WRITE(6,*)'----------------------------------------------------- '

      NuReplaced = 0
      TotOld = 0.
      TotNew = 0.

      mode = 1
      WRITE(6,4)mode
  4   FORMAT(' Choose your option                               <',I1,'>:',$)
      CALL READI(5,mode)
      IF(mode.EQ.5)RETURN
     
      IF(Istatus.NE.0.OR.mode.LT.1.or.mode.GT.4)THEN
        WRITE(6,*) 'Illegal parameter, valid region:'
        WRITE(6,*) '0 < method < 6'
        RETURN
      ENDIF

      IF(mode.NE.4)THEN
        ReplaceValue = 0.
        WRITE(6,14)ReplaceValue
  14    FORMAT(/'Give new value for the counts to be replaced <',F6.2,'>:',$)
        CALL READF(5,ReplaceValue)

      ENDIF

      IF(Istatus.NE.0)RETURN

      IF(mode.EQ.1)THEN
        Mmax = 0.
        WRITE(6,10)Mmax
 10     FORMAT('Delete counts with value lower than          <',F6.2,'>:',$)
        CALL READF(5,Mmax)
      ENDIF
      IF(mode.EQ.2)THEN
        WRITE(6,15)
 15     FORMAT('Answer two questions for lower and higher limits:')
        Mmin = -4.
        WRITE(6,11)Mmin
 11     FORMAT('Delete counts with value higher than         <',F6.2,'>:',$)
        CALL READF(5,Mmin)
        Mmax = MIN(ABS(Mmin),4.)
        WRITE(6,12)Mmax
 12     FORMAT('AND with value lower than                    <',F6.2,'>:',$)
        CALL READF(5,Mmax)
        IF(Mmax.LT.Mmin)THEN
          Write(6,*)'Mmax < Mmin, try again...'
          Istatus=1
        ENDIF
      ENDIF
      IF(mode.EQ.3)THEN
        Mmin = 100000.
        WRITE(6,13)Mmin
 13     FORMAT('Delete counts with value higher than      <',F9.1,'>:',$)
        CALL READF(5,Mmin)
      ENDIF

      IF(Istatus.NE.0)RETURN

      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)
        DO J=0,YDIM-1
          DO I=0,XDIM-1
            xx=rMAT(ISP,I,J)
            TotOld=TotOld+xx
          ENDDO
        ENDDO

        DO J=0,YDIM-1
          DO I=0,XDIM-1
            xx=rMAT(ISP,I,J)
            IF(mode.EQ.1)THEN
              IF(xx.LT.Mmax)THEN
                NuReplaced=NuReplaced+1
                xx=ReplaceValue
              ENDIF
            ENDIF
            IF(mode.EQ.2)THEN
              IF(xx.GT.Mmin.AND.xx.LT.Mmax)THEN
                NuReplaced=NuReplaced+1
                xx=ReplaceValue
              ENDIF
            ENDIF
            IF(mode.EQ.3)THEN
              IF(xx.GT.Mmin)THEN
                NuReplaced=NuReplaced+1
                xx=ReplaceValue
              ENDIF
            ENDIF
            IF(mode.EQ.4)THEN
              NuReplaced=NuReplaced+1
              xx=INT(xx+0.5)
            ENDIF
            rMAT(IDEST,I,J)=xx
            TotNew = TotNew + xx
          ENDDO
        ENDDO

        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='RN:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
      ELSE
        MAXCH=Idim(2,ISP,1)-1
        DO I=0,MAXCH
          xx=rSPEC(ISP,I)
          TotOld=TotOld+xx
        ENDDO
        DO I=0,MAXCH
          xx=rSPEC(ISP,I)
          IF(mode.EQ.1)THEN
            IF(xx.LT.Mmax)THEN
              NuReplaced=NuReplaced+1
              xx=ReplaceValue
            ENDIF
          ENDIF
          IF(mode.EQ.2)THEN
            IF(xx.GT.Mmin.AND.xx.LT.Mmax)THEN
              NuReplaced=NuReplaced+1
              xx=ReplaceValue
            ENDIF
          ENDIF
          IF(mode.EQ.3)THEN
            IF(xx.GT.Mmin)THEN
              NuReplaced=NuReplaced+1
              xx=ReplaceValue
            ENDIF
          ENDIF
          IF(mode.EQ.4)THEN
            NuReplaced=NuReplaced+1
            xx=INT(xx+0.5)
          ENDIF
          rSPEC(IDEST,I)=xx
          TotNew = TotNew + xx
        ENDDO
        cal(2,IDEST,1,1)=cal(2,ISP,1,1)
        cal(2,IDEST,1,2)=cal(2,ISP,1,2)
        cal(2,IDEST,1,3)=cal(2,ISP,1,3)
C Updating comment in the heading of spectrum file
        xcomm(1:3)='RN:'
        fname(2,IDEST)=fname(2,ISP)
        comm(2,IDEST)=comm(2,ISP)
        CALL AddComment(xcomm,3)
      ENDIF

      WRITE(6,20)NuReplaced
  20  FORMAT(/'Number of channels replaced:',I14)
      WRITE(6,21)TotOld
  21  FORMAT('Number of counts before:     ',F13.1)
      WRITE(6,22)TotNew
  22  FORMAT('Number of counts after:      ',F13.1)
      WRITE(6,23)TotNew-TotOld
  23  FORMAT('Increase of counts:          ',F13.1)

      END



      SUBROUTINE SMOOTH
      DIMENSION WEIGHT(-100:100,-100:100)
      INTEGER XDIM,YDIM,DELX,DELY
      CHARACTER APP*4,ANS*1
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      IDEST=IDUM
      WRITE(6,1)IDEST
 1    FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      WRITE(6,2)ISP
 2    FORMAT( 'Source spectrum      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDEST)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1

      IF(ITYPE.GT.1)THEN
        XDIM=Idim(1,ISP,1)
        YDIM=Idim(1,ISP,2)

        WRITE(6,3)XDIM
 3      FORMAT(/'Dimension along x-axis <',I4,'>:',$)
        CALL READI(5,XDIM)       
        WRITE(6,4)YDIM
 4      FORMAT( 'Dimension along y-axis <',I4,'>:',$)
        CALL READI(5,YDIM)
        IF(Istatus.NE.0)RETURN
        IXL=(XDIM/10.)+.5
        IXH=(XDIM-IXL)
        IYL=(YDIM/10.)+.5
        IYH=(YDIM-IYL)
        IF(IXL.LT.1)IXL=1
        IF(IXH.LT.1)IXH=1
        IF(IYL.LT.1)IYL=1
        IF(IYH.LT.1)IYH=1

        FWXL=1.
        FWXH=FWXL*SQRT(float(IXH/IXL))
        FWYL=1.
        FWYH=1.
        IF(XDIM.LT.2.OR.YDIM.LT.2)THEN
          WRITE(6,*)'Too small matrix'
          Istatus=1
          RETURN
        ENDIF

      ELSE
        MAXCH=Idim(2,ISP,1)-1
        IMAXCH=MAXCH+1
        WRITE(6,111)IMAXCH
 111    FORMAT(/'Dimension of spectrum <',I4,'>:',$)
        CALL READI(5,IMAXCH)
        IF(Istatus.NE.0)RETURN
        IXL=(IMAXCH/10.)+.5
        IXH=(IMAXCH-IXL)
        IF(IXL.LT.1)IXL=1
        IF(IXH.LT.1)IXH=1
        MAXCH=IMAXCH-1
        IYL=0
        IYH=0
        FWXL=1.
        FWXH=FWXL*SQRT(float(IXH/IXL))
        FWYL=0
        FWYH=0
        IF(MAXCH.LE.1)THEN
          WRITE(6,*)'Too short spectrum'
          Istatus=1
          RETURN
        ENDIF

      ENDIF
    

 34   CONTINUE
      WRITE(6,10)IXL,FWXL
 10   FORMAT(/'Write FWHMx (ch) around ch x= ',I4,' <',F6.1,'>:',$)
      CALL READF(5,FWXL)
      WRITE(6,11)IXH,FWXH
 11   FORMAT( 'Write FWHMx (ch) around ch x= ',I4,' <',F6.1,'>:',$)
      CALL READF(5,FWXH)

      IF(ITYPE.EQ.1)THEN
        FWYL=0.
        FWYH=0.
      ELSE
        WRITE(6,20)IYL,FWYL
 20     FORMAT(/'Write FWHMy (ch) around ch y= ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWYL)
        WRITE(6,21)IYH,FWYH
 21     FORMAT( 'Write FWHMy (ch) around ch y= ',I4,' <',F6.1,'>:',$)
        CALL READF(5,FWYH)
      ENDIF
      IF(Istatus.NE.0)RETURN

C Finding parametrization of fwhm.: FWHM = A + B * SQRT(ch)
      AY=0
      BY=0
      IF(IXL.NE.IXH)THEN
        BX=(FWXL-FWXH)/(SQRT(float(IXL))-SQRT(float(IXH)))
      ELSE
        BX=0
      ENDIF
      AX=FWXL-BX*SQRT(float(IXL))
      IF(ITYPE.GT.1)THEN
        IF(IYL.NE.IYH)THEN
          BY=(FWYL-FWYH)/(SQRT(float(IYL))-SQRT(float(IYH)))
        ELSE
          BY=0
        ENDIF
        AY=FWYL-BY*SQRT(float(IYL))
      ENDIF
      WRITE(6,*)'FWHM have been expressed by A + B * SQRT(ch):'
      WRITE(6,22)AX,BX,AY,BY
 22   FORMAT('Ax=',F8.4,'  Bx=',F8.4,'       Ay=',F8.4,' By=',F8.4)

C Displaying probability matrix at (xl,yl) and (xh,yh)

      IX=IXL
      IY=IYL
      CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
      WRITE(6,31)IX,IY
 31   FORMAT('Smoothing-matrix around (x,y)=(',I4,',',I4,'):')
      DO J=-4,4
        WRITE(6,30)(WEIGHT(I,J),I=-7,7)
      ENDDO

      IX=IXH
      IY=IYH
      CALL GAUSSR(IX,IY,AX,BX,AY,BY,DELX,DELY,WEIGHT)
      WRITE(6,32)IX,IY
 32   FORMAT(/'Smoothing-matrix around (x,y)=(',I4,',',I4,'):')
      DO J=-4,4
        WRITE(6,30)(WEIGHT(I,J),I=-7,7)
      ENDDO
 30   FORMAT(1X,15F5.3)
      ANS='y'
      WRITE(6,33)ANS
 33   FORMAT(/,'Smoothing-matrix OK? (y/n) <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(ANS.EQ.'N'.OR.ANS.EQ.'n') GO TO 34
      IF(Istatus.NE.0)RETURN

C   STARTING THE SMOOTHING PROCEDURE
      IF(ITYPE.GT.1)THEN
        DO J=0,YDIM-1                 ! 3-dim matrices
          JT=(J/10)*10
          IF(JT.EQ.J)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF
          DO I=0,XDIM-1
            IT=(I/10)*10
            IF(IT.EQ.I.OR.JT.EQ.J)THEN
              CALL GAUSSR(I,J,AX,BX,AY,BY,DELX,DELY,WEIGHT)
            ENDIF
            H=0.
            W=0.
            DO JJ=-DELY,DELY
              DO II=-DELX,DELX
                III=I+II
                JJJ=J+JJ
             IF(III.LT.0.OR.III.GE.XDIM.OR.JJJ.LT.0.OR.JJJ.GE.YDIM)THEN
                  W=W+WEIGHT(II,JJ)
                ELSE
                  H=H+rMAT(ISP,III,JJJ)*WEIGHT(II,JJ)
                ENDIF
              ENDDO
            ENDDO
            cmW=MAX((1.-W),0.25)
            Z=H/cmW                   !Compensate for lost W, max 4x
            rMAT(IDEST,I,J)=Z
          ENDDO
        ENDDO
        cal(1,IDEST,1,1)=cal(1,ISP,1,1)
        cal(1,IDEST,1,2)=cal(1,ISP,1,2)
        cal(1,IDEST,1,3)=cal(1,ISP,1,3)
        cal(1,IDEST,2,1)=cal(1,ISP,2,1)
        cal(1,IDEST,2,2)=cal(1,ISP,2,2)
        cal(1,IDEST,2,3)=cal(1,ISP,2,3)

C Updating comment in the heading of spectrum file
        xcomm(1:3)='SM:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
        WRITE(6,*)' '

      ELSE

        DO I=0,MAXCH                  ! 1-dim spectra
          IT=(I/10)*10
          IF(IT.EQ.I)THEN
            CALL GAUSSR(I,0,AX,BX,0.,0.,DELX,DELY,WEIGHT)
          ENDIF
          H=0.
          W=0.
          DO II=-DELX,DELX
            III=I+II
            IF(III.LT.0.OR.III.GE.MAXCH+1)THEN
              W=W+WEIGHT(II,0)
            ELSE
              H=H+rSPEC(ISP,III)*WEIGHT(II,0)
            ENDIF
          ENDDO
          cmW=MAX((1.-W),0.50)
          Z=H/cmW                     !Compensate for lost W, max 2x
          rSPEC(IDEST,I)=Z
        ENDDO
        cal(2,IDEST,1,1)=cal(2,ISP,1,1)
        cal(2,IDEST,1,2)=cal(2,ISP,1,2)
        cal(2,IDEST,1,3)=cal(2,ISP,1,3)

C Updating comment in the heading of spectrum file
        xcomm(1:3)='SM:'
        fname(1,IDEST)=fname(1,ISP)
        comm(1,IDEST)=comm(1,ISP)
        CALL AddComment(xcomm,3)
      ENDIF
      END


      SUBROUTINE SHOW
      DIMENSION IAXIS(12)
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      IX=0
      IY=0

      IF(ITYPE.GT.1)THEN                           !Matrix
         WRITE(6,1)IDEST
   1    FORMAT(/'Show matrix no <',I1,'>:',$)
        CALL READI(5,IDEST)
        IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
        IF(Istatus.NE.0)RETURN

        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
        WRITE(6,2)IX
   2    FORMAT(/'around x-channel <',I5,'>:',$)
        CALL READI(5,IX)
        WRITE(6,3)IY
   3    FORMAT( 'and y-channel    <',I5,'>:',$)
        CALL READI(5,IY)
        IF(Istatus.NE.0)RETURN
        I1=IX-5
        I2=IX+6
        IF(I1.LT.0)THEN
          I1=0
          I2=11
        ENDIF
        IF(I2.GT.4095)THEN
          I2=4095
          I1=I2-11
        ENDIF
        J1=IY-10
        J2=IY+9
        IF(J1.LT.0)THEN
          J1=0
          J2=19
        ENDIF
        IF(J2.GT.511)THEN
          J2=511
          J1=511-19
        ENDIF
        II=0
        DO I=I1,I2
          II=II+1
          IAXIS(II)=I
        ENDDO
        WRITE(6,4)(IAXIS(II),II=1,12)
   4    FORMAT('   Y / X',12I6)
        WRITE(6,*)' '
        DO J=J1,J2
          WRITE(6,5)J,(rMAT(IDEST,I,J),I=I1,I2)
   5      FORMAT(2X,I3,3X,12F6.0)
        ENDDO

      ELSE
                                            !Singles spectrum
        WRITE(6,11)IDEST
  11    FORMAT(/'Show spectrum no <',I1,'>:',$)
        CALL READI(5,IDEST)
        IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
        IF(Istatus.NE.0)RETURN

        MAXCH=Idim(2,IDEST,1)-1
        WRITE(6,12)IX
  12    FORMAT(/'around channel <',I5,'>:',$)
        CALL READI(5,IX)
        IF(Istatus.NE.0)RETURN
        I1=IX-5
        I2=IX+6
        IF(I1.LT.0)THEN
          I1=0
          I2=11
        ENDIF
        IF(I2.GT.8191)THEN
          I2=8191
          I1=I2-11
        ENDIF  
        II=0
        DO I=I1,I2
          II=II+1
          IAXIS(II)=I
        ENDDO

        WRITE(6,*)' Channel    Counts'
        DO i=1,12
           ii=I1-1+i
           IF(ii.GT.8191)GO TO 15
           WRITE(6,14)IAXIS(i),rSPEC(IDEST,ii)
  14       FORMAT(I6,E14.6)
        ENDDO
  15    WRITE(6,*)' ' 

      ENDIF
      END


      SUBROUTINE TOUCH
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      DIMENSION xxA(2,2)
  
C The IIAs contain the areas of the 2 matrices and spectra
      IF(ITYPE.EQ.1)IIT=2      !Singles spectrum
      IF(ITYPE.NE.1)IIT=1      !2-dim. matrix

      IF(IIT.EQ.1)THEN
        XDIM=Idim(1,IDEST,1)
        YDIM=Idim(1,IDEST,2)
            
        xxA(IIT,IDEST)=0
        DO J=0,YDIM-1
          JT=(J/50)*50
          IF(JT.EQ.J)THEN
            write(6,FMT='(A1,$)')'.'
            call flush(6)
          ENDIF
          DO I=0,XDIM-1
            xxA(IIT,IDEST)=xxA(IIT,IDEST)+rMAT(IDEST,I,J)
          ENDDO
        ENDDO
        WRITE(6,*)' '
        WRITE(6,*)'Name:   ',fname(1,IDEST)
        WRITE(6,*)'Comment:',comm(1,IDEST)
        WRITE(6,6)IDEST,XDIM,YDIM,
     1  (cal(1,IDEST,1,i),i=1,3),(cal(1,IDEST,2,i),i=1,3)
6       FORMAT(' Matrix ',I1,' has dimension ',
     1  I4,'*',I3,' with calibration:',/,
     1 ' Along x-axis: a0=',E13.6,' a1=',E13.6,' and a2=',E13.6,/,
     1 ' Along y-axis: a0=',E13.6,' a1=',E13.6,' and a2=',E13.6)

        WRITE(6,7)XDIM-1,YDIM-1,xxA(IIT,IDEST)
7       FORMAT(' Counts in matrix (0:',I4,',0:',I3,') = ',E13.6)
        WRITE(6,*)' '
      ELSE
        MAXCH=Idim(2,IDEST,1)-1
        IMAXCH=MAXCH+1
        WRITE(6,*)'Name:   ',fname(2,IDEST)
        WRITE(6,*)'Comment:',comm(2,IDEST)
        WRITE(6,8)IDEST,IMAXCH,
     1  (cal(2,IDEST,1,i),i=1,3)
8       FORMAT(' Spectrum ',I1,' has dimension ',
     1 I5,' with calibration:',/,
     1  ' a0=',E13.6,' a1=',E13.6,' and a2=',E13.6)
        xxA(IIT,IDEST)=0
        DO I=0,MAXCH
          xxA(IIT,IDEST)=xxA(IIT,IDEST)+rSPEC(IDEST,I)
        ENDDO
        WRITE(6,9)MAXCH,xxA(IIT,IDEST)
9       FORMAT(' Counts in spectrum (0:',I4,')= ',E13.5)
        WRITE(6,*)' '
      ENDIF
      END


      SUBROUTINE TRANS2MATRIX
C Transforms a singles spectrum into a matrix of 1 or several equal rows
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH

      COMMON/LASTj/jnext,jstat           ! To remember next j-value

      WRITE(6,1)IDEST
 1    FORMAT('Destination matrix      <',I1,'>:',$)
      CALL READI(5,IDEST)
      ISP=IDEST
      WRITE(6,2)ISP
 2    FORMAT( 'Source singles spectrum <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(IDEST.LT.1.OR.IDEST.GT.2)Istatus=1
      IF(ISP  .LT.1.OR.ISP  .GT.2)Istatus=1
      IF(jnext.GT.511)jnext=511
      IF(jnext.LT.0)  jnext=0
      IF(Istatus.NE.0)RETURN

      WRITE(6,*)'The spectrum can be copied to 1 or several rows'
      WRITE(6,*)'Transform spectrum to rows (y-chs) between:' 

      IF(jstat.EQ.1)jlow =jnext    !The routine has been accessed before
      WRITE(6,3)jlow
 3    FORMAT(/' Lower row  <',I3,'>:',$)
      CALL READI(5,jlow)
      jhigh=jlow
      WRITE(6,4)jhigh
 4    FORMAT( ' Higher row <',I3,'>:',$)
      CALL READI(5,jhigh)
      IF(jhigh.GT.511)jhigh=511
      IF(Istatus.NE.0)RETURN

      XDIM=Idim(2,ISP,1)
      IF(XDIM.GT.4096)XDIM=4096
      YDIM=jhigh+1

      DO j=jlow,jhigh
        DO i=0,XDIM-1
          rMAT(IDEST,i,j)=rSPEC(ISP,i)
        ENDDO
      ENDDO

      ITYPE=3
      CALL SetMarker(1,1,1)

      cal(1,IDEST,1,1)=cal(2,ISP,1,1)
      cal(1,IDEST,1,2)=cal(2,ISP,1,2)
      cal(1,IDEST,1,3)=cal(2,ISP,1,3)
      cal(1,IDEST,2,1)=0
      cal(1,IDEST,2,2)=1.
      cal(1,IDEST,2,3)=0.
      jnext=jhigh+1
      jstat=1

C Updating comment in the heading of spectrum file
      xcomm(1:3)='TR:'
      CALL AddComment(xcomm,3)
      fname(2,IDEST)='TR'//fname(1,ISP)(1:6)
      RETURN
      END


      SUBROUTINE UNIXCMD
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER string*40
      INTEGER status, system
      string='ls'
      WRITE(6,1)string(1:2)
 1    FORMAT(/'Type your UNIX command <',A,'>:',$)
      CALL READA(5,string)
      IF(Istatus.NE.0)RETURN

      status=SYSTEM(string)
      IF(status.NE.0)WRITE(6,*)'Error, command not understood'
      RETURN
 99   WRITE(6,*)'Error, command not understood'
      END
      

      FUNCTION CORR(EG,THETA)
C Correction to number of counts due to DeltaTheta
      REAL EG,THETA,A,B,C
      A = EG*(EG/511.)*SIN(THETA)
      B = 1. + (EG/511.)*(1. - COS(THETA))
      C = A/(B**2.)
      CORR = C
      END

      FUNCTION FERMI(AA,XJ,EX,EGAP)
C CALLED FROM FUNC1, FUNC4, FUNC3 AND FUNC5. FINDS THE LEVEL DENSITY 
C AS FUNCTION OF
C INTRINSIC EXC. ENERGY=EX-EGAP-300. WE ASSUME YRAST TO BE 300 keV.
C CALCULATE DOWN TO ENERGY U=4/a ,WHICH IS U = ca.200 keV.
      FERMI=0
      U=EX-EGAP-300.
      UMIN=4./AA
      IF(UMIN.LT.200)UMIN=200.

      IF(U.LE.0)RETURN
      IF(U.GT.UMIN.AND.U.GT.0)THEN
        FERMI=((2.*XJ+1.)*SQRT(AA)*EXP(2.*SQRT(AA*U)))/(U*U)
        RETURN
      ENDIF
      IF(U.LE.UMIN.AND.U.GT.0)THEN
       FERMI=((2.*XJ+1.)*SQRT(AA)*EXP(2.*SQRT(AA*UMIN)))/(UMIN*UMIN)
        RETURN
      ENDIF
      RETURN
      END


      FUNCTION FUNC1(EG,A)
C CALCULATES THE THE FIRST GENERATION GAMMA-SPECTRUM AS A(1)*EXPN*RHO
C WE AVERAGE OVER 6 EXCITATION ENERGIES BETWEEN EXL TO EXH, DUE TO DETECTOR
C RESOLUTION. ENERGY UNITS IN MEV
      REAL A(2),N,MASS
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      COMMON/CALxy/AX0,AX1,AY0,AY1
      FUNC1=0
      IX=((EG-AX0)/AX1+0.5)
      IF(IX.LT.0)RETURN
      AA=A(2)
      DEL=EXH-EXL
      DELST=DEL/5.
      DO I=1,6
        EXX=EXL+FLOAT(I-1)*DELST-EG
         RHO=FERMI(AA,XJ,EXX,EGAP)
        FUNC1=A(1)*EXPN(IX)*RHO+FUNC1
      ENDDO
      FUNC1=FUNC1/6.
      RETURN         
      END


      FUNCTION FUNC2(ALOGEG,A)
      DIMENSION A(2)
      FUNC2=A(1)+A(2)*ALOGEG
      RETURN
      END


      FUNCTION FUNC3(EXF,A)
      REAL N,A(2),MASS
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      FUNC3=0
      AA=A(2)
      VENT=FWXG
      FWXG=0
      EXX=EXF-FWXG/2.
      DELST=FWXG/5.
      FWXG=VENT
      DO I=1,6
        EXX=EXX+FLOAT(I-1)*DELST
        RHO=FERMI(AA,XJ,EXX,EGAP)
        FUNC3=A(1)*RHO+FUNC3
      ENDDO
      FUNC3=FUNC3/6.
      FUNC3=ALOG(FUNC3)
      RETURN         
      END


      FUNCTION FUNC4(XX,A)
C CALCULATES THE THE FIRST GENERATION GAMMA-SPECTRUM AS A(1)*EXPN*RHO
C WE AVERAGE OVER 6 EXCITATION ENERGIES BETWEEN EXL TO EXH, DUE TO DETECTOR
C RESOLUTION. ENERGYUNITS ARE IN MEV. PARAMETER XX IS ACTUAL NUMBER OF
C DATAPOINT

      CHARACTER APP*4
      INTEGER XDIM,YDIM
      REAL A(2),P(2),N,MASS
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      COMMON/CALxy/AX0,AX1,AY0,AY1
      COMMON/CTOTFIT/XEN(50000),YEN(50000),NPTS,EXV,FX,EXMIN,ISP
      EXTERNAL FUNC1,FERMI
      ISP=1
      IF(IDEST.EQ.1)ISP=2
      FUNC4=0.
      III=XX+0.5
      EG=XEN(III)
      EX=YEN(III)
      EXL=EX-FWXG/2.
      EXH=EX+FWXG/2.
      IF(EXL.LT.0)EXL=0.
      IEG=((EG-AX0)/AX1+0.5)
      JEX=((EX-AY0)/AY1+0.5)
      IF(IEG.LT.0.OR.JEX.LT.0)RETURN

      AA=A(2)
      DEL=EXH-EXL
      DELST=DEL/5.
      DO I=1,6
        EXX=EXL+FLOAT(I-1)*DELST-EG
        RHO=FERMI(AA,XJ,EXX,EGAP)
        FUNC4=FUNC4+A(1)*EXPN(IEG)*RHO
      ENDDO
         
C CALCULATING F(Ex)
      IF(EX.NE.EXV.OR.FX.EQ.0)THEN
        IMAX  =((EX-EXMIN-AX0)/AX1+0.5)
        IUPPER=((EXH-AX0)/AX1+0.5)
        IF(IMAX.GT.511)IMAX=511
        IF(IUPPER.GT.511)IUPPER=511
        FX=0.
        GAS=0.
        GSB=0.
        P(1)=1.
        P(2)=A(2)
        DO I=0,IMAX
          EE=AX1*I+AX0
          IF(EE.GT.500.)FX=FX+FUNC1(EE,P)
          IF(EE.GT.500.)GAS=GAS+rMAT(ISP,I,JEX)
        ENDDO
        DO I=IMAX+1,IUPPER
          IF(EE.GT.500.)GSB=GSB+rMAT(ISP,I,JEX)
        ENDDO
C CORRECT FOR DECAY TO STATES BELOW FERMI-GAS. (TAKEN FROM EXP. SPECTRA)
        FRAC=0.
        IF(GAS.GT.0.)FRAC=GSB/GAS
        FRAC=1.+FRAC
        FX=FX*FRAC
C        IF(FX.GT.0)WRITE(6,24)EX,FRAC,FX
C 24    FORMAT('Exc.=',F5.0,' Corr. fac.=',
C     +  F5.2,' F(Ex)=',E12.5)
      EXV=EX
      ENDIF
      IF(FX.GT.0)FUNC4=FUNC4/(6.*FX)
      RETURN         
      END


      FUNCTION FUNC5(A)
C CALCULATES A(1)*RHO
C WE AVERAGE OVER 6 EXCITATION ENERGIES BETWEEN EXL TO EXH, DUE TO DETECTOR
C RESOLUTION. ENERGY UNITS ARE IN MEV
      REAL A(2),N,MASS
      COMMON/CNUTE/EX,EXL,EXH,XJ,EGAP,MASS,EXPN(0:4095),N(0:4095),FWXG
      FUNC5=0
      AA=A(2)
      DEL=EXH-EXL
      DELST=DEL/5.
      DO I=1,6
        EXX=EXL+FLOAT(I-1)*DELST
        RHO=FERMI(AA,XJ,EXX,EGAP)
        FUNC5=A(1)*RHO+FUNC5
      ENDDO
      FUNC5=FUNC5/6.
      RETURN         
      END


C=======================================================================

      SUBROUTINE LINEUP(NUP,NR)

C          NUP: no. of lines to go up
C          NR : no. of columns to move right

      INTEGER       NUP, NR

      CHARACTER*4   UP
      CHARACTER*5   RIGHT


      IF (NUP.GT.0) THEN
         JUP = NUP
         IF (JUP.GT.9) JUP = 9
         WRITE(UP,10) CHAR(27),JUP
10       FORMAT(A1,'[',I1.1,'A')
C                         esc[0A - move text cursor up....
         CALL QIO_PUT_TEXT(UP,4)
      ENDIF

      IF (NR.GT.0) THEN
         JR = NR
         IF (JR.GT.99) JR = 99
         WRITE(RIGHT,20) CHAR(27),JR
20       FORMAT(A1,'[',I2.2,'C')
C                         esc[00C - move text cursor right....
         CALL QIO_PUT_TEXT(RIGHT,5)
      ENDIF

      RETURN
      END

C=======================================================================

      SUBROUTINE MATINV(ARRAY,NORDER,IDIM)

      REAL*8  ARRAY(IDIM,IDIM), AMAX, SAVE
      INTEGER IK(100), JK(100)

      DO K = 1, NORDER

c        find largest element array(i,j) in rest of matrix....

         AMAX = 0.0D0
21       DO I = K, NORDER
            DO J = K, NORDER
               IF (DABS(AMAX)-DABS(ARRAY(I,J)).LE.0.0D0) THEN
                  AMAX = ARRAY(I,J)
                  IK(K) = I
                  JK(K) = J
               ENDIF
            ENDDO
         ENDDO
         IF (AMAX.EQ.0.0) RETURN

C        interchange rows and columns to put amax in array(k,k)....

         I = IK(K)
         IF (I.LT.K) GO TO 21
         IF (I.GT.K) THEN
            DO J = 1, NORDER
               SAVE = ARRAY(K,J)
               ARRAY(K,J) = ARRAY(I,J)
               ARRAY(I,J) = -SAVE
            ENDDO
         ENDIF

         J = JK(K)
         IF (J.LT.K) GO TO 21
         IF (J.GT.K) THEN
            DO I = 1, NORDER
               SAVE = ARRAY(I,K)
               ARRAY(I,K) = ARRAY(I,J)
               ARRAY(I,J) = -SAVE
            ENDDO
         ENDIF

C        accumulate elements of inverse matrix....

         DO I = 1, NORDER
            IF (I.NE.K) ARRAY(I,K) = -ARRAY(I,K)/AMAX
         ENDDO
         DO I = 1, NORDER
            DO J = 1, NORDER
               IF (I.NE.K .AND. J.NE.K)
     +               ARRAY(I,J) = ARRAY(I,J) + ARRAY(I,K)*ARRAY(K,J)
            ENDDO
         ENDDO
         DO J = 1, NORDER
            IF (J.NE.K) ARRAY(K,J) = ARRAY(K,J)/AMAX
         ENDDO
         ARRAY(K,K)=1./AMAX
      ENDDO

C        restore ordering of matrix....

      DO L = 1, NORDER
         K = NORDER - L + 1
         J = IK(K)
         IF (J.GT.K) THEN
            DO I = 1, NORDER
               SAVE = ARRAY(I,K)
               ARRAY(I,K) = -ARRAY(I,J)
               ARRAY(I,J) = SAVE
            ENDDO
         ENDIF

         I = JK(K)
         IF (I.GT.K) THEN
            DO J = 1, NORDER
               SAVE = ARRAY(K,J)
               ARRAY(K,J) = -ARRAY(I,J)
               ARRAY(I,J) = SAVE
            ENDDO
         ENDIF
      ENDDO

      RETURN
      END
      SUBROUTINE NORWAY
C Routine to display norwegian flag
C M.Guttormsen november 1993
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colorc
      REAL Limit(0:19)
      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM

      
C Setting up colors for 3-dim landscape
      ictype=1
      CALL INITG(NX,NY)    !Finding window size (nx,ny) 
      CALL ColComp(ictype) !Puts default color-vaues to Color(0:19)

      NX0=NX
      NY0=NY
      
      I1=5
      n=9
      LOY=0
      LOX=0
    
      NY=NY/3             !Number of y-pixels pr. spectrum
      NX=NX/3
      NY=(16./22.)*NX
      LOY=NY              !Pixelstart in y-direction
      LOX=NX              !Pixelstart in x-direction
      
      CALL LIMG(NX,LOX,NY,LOY) !Informing screen window

      MX1=LOX
      MX2=MX1+NX*(6./22.)
      MX3=MX1+NX*(7./22.)
      MX4=MX1+NX*(9./22.)
      MX5=MX1+NX*(10./22.)
      MX6=MX1+NX
      
      MY1=LOY
      MY2=MY1+NY*(6./16.)
      MY3=MY1+NY*(7./16.)
      MY4=MY1+NY*(9./16.)
      MY5=MY1+NY*(10./16.)
      MY6=MY1+NY
     
      CALL SETCOLOR(Colorc(12))
      DO j=MY1,MY6               
        CALL KTRAS(MX1,j,0)     
        CALL KTRAS(MX6,j,1)
      ENDDO

      CALL SETCOLOR(Colorc(18))
      DO j=MY2,MY5               
        CALL KTRAS(MX1,j,0)      
        CALL KTRAS(MX6,j,1)
      ENDDO
      DO i=MX2,MX5               
        CALL KTRAS(i,MY1,0)      
        CALL KTRAS(i,MY6,1)
      ENDDO

      CALL SETCOLOR(Colorc(0))
      DO j=MY3,MY4               
        CALL KTRAS(MX1,j,0)      
        CALL KTRAS(MX6,j,1)
      ENDDO
      DO i=MX3,MX4               
        CALL KTRAS(i,MY1,0)      
        CALL KTRAS(i,MY6,1)
      ENDDO

      CALL FINIG

      DO i=1,10000000                    !dummy and artificial wait
        x=SIN(.022)
        x=SIN(.022)
        x=SIN(.022)
      ENDDO 

c      isystem=sleep(1)
      CALL SLEEP(1)

C Fadeing out
      CALL SETCOLOR(Colorc(18))     !White dots all over
c      DO i=0,NX*NY
c        ix=LOX+rand(0)*NX+0.5
c        iy=LOY+rand(0)*NY+0.5
c        CALL KTRAS(ix,iy,2)
c      ENDDO
      DO j=MY1,MY6                !Total delete
        CALL KTRAS(MX1,j,0)     
        CALL KTRAS(MX6,j,1)
      ENDDO

C Tests colors
c      mxl=mx1-10
c      call ktras(mx1,my1,0)
c      do ic=1,20
c        mxl=mxl+10
c        mxh=mxl+10
c        call setcolor(colormap(ic))
c        DO j=MY1,MY6              
c          CALL KTRAS(MXl,j,0)     
c          CALL KTRAS(MXh,j,1)
c        ENDDO
c      enddo

      CALL SETCOLOR(19)
      
C Going back to full window
      CALL LIMG(NX0,0,NY0,0) !Informing screen window
      CALL INITG(NX,NY)
C Gets window parameters for use for F77 routines through
C COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      CALL GETGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)

      END

      SUBROUTINE OUTLAY(iOL)
C Routine to display part of a matrix as a number of singles spectra
      LOGICAL DISP
      INTEGER XDIM,YDIM
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/OL/iOLnew,iRC,m1,m2
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      REAL dex(14)
    
      CHARACTER*28 HEADING
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,oldname*8
      REAL Spec(4096)
      CHARACTER ANS*1,TEX1*3,TEX2*4,TEX*9

      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3

      INTEGER COLORMAP(20),Colorc(0:19)
      COMMON /COLORMAP/ COLORMAP,Limit,Colocr
      REAL Limit(0:19)

      COMMON/SAVEOUTLAY/OLhi,OLlo,OLlc,OLhc
      REAL OLhi(64),OLlo(64),OLlc(64),OLhc(64)

      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM

      iblack=20

      iOLnew=iOL
      IF(iOL.LT.0.OR.iOL.GT.3)Istatus=1
      IF(Istatus.NE.0)RETURN

      WRITE(6,1)IDEST
 1    FORMAT(/'Display multiple spectra of matrix <',I2,'>:',$)
      CALL READI(5,IDEST)
      IF(Istatus.NE.0)RETURN
      ITYPE=3
     
      IF(fname(1,IDEST).NE.oldname)THEN
        m1=0
        m2=63
      ENDIF
      oldname=fname(1,IDEST)

      ANS='R'
      WRITE(6,3)ANS
 3    FORMAT(/'Show rows (R) or coloumns (C) as spectra <',A1,'>:',$)
      CALL READA1(5,ANS)
      IF(Istatus.NE.0)RETURN

      IISTAT=0
      IF(ANS.EQ.'R'.OR.ANS.EQ.'r')THEN
        WRITE(6,*)'Choose spectra (or y-channels, max=64)'
        m1=MAX0(0,m1)
        WRITE(6,4)m1
 4      FORMAT(/'Lower channel on y-axis  <',I5,'>:',$)
        CALL READI(5,m1)
        IF(m2.GE.m1.AND.m2.LE.m1+63)THEN
          m2=m2
        ELSE
          m2=m1+63
        ENDIF
        IF(m2.GT.YDIM-1)m2=YDIM-1
        WRITE(6,5)m2
 5      FORMAT( 'Higher channel on y-axis <',I5,'>:',$)
        CALL READI(5,m2)
        IF(m1.LT.  0.OR.m2.LT.  0)Istatus=2
        IF(m1.GT.511.OR.m2.GT.511)Istatus=2
        I2=ABS(m1-m2)+1            ! Number of spectra
        maxdim=XDIM                ! Max dimension of spectra
        TEX1='Y: '
        IF(I2.GT.64)Istatus=2
        IF(Istatus.NE.0)RETURN
        IISTAT=1
      ENDIF

      IF(ANS.EQ.'C'.OR.ANS.EQ.'c')THEN
        WRITE(6,*)'Choose spectra (or x-channels, max=64)'
        m1=MAX0(0,m1)
        WRITE(6,6)m1
 6      FORMAT(/'Lower channel on x-axis  <',I5,'>:',$)
        CALL READI(5,m1)
        IF(m2.GE.m1.AND.m2.LE.m1+63)THEN
          m2=m2
        ELSE
          m2=m1+63
        ENDIF
        IF(m2.GT.XDIM-1)m2=XDIM-1
        WRITE(6,7)m2
 7      FORMAT( 'Higher channel on x-axis <',I5,'>:',$)
        CALL READI(5,m2)
        IF(m1.LT.   0.OR.m2.LT.   0)Istatus=2
        IF(m1.GT.4095.OR.m2.GT.4095)Istatus=2
        I2=ABS(m1-m2)+1           ! Number of spectra
        maxdim=YDIM               ! Max dimension of spectra
        TEX1='X: '
        IF(I2.GT.64)Istatus=2
        IF(Istatus.NE.0)RETURN
        IISTAT=1
      ENDIF

C Want to display I2 spectra 
C Parting the screen into inx*iny parts
      inx=1
      iny=1      
      IF(I2.GT. 1.AND.I2.LE. 2)THEN !2*1 spectra
        inx=2
        iny=1
      ENDIF
      IF(I2.GT. 2.AND.I2.LE. 4)THEN !2*2 spectra
        inx=2
        iny=2
      ENDIF
      IF(I2.GT. 4.AND.I2.LE. 6)THEN !3*2 spectra
        inx=3
        iny=2
      ENDIF
      IF(I2.GT. 6.AND.I2.LE. 9)THEN !3*3 spectra
        inx=3
        iny=3
      ENDIF
      IF(I2.GT. 9.AND.I2.LE.12)THEN !4*3 spectra
        inx=4
        iny=3
      ENDIF
      IF(I2.GT.12.AND.I2.LE.16)THEN !4*4 spectra
        inx=4
        iny=4
      ENDIF
      IF(I2.GT.16.AND.I2.LE.20)THEN !5*4 spectra
        inx=5
        iny=4
      ENDIF
      IF(I2.GT.20.AND.I2.LE.25)THEN !5*5 spectra
        inx=5
        iny=5
      ENDIF
      IF(I2.GT.25.AND.I2.LE.30)THEN !6*5 spectra
        inx=6
        iny=5
      ENDIF
      IF(I2.GT.30.AND.I2.LE.36)THEN !6*6 spectra
        inx=6
        iny=6
      ENDIF           
      IF(I2.GT.36.AND.I2.LE.42)THEN !7*6 spectra
        inx=7
        iny=6
      ENDIF
      IF(I2.GT.42.AND.I2.LE.49)THEN !7*7 spectra
        inx=7
        iny=7
      ENDIF
      IF(I2.GT.49.AND.I2.LE.56)THEN !8*7 spectra
        inx=8
        iny=7
      ENDIF
      IF(I2.GT.56.AND.I2.LE.64)THEN !8*8 spectra
        inx=8
        iny=8
      ENDIF

      IF(IISTAT.EQ.0)Istatus=2
      IF(Istatus.NE.0)RETURN

      CALL INITG(NX0,NY0) 
      NY=NY0/iny           !Number of y-pixels pr. spectrum
      NX=NX0/inx           !Number of x-pixels pr. spectrum

C Drawing grid and frame for inx*iny spectra
      CALL SETCOLOR(iblack)
      DO i=0,inx
        CALL KTRAS(i*NX,20    ,0)
        CALL KTRAS(i*NX,NY0+18,1)
      ENDDO
      DO i=0,iny-1
        CALL KTRAS(0  ,i*NY+20,0)
        CALL KTRAS(NX0,i*NY+20,1)
      ENDDO
                
      IF(ANS.EQ.'R'.OR.ANS.EQ.'r')THEN
        IF(iOL.EQ.1)THEN           !Full scale for display
          CALL SetMarker(1,0,1)
        ENDIF    
        IF(iOL.EQ.2)THEN           !Autoscaling
          CALL SetMarker(2,0,1)                                      
        ENDIF
        OLlow =LDX            
        OLhigh=HDX                 
      ENDIF
      IF(ANS.EQ.'C'.OR.ANS.EQ.'c')THEN
        IF(iOL.EQ.1)THEN           !Full scale for display
          CALL SetMarker(0,1,1)
        ENDIF    
        IF(iOL.EQ.2)THEN           !Autoscaling
          CALL SetMarker(0,2,1)                                      
        ENDIF
        OLlow =LDY               
        OLhigh=HDY
      ENDIF

      Idistype=2                   !telling CR that it is an OL spectrum

C Starting the loop of drawing I2 spectra
      IF(m2.LT.m1)THEN     !Assures right order: m1<m2
        mwait=m1
        m1=m2
        m2=mwait 
      ENDIF
      I1=0

C Spectrum loop starts
      DO m=m1,m2
        I1=I1+1

        IF(iOL.EQ.0)THEN
          OLlow  =min(OLlc(I1),ABS(maxdim-11))    !Using old values
          OLhigh =max(OLhc(I1),10)
          OLlocnt=min(0.,OLlo(I1))
          OLhicnt=max(0.000001,OLhi(I1))
        ENDIF
        IF(ANS.EQ.'R'.OR.ANS.EQ.'r')THEN
          DO i=0,maxdim-1              
            Spec(i+1)=rMAT(IDEST,i,m)
          ENDDO
        ENDIF
        IF(ANS.EQ.'C'.OR.ANS.EQ.'c')THEN
          DO i=0,maxdim-1              
            Spec(i+1)=rMAT(IDEST,m,i)
          ENDDO
        ENDIF
        IF(iOL.EQ.2)THEN
          DO i=maxdim,10,-1
            IF(Spec(i).NE.0)GO TO 99
          ENDDO
 99       a=0
          b=i
          b=b*1.01
          CALL GRAX(a,b,dex,nv,1)
          OLlow=a
          OLhigh=dex(nv)*(nv+1)/nv
        ENDIF

        IF(OLlow.lt.0)OLlow=0
        IF(OLhigh.GT.maxdim-1)OLhigh=maxdim-1
        IF(OLlow. GT.OLhigh-1)GO TO 999

        NCC =(OLhigh-OLlow)/NX+1
        NCHS=OLhigh-OLlow+1

        IF(NCC.EQ.1)THEN
          IF(iOL.GE.1)THEN  !Autoscale of z-axis with pixels > channels
            OLlocnt=0
            OLhicnt=0.000001
            ii1=MAX0(OLlow+2,INT(OLlow+0.01*NCHS))
            ii2=MIN0(OLhigh,INT(OLhigh-0.01*NCHS))
            IF(ii2-ii1.lt.10)THEN
              ii1=OLlow+1
              ii2=OLhigh+1
            ENDIF
            DO i=ii1,ii2
              IF(OLhicnt.LT.Spec(i))OLhicnt=Spec(i)
              IF(OLlocnt.GT.Spec(i))OLlocnt=Spec(i)
            ENDDO
c            OLlocnt=0      !By brutal force
          ENDIF
        ELSE
          IF(iOL.GE.1)THEN  !Autoscale of z-axis with pixels < channels
            OLlocnt=0
            OLhicnt=0.000001
            ii1=MAX0(OLlow+2,INT(OLlow+0.01*NCHS))
            ii2=MIN0(OLhigh,INT(OLhigh-0.01*NCHS))
            IF(ii2-ii1.lt.10)THEN
              ii1=OLlow+1
              ii2=OLhigh+1
            ENDIF
            DO ICH=OLlow,OLlow+(NCHS/NCC-1)*NCC,NCC
              Yc=0.
              DO I=1,NCC
                Yc=Yc+Spec(ICH+I-1)
              ENDDO
              Yc=Yc/(FLOAT(NCC))
              IF((OLhicnt.LT.Yc).AND.(ICH.GT.ii1).AND.(ICH.LT.ii2))OLhicnt=Yc
              IF((OLlocnt.GT.Yc).AND.(ICH.GT.ii1).AND.(ICH.LT.ii2))OLlocnt=Yc
            ENDDO
c            OLlocnt=0      !By brutal force
          ENDIF
        ENDIF

        OLhi(I1)=OLhicnt            !Storing for next display
        OLlo(I1)=OLlocnt
        OLlc(I1)=OLlow
        OLhc(I1)=OLhigh

C Finding (x,y) pixel origo for spectrum I1
        LOY=NY*((I1-1)/inx)           !Pixelstart in y-direction
        II1=I1
        DO WHILE (II1.GT.inx)
          II1=II1-inx
        ENDDO
        LOX=NX*(II1-1)                !Pixelstart in x-direction
        CALL LIMG(NX,LOX,NY,LOY)      !Informing screen window

C Gets window parameters for use for F77 routines through
C COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      CALL GETGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)  

C Making axis
        X0=OLlow
        DX=NCHS
        Y0=OLlocnt
        DY0=OLhicnt-OLlocnt
        DY=1.05*DY0
        CALL SETCOLOR(iblack)
        CALL TRAX(DX,X0,DY,Y0,IYAXIS)

        ICOL = COLORMAP(1)         !blue as default

        CALL SETCOLOR(ICOL)
        X=OLlow
        IF(NCC.EQ.1)THEN
          s=Spec(OLlow+1)
          CALL PSPOT(X,s)
          DO i=OLlow+1,OLhigh+1
             s=Spec(i)
             CALL VECT(X,s)
             X=X+1.0
             CALL VECT(X,s)
          ENDDO 
        ELSE
          Y=0.
          DO i=1,NCC
            Y=Y+Spec(OLlow+i)
          ENDDO
          FNCC=FLOAT(NCC)
          Y=Y/FNCC
          CALL PSPOT(X,Y)
          DO ICH=OLlow,OLlow+(NCHS/NCC-1)*NCC,NCC
            Y=0.
            DO i=1,NCC
              Y=Y+Spec(ICH+i)
            ENDDO
            Y=Y/FNCC
            CALL VECT(X,Y)
            X=X+FNCC
            CALL VECT(X,Y)
          ENDDO
        ENDIF

        CALL SETCOLOR(iblack)
        CALL KTRAS(LOX+NX-10,LOY+NY-10,0)
        WRITE(TEX2,20)m
   20   FORMAT(I2)  
        IF(itext.EQ.1)CALL PUTG(TEX2,2,8)
      ENDDO
      CALL DATETIME(HEADING)
C Finding date text to write   
      n1=0
      n2=0   
      n3=0
      ic=0
      DO i=1,17
         IF(HEADING(i:i).EQ.'-'.OR.HEADING(i:i).EQ.' '.OR.HEADING(i:i).EQ.':')THEN
            ic=ic+1
            IF(ic.EQ.2)n1=i
            IF(ic.EQ.3)n2=i
            IF(ic.EQ.4)n3=i
         ENDIF
      ENDDO
      numb=n1+(n3-n2)+1    
      IF(itext.EQ.1)THEN
        CALL MSPOT(NX0-60,LOY+NY+5)
        CALL PUTG(fname(1,IDEST)(1:8),8,1)
        CALL MSPOT(NX0-60,LOY+NY-6)
        CALL PUTG(HEADING(1:n1-1)//HEADING(n2+1:n3)//HEADING(n3+1:n3+3),numb,1)
      ENDIF
      CALL FINIG
      DISP=.TRUE.

C Putting on unit on axis
      CALL INITG(NX,NY)
C Units on x-axis
      CALL MSPOT(NX-8,1)
      CALL PUTG(UNITx,3,8)

C Writing information
      IF(ANS.EQ.'R'.OR.ANS.EQ.'r')THEN
        WRITE(6,*)'Use DX and DZ to display new channels and counts'
      ENDIF
      IF(ANS.EQ.'C'.OR.ANS.EQ.'c')THEN
        WRITE(6,*)'Use DY and DZ to display new channels and counts'
      ENDIF
      WRITE(6,*)' '

      RETURN

999   CALL FINIG
      RETURN
      END

C=======================================================================

      SUBROUTINE PARA2NUM(ANS,PARAM,ERR_FLG)

C     change an alphanumeric ANSwer into PARAM (parameter number)....
C     ERR_FLG = true for unrecognized parameter....
C     called by FIXORFREE.... 

      CHARACTER*80 ANS,TMP_ANS
      INTEGER      PARAM
      LOGICAL      ERR_FLG

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      COMMON /LUS/ IR,IW,IP,IG

C        local variables....
      CHARACTER*3    PARC(51)
     +           /' A ',' B ',' C ',' R ','BTA','STP','P1 ','W1 ','H1 ',
     +            'P2 ','W2 ','H2 ','P3 ','W3 ','H3 ','P4 ','W4 ','H4 ',
     +            'P5 ','W5 ','H5 ','P6 ','W6 ','H6 ','P7 ','W7 ','H7 ',
     +            'P8 ','W8 ','H8 ','P9 ','W9 ','H9 ','PA ','WA ','HA ',
     +            'PB ','WB ','HB ','PC ','WC ','HC ','PD ','WD ','HD ',
     +            'PE ','WE ','HE ','PF ','WF ','HF '/


      TMP_ANS = ANS
C        remove leading spaces....
140   IF (TMP_ANS(1:1).EQ.' ') THEN
         TMP_ANS(1:39) = TMP_ANS(2:40)
         TMP_ANS(40:40) = ' '
         GO TO 140
      ENDIF

C         convert lower case to upper case characters....
      DO 150 I = 1,4
         IC = ICHAR(TMP_ANS(I:I))
         IF (IC.GE.97.AND.IC.LE.122) TMP_ANS(I:I) = CHAR(IC-32)
150   CONTINUE

      ERR_FLG = .FALSE.
      DO 160 PARAM = 1, 4
C           put a space in front of possible one letter answer....
         IF (' '//TMP_ANS(1:2).EQ.PARC(PARAM)) RETURN
160   CONTINUE

      DO 170 PARAM = 5, NPARS
         IF (TMP_ANS(1:3).EQ.PARC(PARAM)) RETURN
170   CONTINUE

      IF (TMP_ANS(1:4).EQ.'BETA') THEN
         PARAM = 5
      ELSEIF (TMP_ANS(1:4).EQ.'STEP') THEN
         PARAM = 6
      ELSEIF (TMP_ANS(1:3).EQ.'RP ') THEN
         PARAM = 101
      ELSEIF (TMP_ANS(1:3).EQ.'RW ') THEN
         PARAM = 102
      ELSE
C           no match so ....
         ERR_FLG = .TRUE.
      ENDIF

      RETURN
      END
      SUBROUTINE PARSET(MODE)

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      REAL          AREAS(15),DAREAS(15),CENTS(15)
      COMMON /AREA/ AREAS,DAREAS,CENTS

      REAL           FINEST(5), SWPARS(3)
      INTEGER        INFIX(3), INFIXRW, INFIXW
      COMMON /INEST/ FINEST,INFIX,SWPARS,INFIXRW,INFIXW

      LOGICAL RESETP,RESETW

      ILO=MCH(1)+1
      IHI=MCH(2)+1
      X0=(IHI+ILO)/2
      DO 5 I=1,NPARS
    5    ERRS(I)=0.0
      X=0.0
      DO 20 I=1,NPKS
20       X=X+PPOS(I)
      X=X/FLOAT(NPKS)
      IF (IFIXED(1).EQ.1) PARS(1)=(rSPEC(IDEST,IHI-1)+rSPEC(IDEST,ILO-1))/2.0
      IF (IFIXED(2).EQ.1) PARS(2)=(rSPEC(IDEST,IHI-1)-rSPEC(IDEST,ILO-1))/FLOAT(IHI-ILO)
      IF (IFIXED(3).EQ.1) PARS(3)=0.0
      IF (IFIXED(4).EQ.1) PARS(4)=FINEST(1)+FINEST(2)*X
      IF (IFIXED(5).EQ.1) PARS(5)=FINEST(3)+FINEST(4)*X
      IF (PARS(5).EQ.0.0) PARS(5)=0.5*SQRT
     +                       ( SWPARS(1)
     +                       + SWPARS(2)*X
     +                       + SWPARS(3)*X*X )
      IF (IFIXED(6).EQ.1) PARS(6)=FINEST(5)
      IF (MODE.LT.0) THEN

C            come here only during set-up....
         RESETP=.TRUE.
         RESETW=.TRUE.
         NFP=3-INFIX(1)-INFIX(2)-INFIX(3)
         IFIXED(4)=INFIX(1)
         IFIXED(5)=INFIX(2)
         IFIXED(6)=INFIX(3)
         IF (IFIXED(4).EQ.0.AND.PARS(4).EQ.0.0) THEN
            NFP=NFP+IFIXED(5)
            IFIXED(5)=0
         ENDIF
         IRELW=INFIXRW
         IF (INFIXW.EQ.0) THEN
            DO I=1,NPKS
              IFIXED(3*I+5)=0         !magne
            ENDDO
            NFP=NFP+NPKS
         ENDIF
      ELSE
         IF (IRELPOS.EQ.0) THEN
            RESETP=.FALSE.
            CALL ASKYN(
     +       54HRelative positions fixed - reset peak positions? (Y/N)
     +      ,54,*120)
         ENDIF
         RESETP=.TRUE.
120      IF (IRELW.EQ.0) THEN
            RESETW=.FALSE.
            CALL ASKYN(
     +         43HRelative widths fixed - reset widths? (Y/N),43,*140)
         ENDIF
         RESETW=.TRUE.
      ENDIF
140   DO 10 I=1,NPKS
         AREAS(I)=0.0
         DAREAS(I)=0.0
         J=3*I+6
         IF (RESETP.AND.IFIXED(J-2).EQ.1) PARS(J-2)=PPOS(I)
         IF (MODE.LT.0.OR.(RESETW.AND.IFIXED(J-1).EQ.1))
     +              PARS(J-1)=SQRT( SWPARS(1)
     +                            + SWPARS(2)*PPOS(I)
     +                            + SWPARS(3)*PPOS(I)*PPOS(I) )
         IF (IFIXED(J).EQ.0) GO TO 10
         X=PPOS(I)-X0+1.0
         Y=PARS(1)+PARS(2)*X
         IPP=PPOS(I)+1.5
         PARS(J)=rSPEC(IDEST,IPP-1)-Y
         CENTS(I)=PARS(J-2)
10    CONTINUE

      RETURN
      END
      SUBROUTINE PEAKFIND
C Routine that searches for peaks in matr./spc.  
      COMMON/PKFIND/xSPEC(8192),NOCH                     
      COMMON/PEAK/NoPeak,Peaks(200,5)

      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM           
      INTEGER XDIM,YDIM,dim                                              
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      CHARACTER APP*4
      CHARACTER*7 MCHAR
      CHARACTER ans*1                                                                                
      CHARACTER*20 DATTIM

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      DIMENSION XCHA(400),YCHA(400),WG(400),C(5)
      REAL*8 EF(5,5)

      Idev =22 
      disc =0.5
      disct=disc
      Kmax =2
      fw0t =6.
      fw1t =0.
      ans  ='s'

      l1=0                 !Default is singles spectrum
      l2=0
      a0=cal(2,IDEST,1,1)
      a1=cal(2,IDEST,1,2)
      a2=cal(2,IDEST,1,3)
      dim=MAXCH+1
      ism=2
      IF(ITYPE.EQ.1)GO TO 555

      ans='x'              !It is a matrix, and we must ask for things
      ism=1
      WRITE(6,3)ans        
   3  FORMAT(/'Peakfind along x or y axis  <',A1,'>:',$)
      CALL READA1(5,ans)
      IF(ans.EQ.'X'.OR.ans.EQ.'x')THEN
        ans='x'
        dim=XDIM
        l1=0
        l2=YDIM-1
        WRITE(6,4)l1
   4    FORMAT(/'Lower spectrum on y-axis  <',I4,'>:',$)
        CALL READI(5,l1)
        WRITE(6,5)l2
   5    FORMAT( 'Higher spectrum on y-axis <',I4,'>:',$)
        CALL READI(5,l2)
        a0=cal(1,IDEST,1,1)
        a1=cal(1,IDEST,1,2)
        a2=cal(1,IDEST,1,3)
        IF(l1.LT.0.OR.l2.GT.511)Istatus=1
      ENDIF
      IF(ans.EQ.'Y'.OR.ans.EQ.'y')THEN
        ans='y'
        dim=YDIM
        l1=0
        l2=XDIM-1
        WRITE(6,6)l1
   6    FORMAT(/'Lower spectrum on x-axis  <',I4,'>:',$)
        CALL READI(5,l1)
        WRITE(6,7)l2
   7    FORMAT( 'Higher spectrum on x-axis <',I4,'>:',$)
        CALL READI(5,l2)
        a0=cal(1,IDEST,2,1)
        a1=cal(1,IDEST,2,2)
        a2=cal(1,IDEST,2,3)
        IF(l1.LT.0.OR.l2.GT.4095)Istatus=1
      ENDIF

555   IF(Istatus.NE.0)RETURN
      NOCH=dim

C Testing spectra for fwhm and disc=dA/A
C Making peakfind
      itry=0

556   itry=itry+1
      aveno=0
      ino  =0

      avefw=0
      ifw  =0

      fw0  =0
      fw1  =0
      ifws =0

      DO l=l1,l2
        lt=((l+1)/30)*30
        IF(lt.EQ.l+1)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        isum=0
        DO m=2,dim  
          xSPEC(m)=0
          IF(ans.EQ.'s')xSPEC(m)=rSPEC(IDEST,m-1)
          IF(ans.EQ.'x')xSPEC(m)=rMAT(IDEST,m-1,l)
          IF(ans.EQ.'y')xSPEC(m)=rMAT(IDEST,l,m-1)
          IF(xSPEC(m).LT.0)xSPEC(m)=0
          IF(xSPEC(m).GT.0)NOCH=m
          isum=isum+xSPEC(m)
        ENDDO
        IF(isum.GT.0)THEN
          CALL PEAKFI(fw0t,fw1t,disct,Kmax,' ')
          ino=ino+1
          aveno=aveno+NoPeak
          DO i=1,NoPeak
            cent =Peaks(i,1)
            dcent=Peaks(i,2)
            area =Peaks(i,3)
            darea=Peaks(i,4)
            width=Peaks(i,5)
            ifw=ifw+1
            avefw=avefw+width
            IF(NoPeak.GT.2)THEN
              XCHA(i)=cent
              YCHA(i)=width
              IF(dcent.LT.0.001)dcent=0.001
              WG(i)=(1./dcent)*(1./(darea/area))
            ENDIF
          ENDDO
C Fitting the width as a linear function of channel
          IF(NoPeak.GT.2)THEN
            CALL FITS(XCHA,YCHA,WG,C,EF,2,NoPeak,CHI)
            fw0e=C(1)
            fw1e=C(2)
            IF(fw0e.LT.0.5)fw0e=0.5
            IF(fw0e.GT.NOCH/3)fw0e=NOCH/3
            IF(fw0e+NOCH*fw1e.LT.0.5)   fw1e=(0.5     -fw0e)/NOCH
            IF(fw0e+NOCH*fw1e.GT.NOCH/3)fw1e=((NOCH/3)-fw0e)/NOCH
            fw0=fw0+fw0e
            fw1=fw1+fw1e
            ifws=ifws+1
          ENDIF
        ENDIF
      ENDDO

C Finding reasonable values for fwhm and disc=dA/A (default=0.5)
      IF(ifws.GE.1)THEN
        fw0=fw0/ifws
        fw1=fw1/ifws
      ELSE
        fw0=6.0/0.85
        fw1=0.
        IF(ifw.GT.0.AND.avefw.GT.0)fw0=avefw/ifw
      ENDIF
      aveno=aveno/ino
      IF(aveno.LT. 10)disct=disc/0.5       !disc=0.5/0.5=1, means dA=A
      IF(aveno.GT. 50)disct=disc/1.0
      IF(aveno.GT.100)disct=disc/2.0 
          
      IF(fw0.LT.0.5)   fw0=0.5
      IF(fw0.GT.NOCH/3)fw0=NOCH/3
      IF(fw0+NOCH*fw1.LT.0.5)   fw1=(0.5     -fw0)/NOCH
      IF(fw0+NOCH*fw1.GT.NOCH/3)fw1=((NOCH/3)-fw0)/NOCH
      fw0 =fw0*0.85         !Easier to find peaks with less fwhm
      fw1 =fw1*0.85

      IF(itry.EQ.1)THEN
        fw0t =fw0       
        fw1t =fw1
        GO TO 556             !Searches once more for good parameters
      ENDIF
  
      disc=disct
C Asking for fwhm and disc
      WRITE(6,*)' '
      WRITE(6,*)' '
      WRITE(6,17)
17    FORMAT('The peakfind routine needs an estimate of the',/,
     +       'experimental fwhm given as a linear function of',/,
     +       'channels by fwhm=fw0+fw1*channel, and the threshold',/, 
     +       'for when peaks are listed according to the uncertainty',/,
     +       'in counts: dA/A < threshold' )  

      WRITE(6,14)fw0
14    FORMAT(/'fw0 (ch) in peaksearch <',F7.2,'>:',$)
      CALL READF(5,fw0)
      WRITE(6,15)fw1
15    FORMAT( 'fw1 in peaksearch   <',F10.6,'>:',$)
      CALL READF(5,fw1)

      WRITE(6,16)disc
16    FORMAT( 'Peaks listed when dA/A less than   <',F5.2,'>:',$)
      CALL READF(5,disc)

C Opening output files and writing headings
      CALL DATETIME(DATTIM)
      WRITE(6,*)' '
      WRITE(6,24)
      WRITE(6,19)FNAME(ISM,IDEST),DATTIM(1:12)
      WRITE(6,20)fw0,fw1,disc
      WRITE(6,21)a0,a1,a2
      WRITE(6,22)
      WRITE(6,23)
      WRITE(6,24)

      OPEN (Idev,FILE='peakfit.out',ACCESS='APPEND',IOSTAT=IOS)
      IF(IOS.EQ.0)THEN
        WRITE(Idev,24)
        WRITE(Idev,19)FNAME(ISM,IDEST),DATTIM(1:12)
        WRITE(Idev,20)fw0,fw1,disc
        WRITE(Idev,21)a0,a1,a2
        WRITE(Idev,22)
        WRITE(Idev,23)
        WRITE(Idev,24)
      ENDIF

19    FORMAT('Peakfit results for file:     ',A,' at ',A)
20    FORMAT('fw0 = ',F7.1,' ch  and fw1= ',F7.3,'    (dA/A) < ',F5.2)
21    FORMAT('Calibration (a0,a1,a2)=',F8.1,F9.3,E12.4,/)
22    FORMAT('Spec Centroid  fwhm  Counts(dCount)  Energy(dEnergy)   fwhm')
23    FORMAT('(ch)   (ch)    (ch)                   (keV)    (keV)  (keV)')
24    FORMAT('===========================================================')
25    FORMAT(  I4,  F8.1,    F7.1,    I8,    I8,    F9.1,      F8.1,  F7.1)


C Making peakfind
      iPeaktest=0
      DO l=l1,l2
        isum=0
        DO m=2,dim  
          xSPEC(m)=0
          IF(ans.EQ.'s')xSPEC(m)=rSPEC(IDEST,m-1)
          IF(ans.EQ.'x')xSPEC(m)=rMAT(IDEST,m-1,l)
          IF(ans.EQ.'y')xSPEC(m)=rMAT(IDEST,l,m-1)
          IF(xSPEC(m).LT.0)xSPEC(m)=0
          IF(xSPEC(m).GT.0)NOCH=m
          isum=isum+xSPEC(m)
        ENDDO
        IF(isum.GT.0)THEN
          CALL PEAKFI(fw0,fw1,disc,Kmax,ans)
          DO i=1,NoPeak
            iPeaktest=1
            cent =Peaks(i,1)
            dcent=Peaks(i,2)
            area =Peaks(i,3)
            darea=Peaks(i,4)
            width=Peaks(i,5)
            iarea  =area+0.5
            idarea =darea+0.5
            energy =a0+a1*cent+a2*cent*cent
            denergy=(a1+2.0*a2*cent)*dcent
            efw    =(a1+2.0*a2*cent)*width
            WRITE(6,   25)l,cent,width,iarea,idarea,energy,ABS(denergy),ABS(efw)
            IF(IOS.EQ.0)WRITE(Idev,25)l,cent,width,iarea,idarea,energy,ABS(denergy),ABS(efw)
          ENDDO
          IF(NoPeak.GE.1)THEN
            WRITE(6   ,*)' '
            IF(IOS.EQ.0)WRITE(Idev,*)' '
          ENDIF
        ENDIF
      ENDDO
      IF(iPeaktest.EQ.0) WRITE(6,*)'No peaks found'

      CLOSE(Idev)
      IF(IOS.EQ.0)WRITE(6,*)'Results also written in file: peakfit.out'

C Display markers and energies at peak positions
      IF(ans.EQ.'s')THEN
        CALL INITG(NX,NY)
        L=10
        IXold=0
        IYold=0
        DO i= 1,NoPeak
          cent =Peaks(i,1)
          IF(cent.GE.LOCH.AND.cent.LE.HICH)THEN
            energy =a0+a1*cent+a2*cent*cent
            ICH = cent + 0.5
            Y = xSPEC(ICH+1)
            X = cent + 0.5
            WRITE(MCHAR,'(F7.1)')energy
            CALL CVXY(X,Y,IX,IY,1)
            IF(ABS(IYold-IY).LT.12.AND.ABS(IXold-IX).LT.40)THEN
              L=L+12+(IYold-IY)
              IF(L.GT.50)L=10            !Resets again (only 3 times stacked)
            ELSE
              L=10                       !Good place to write energy
            ENDIF 
            IF(IY.GT.NY-20)IY=NY-20
            CALL MSPOT(IX,IY+10)
            CALL IVECT(IX,IY+10+L)
            CALL MSPOT(IX,IY+15+L)
            CALL PUTG(MCHAR,7,5,1)
            IXold=IX
            IYold=IY+(L-10)
          ENDIF
        ENDDO
        CALL FINIG
      ENDIF
      RETURN
      END


      SUBROUTINE PEAKFI(fw0,fw1,disc,Kmax,ans)
C Taken from W.W.Black Nucl.Instr. and Methods 71(1969)317
C and A.L.Connelly and W.W.Black Nucl.Instr. and Methods 82(1970)141
C Peakfind routine implemented by Finn Ingebretsen 1977
C Modified for Mama by Magne Guttormsen 1995, new MATINV, new fwhm as
C function of channel, consistent fwhm of peak and correlation peak
C
C Experimental fwhm given by      fwhme=fw0+fw1*ch
C The fwhm of correlation peak is fwhmc=0.66667*fwhme

      DIMENSION SPEC(8192),F(400),F1(400)
      DIMENSION PKS(200),JMARK(200)
      INTEGER SPEC
      COMMON/PKFIND/xSPEC(8192),NOCH
      COMMON/PEAK/NoPeak,Peaks(200,5)
      REAL*8 EF(5,5)
      DIMENSION XCHA(400),YCHA(400),WG(400),C(5)
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      CHARACTER ans*1

C  MINST is smallest number of background channels on one side of peak
      DO I=1,NOCH
        SPEC(I)=0
      ENDDO
      N0=0
      cent=0.
      SumInt=0.
      PKS(1)=0.
      iLow =max0(INT(1+2*fw0),2)
      iHigh=min0(INT(NOCH-1-2*(fw0+fw1*NOCH)),NOCH-2)
      NOCHdelta=NOCH/20                     !Calculate 20 times the fwhm
      IF(NOCHdelta.EQ.0)NOCHdelta=1
      IF(fw0.LT.0.001)RETURN
      IF(NOCH.LT.5)RETURN
      IF(iLow.GE.iHigh-2)RETURN
      DO 10 I=iLow,iHigh                    !First big loop
C  Assumes Gaussian correlation shape
C  con1=2.*SQRT(ALOG(2.)/3.1415926)/fwhmc
C  con2=4.*ALOG(2.)/(fwhmc)**2
       
      IF(INT((I-iLow)/NOCHdelta)*NOCHdelta.EQ.(I-iLow))THEN
        fwhme=fw0+I*fw1
        IF(fwhme.GT.199)fwhme=199
        fwhmc=0.666667*fwhme
        con1 =0.939437/fwhmc
        con2 =2.772589/(fwhmc*fwhmc)
        K=fwhme+0.5
        NBCKGD=2*K
        MINST=NBCKGD/4
        IF(MINST.LT.2)MINST=2
        KK=2*K+1
        DO j=1,KK
          F(j) =con1*EXP(-con2*(j-K-1)**2)
          F1(j)=(1./KK-F(j))**2
        ENDDO

      ENDIF

      sum=0.
      VAR=0.
      IK1=max(I-K,1)
      IK2=min(I+K,NOCH)
      sum2=0.
C sum2 is the correlation function
      DO J=IK1,IK2
        TMP=xSPEC(J)
        sum=sum+TMP
        JIK1=J-I+K+1
        VAR=VAR+F1(JIK1)*TMP
        sum2=sum2+F(JIK1)*TMP
      ENDDO

      B=0
      IF(VAR.GT.0.01)B=1.6*SQRT(VAR)
      sum2=sum2-sum/KK-B

C Test if correlation is significant
      IF(sum2.LE.0.)GO TO 725

C Yes, was last  0 or -1
      IF(SPEC(I-1).EQ.1)GO TO 720

C  Last was 0 or -1, initiates store of this peak
      PEAK=sum2+B
      i1=I
      nPeak=1

C  nPeak is the peaknumber. i1 is first channel
 720  sum2=sum2+B
      nPeak=nPeak+1
      IF(nPeak.GT.200)nPeak=200
      PKS(nPeak)=sum2
      cent=cent+(I-1)*sum2
      SumInt=SumInt+sum2
      SPEC(I)=1
      IF(sum2.GT.PEAK)PEAK=sum2
      GO TO 10

C Insignificant correlation, was last time 1
  725 IF(SPEC(I-1).NE.1)GO TO 10

C Peak is just passed
      nPeak=nPeak+1
      IF(nPeak.GT.200)nPeak=200
      PKS(nPeak)=0.
      i2=I-1
      N0=N0+1
      Peaks(N0,1)=cent/SumInt
      cent=0.
      SumInt=0.

C  Finding width of correlation peak
      PEAK=PEAK*0.5
      KL=1
      DO 46 J=2,nPeak
      GO TO(47,48),KL
   47 IF(PKS(J).LT.PEAK)GO TO 46
      CH11=(J-1)+(PEAK-PKS(J-1))/(PKS(J)-PKS(J-1))
      KL=2
      GO TO 46
   48 IF(PKS(J).GT.PEAK)GO TO 46
      CH22=(J-1)+(PEAK-PKS(J-1))/(PKS(J)-PKS(J-1))
      GO TO 50
   46 CONTINUE

C  Storing width
   50 Peaks(N0,2)=(CH22-CH11)    

C  IGNORE ONE-CHANNEL "SPIKES"
      INTPK=Peaks(N0,2)*100.
      IF(INTPK.NE.100)GO TO 49
      N0=N0-1
      GO TO 10
  49  IF(N0.LT.200)GO TO 11
      IF(Idev.NE.0)WRITE(Idev,650)
  650 FORMAT('Peak array filled')
      GO TO 13
   11 MEXP=(KK+i1-i2-1)/2.+0.5
      IF(MEXP.LE.0)GO TO 10

C  The input width is larger than the calculated
C  Making forbidden region for background
      JJJ1=i1-MEXP
      JJJ2=i1-1
      DO J=JJJ1,JJJ2
        IF(SPEC(J).NE.1)SPEC(J)=-1
      ENDDO
      JJJ1=i2+1
      JJJ2=i2+MEXP
      DO J=JJJ1,JJJ2
        IF(SPEC(J).NE.1)SPEC(J)=-1
      ENDDO

   10 CONTINUE
   13 CONTINUE
      KSIGF=0
      iBac=0
      IMX=N0
      Peaks(N0+1,1)=100000.
      MARKR=1
      JMARK(1)=100000
      N0=0

      DO 40 II=1,IMX                    !Second big loop
      cent=Peaks(II,1)
      width=Peaks(II,2)
      icent=cent+0.5
      fwhme=fw0+cent*fw1
      IF(fwhme.GT.199)fwhme=199
      fwhmc=0.666667*fwhme
      K=fwhme+0.5
      NBCKGD=2*K
      MINST=NBCKGD/4
      IF(MINST.LT.2)MINST=2
      KK=2*K+1
 
      IB=icent+1
  749 IF(SPEC(IB).EQ.1) GO TO 750
      i1=IB
      GO TO 751
  750 IB=IB-1
      GO TO 749
  751 IB=icent
  752 IB=IB+1
      IF(SPEC(IB).EQ.1) GO TO 752
      i2=IB-1

C Finding area of real peak
      BCKGD=0.
      MEXP=(KK+i1-i2-1)/2.+0.5
      IF(MEXP.LT.0)MEXP=0
      JJJ3=i1-MEXP
      JJJ4=i2+MEXP
      IF(iBac.EQ.1)GO TO 73
      JJJ=i1-MEXP
      LCASE=1
      LBCGD=0
      DO 51 J=1,NBCKGD
   52 JJ=JJJ-J
      IF(JJ.LE.0)GO TO 40
      IF(SPEC(JJ).NE.0)GO TO 60
      XCHA(J)=JJ
      YCHA(J)=xSPEC(JJ)
      WG(J)=0.5
      IF(YCHA(J).GE.10.)WG(J)=1./YCHA(J)
      LBCGD=LBCGD+1
      GO TO 51
   60 IF(LBCGD.GE.MINST)GO TO 61
      LCASE=2
      JJJ=JJJ-1
      GO TO 52
   51 CONTINUE
   61 JJJ=i2+MEXP
      JLOW=JJ-1
      JSTR=LBCGD
      MCASE=1
      MBCGD=0
      DO 54 J=1,NBCKGD
   55 JJ=JJJ+J
      IF(JJ.GE.NOCH)GO TO 40
      IF(SPEC(JJ).NE.0)GO TO 70
      JARR=J+JSTR
      IF(JARR.GT.400)JARR=400
      XCHA(JARR)=JJ
      YCHA(JARR)=xSPEC(JJ)
      WG(JARR)=0.5
      IF(YCHA(JARR).GE.10.)WG(JARR)=1./YCHA(JARR)
      MBCGD=MBCGD+1
      GO TO 54
   70 IF(MBCGD.GT.MINST)GO TO 71
      MCASE=2
      JJJ=JJJ+1
      GO TO 55
   54 CONTINUE
   71 NPTS=LBCGD+MBCGD
      IF(NPTS.GT.400)NPTS=400
      JHIG=JJ-1
      DO 72 J=1,NPTS
   72 XCHA(J)=XCHA(J)-JJ
C Fitting the background
      CALL FITS(XCHA,YCHA,WG,C,EF,Kmax,NPTS,CHI)
   73 ARVAR=0.
      PKVAR=0.
      sum=0.

C  Check doublets and their integration limits
      iBac=0
      IF(II.EQ.1)GO TO 74
      ICDIF=Peaks(II-1,1)+0.5

C  Is low limit for plot below last peak
      IF(JLOW.GT.ICDIF)GO TO 74
      ICDIF=(icent-ICDIF)/2.-0.5             !Corrected by Magne
      IDIF2=icent-JJJ3+1

C  Check distance between adjcent peaks
      IF(ICDIF.GE.IDIF2)GO TO 74
      JJJ3=icent+1-ICDIF
   74 CONTINUE
      ICDIF=Peaks(II+1,1)+0.5
      IF(JHIG.LE.ICDIF)GO TO 75
      ICDIF=(ICDIF-icent)/2.-0.5
      IDIF2=JJJ4-1-icent
      IF(ICDIF.GE.IDIF2)GO TO 76
      JJJ4=icent+1+ICDIF
   76 iBac=1
   75 CONTINUE

      IF(ans.EQ.'s')THEN
        CALL SETCOLOR(20)         !black
        CALL INITG(NX,NY)
      ENDIF
      IF(JJJ3.LT.1)JJJ3=1
      DO J=JJJ3,JJJ4
        SPC=xSPEC(J)
        BCKGD=0.
        VARBCK=0.
        FAC1=1.
        DO N=1,Kmax
          FAC=FAC1
          DO K1=1,Kmax
            VARBCK=VARBCK+EF(N,K1)*FAC
            FAC=FAC*(J-JJ)
          ENDDO
          BCKGD=BCKGD+C(N)*FAC1
          FAC1=FAC1*(J-JJ)
        ENDDO
        VARBCK=VARBCK*CHI
        ARVAR=ARVAR+SPC+VARBCK
        PKVAR=PKVAR+(SPC+VARBCK)*(J-cent)**2
        IF(ans.EQ.'s')THEN
          IF(cent.GE.LDX.AND.cent.LE.HDX)THEN
            X = J
            Y=BCKGD
            CALL CVXY(X,Y,IX,IY,1)
            IF(J.EQ.JJJ3)CALL MSPOT(IX,IY)
            CALL IVECT(IX,IY)
          ENDIF
        ENDIF
        sum=sum+SPC-BCKGD
      ENDDO
      IF(ans.EQ.'s')THEN
        CALL FINIG
      ENDIF

      dsum=0
      IF(ARVAR.GT.0.01)dsum=SQRT(ARVAR)
      IF(sum.EQ.0.)sum=1.
      IF(ABS(dsum/sum).LE.disc.AND.sum.GT.4.)GO TO 65
      IF(KSIGF.EQ.1)GO TO 398
      GO TO 40
   65 N0=N0+1
      dcent=0
      IF(PKVAR.GT.0.01)dcent=SQRT(PKVAR)/sum
      JJ3=JJJ3-1
      JJ4=JJJ4-1
      JMARK(MARKR)=JJJ3
      JMARK(MARKR+1)=JJJ4
      MARKR=MARKR+2
      JMARK(MARKR)=100000
      KSIGF=1
      Peaks(N0,1)=cent
      Peaks(N0,2)=dcent
      Peaks(N0,3)=sum
      Peaks(N0,4)=dsum
      Peaks(N0,5)=width           
  398 CONTINUE
      MARKR=1
   40 CONTINUE
    
C Taking away narrow peaks, not significant
      wmax=1
      ii=0
      DO i=1,N0
        IF(Peaks(i,5).GT.0.01*wmax)THEN
          ii=ii+1
          Peaks(ii,1)=Peaks(i,1)
          Peaks(ii,2)=Peaks(i,2)
          Peaks(ii,3)=Peaks(i,3)
          Peaks(ii,4)=Peaks(i,4)
          Peaks(ii,5)=Peaks(i,5)*1.5 !Remember fwhmc=0.66667fwhme
        ENDIF
        IF(Peaks(i,5).GT.wmax)wmax=Peaks(i,5)
      ENDDO
      NoPeak=ii
      RETURN
      END

      SUBROUTINE FITS(X,Y,W,C,E,Kmax,NPTS,CHI)
C GENERAL SUBROUTINE FOR POLYNOMIAL FIT
C ENTER WITH X AND Y VALUES, WEIGHT, NO. OF WANTED PARAMETERS
C IN Kmax, AND NO. OF POINTS (.LE.200) IN NPTS.  RETURNS WITH COVAR
C MATRIX IN EF,PARAMETERS IN C AND NORMALLIZED CHISQUARED IN CHI
      REAL*8 E(5,5)
      DIMENSION X(400),Y(400),W(400),C(5),EF(5,5),RS(5)
      IDIM=5
      sum1=0.
      DO 2 K=1,Kmax
      DO 1 K1=1,Kmax
    1 E(K,K1)=0.
    2 RS(K)=0.
      DO 5 J=1,NPTS
      FAC1=W(J)
      DO 4 K=1,Kmax
      FAC=FAC1
      DO 3 K1=1,Kmax
      E(K,K1)=E(K,K1)+FAC
    3 FAC=FAC*X(J)
      RS(K)=RS(K)+FAC1*Y(J)
    4 FAC1=FAC1*X(J)
    5 sum1=sum1+W(J)*Y(J)*Y(J)
      DO 6 K=1,Kmax
      DO 6 K1=1,K
      EF(K,K1)=E(K,K1)
    6 EF(K1,K)=EF(K,K1)
      CALL MATINV(E,Kmax,IDIM)
      sum2=0.
      DO 8 K=1,Kmax
      sum=0.
      DO 7 K1=1,Kmax
    7 sum=sum+E(K,K1)*RS(K1)
      C(K)=sum
    8 sum2=sum*RS(K)+sum2
      sum3=0.
      DO 9 K=1,Kmax
      DO 9 K1=1,Kmax
    9 sum3=sum3+C(K)*C(K1)*EF(K,K1)
      NDIV=NPTS-Kmax
      IF(NDIV.LE.0)NDIV=1
      CHI=(sum1-2.*sum2+sum3)/NDIV
      RETURN
      END
       SUBROUTINE POLYFIT 
       COMMON/pofit/iii
C Just a few questions to answer for polynomfit when iii=1
       iii=1
       CALL funcfit
       RETURN
       END

C*******************************************************************
C  READ-WRITE-PROCEDURES FOR 1 OR 2 DIMENSIONAL SPECTRA
C  mama-version
C  Version 7. Oct. 2003/mg
C*******************************************************************

      SUBROUTINE WRITEFILE
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      INTEGER XDIM,YDIM, dim
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER UTFIL1*80,UTFIL2*80,UTFIL3*80,FILNAM*80,APP*4
      REAL Calib(6), Spec(0:8191)

      WRITE(6,1)IDEST
1     FORMAT(/'Spectrum to write            <',I1,'>:',$)
      CALL READI(5,IDEST)
      IF(IDEST.GT.2)Istatus=1
      IF(Istatus.NE.0)RETURN

      UTFIL1='SPEC'
      UTFIL2='NA-'
      UTFIL3='TEST'
      IUTF=21

 888  CONTINUE
      WRITE(6,2)
   2  FORMAT('Singles spectrum                1',/,
     1       'Set of spectra NA-0, NA-1,...   2',/,
     2       '2-dimensional spectrum (matrix) 3')
      WRITE(6,3)ITYPE
   3  FORMAT('Please, choose your type     <',I1,'>:',$)
      CALL READI(5,ITYPE)
      IF(Istatus.NE.0)RETURN
 
      IF(ITYPE.EQ.1)THEN
        WRITE(6,23)  cal(2,IDEST,1,1)
        CALL READF(5,cal(2,IDEST,1,1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,24)  cal(2,IDEST,1,2)
        CALL READF(5,cal(2,IDEST,1,2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,25)  cal(2,IDEST,1,3)
        CALL READF(5,cal(2,IDEST,1,3))
        IF(Istatus.NE.0)RETURN
        m=0
        DO i=1,1
          DO j=1,3
            m=m+1
            Calib(m)=cal(2,IDEST,i,j)
          ENDDO
        ENDDO
        iCal=m
        LIN=MAXCH+1
        WRITE(6,4)LIN
    4   FORMAT(/'Length of output-spectrum <',I4,'>:',$)
        CALL READI(5,LIN) 
        IF(Istatus.NE.0)RETURN
        dim=LIN
        WRITE(6,5)UTFIL1(1:4)
    5   FORMAT( 'Filename                  <',A,'>:',$)
        CALL READA(5,UTFIL1)
        IF(Istatus.NE.0)RETURN
        DO i=0,8191
          Spec(i)=rSPEC(IDEST,i)
        ENDDO
        CALL LENGDE(UTFIL1,LIN)
        FILNAM=UTFIL1(1:LIN)         
        OPEN(IUTF,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
        CALL norw1dim(IUTF,comm(2,IDEST),dim,Spec,Calib)
        CLOSE(IUTF)
      ENDIF

      IF(ITYPE.EQ.2)THEN
        WRITE(6,23)  cal(1,IDEST,1,1)
        CALL READF(5,cal(1,IDEST,1,1)) 
        IF(Istatus.NE.0)RETURN
        WRITE(6,24)  cal(1,IDEST,1,2)
        CALL READF(5,cal(1,IDEST,1,2))
        IF(Istatus.NE.0)RETURN 
        WRITE(6,25)  cal(1,IDEST,1,3)
        CALL READF(5,cal(1,IDEST,1,3))
        IF(Istatus.NE.0)RETURN
        m=0
        DO i=1,1
          DO j=1,3
            m=m+1
            Calib(m)=cal(1,IDEST,i,j)
          ENDDO
        ENDDO
        iCal=m
        NSPEC=YDIM
        WRITE(6,9)NSPEC
   9    FORMAT(/,'Number of spectra (max=512) <',I3,'>:',$)
        CALL READI(5,NSPEC)
        IF(Istatus.NE.0)RETURN
        WRITE(6,10)XDIM
  10    FORMAT('Length of output-spectra   <',I4,'>:',$)
        CALL READI(5,XDIM)
        IF(Istatus.NE.0)RETURN
        dim=XDIM
        WRITE(6,11)UTFIL2(1:3)
  11    FORMAT('Filename                    <',A,'>:',$)
        CALL READA(5,UTFIL2)
        IF(Istatus.NE.0)RETURN
        CALL LENGDE(UTFIL2,LIN)
        DO j=0,NSPEC-1
          DO i=0,4095
            Spec(i)=rMAT(IDEST,i,j)
          ENDDO
          FILNAM=UTFIL2(1:LIN)//APP(j+1)
          OPEN(IUTF,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
          CALL norw1dim(IUTF,COMM(1,IDEST),dim,Spec,Calib)
          CLOSE(IUTF)
        ENDDO
      ENDIF

      IF(ITYPE.EQ.3)THEN
        WRITE(6,23)cal(1,IDEST,1,1)
 23     FORMAT(/'Cal. coeff. a0 (keV) on x-axis     <',F11.1,'>:',$)
        CALL READF(5,cal(1,IDEST,1,1))
        IF(Istatus.NE.0)RETURN
        WRITE(6,24)cal(1,IDEST,1,2)
 24     FORMAT( 'Cal. coeff. a1 (keV/ch) on x-axis  <',F11.3,'>:',$)
        CALL READF(5,cal(1,IDEST,1,2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,25)cal(1,IDEST,1,3)
 25     FORMAT( 'Cal. coeff. a2 (keV/ch2) on x-axis <',E11.4,'>:',$)
        CALL READF(5,cal(1,IDEST,1,3))
        IF(Istatus.NE.0)RETURN
        WRITE(6,26)cal(1,IDEST,2,1)
 26     FORMAT(/'Cal. coeff. a0 (keV) on y-axis     <',F11.1,'>:',$)
        CALL READF(5,cal(1,IDEST,2,1)) 
        IF(Istatus.NE.0)RETURN
        WRITE(6,27)cal(1,IDEST,2,2)
 27     FORMAT( 'Cal. coeff. a1 (keV/ch) on y-axis  <',F11.3,'>:',$)
        CALL READF(5,cal(1,IDEST,2,2))
        IF(Istatus.NE.0)RETURN
        WRITE(6,28)cal(1,IDEST,2,3)
 28     FORMAT( 'Cal. coeff. a2 (keV/ch2) on y-axis <',E11.4,'>:',$)
        CALL READF(5,cal(1,IDEST,2,3))
        IF(Istatus.NE.0)RETURN
        WRITE(6,30)XDIM
  30    FORMAT(/'Dimension on x-axis (max=4096) <',I4,'>:',$)
        CALL READI(5,XDIM)
        IF(Istatus.NE.0)RETURN
        IF(XDIM.GT.4096)XDIM=4096
        WRITE(6,31)YDIM
  31    FORMAT( 'Dimension on y-axis (max=512)  <',I4,'>:',$)
        CALL READI(5,YDIM)
        IF(Istatus.NE.0)RETURN
        IF(YDIM.GT.512)YDIM=512
        IF(Istatus.NE.0)RETURN
        WRITE(6,32)UTFIL3(1:4)
  32    FORMAT( 'Filename                       <',A,'>:',$)
        CALL READA(5,UTFIL3)
        IF(Istatus.NE.0)RETURN
        FILNAM=UTFIL3
        OPEN(IUTF,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
        CALL norw2dim(IUTF,COMM(1,IDEST))
        CLOSE(IUTF)         
      ENDIF

      CALL SetMarker(1,1,1)

      IF(ITYPE.NE.1.AND.ITYPE.NE.2.AND.ITYPE.NE.3)GO TO 888
      GO TO 99
9999  WRITE(6,*)'No file access'
      CLOSE(IUTF)
  99  CONTINUE
      END
 
   
      SUBROUTINE READFILE
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      INTEGER XDIM,YDIM,dim
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      CHARACTER FILNAM*80,FILNAMX*80,APP*4,text*110,tableline*5000
      REAL Calib(6), Spec(0:8191)
      CHARACTER*1 ans

      INTEGER*2 mctype,mca,seg,strtch,lngtdt      !MCA (MultiChannelAnalyzer on PC)
      INTEGER*2 begrec,endrec,Iold2               !MCA
      INTEGER*4 spcin(8),xdum,lvetme,rltime,Iold4 !MCA
      CHARACTER*1 srttme(4),srtsec(2),srtdte(8)   !MCA

C******************************************************* 
C
C  INPUT-PROCEDURE OF READING 1 OR 2 DIMENSIONAL SPECTRA
C
C******************************************************* 
      ITYPEold=ITYPE
      IDESTold=IDEST

      IDEST=1
      WRITE(6,1)IDEST
1     FORMAT('Destination spectrum <',I1,'>:',$)
      CALL READI(5,IDEST)
      IF(IDEST.GT.2)Istatus=1
      IF(Istatus.NE.0)RETURN
      NFILIN=0
      INF=20
      ITYP=0
      ITYPE=0
      FILNAM='TEST'

C Trying first to open file and extract parameters from
C the header file. After this we ask, with proper defaults
      WRITE(6,2)FILNAM(1:4)
  2   FORMAT('Filename          <',A,'>:',$)
      CALL READA(5,FILNAM)
      IF(Istatus.NE.0)RETURN
      OPEN(INF,FILE=FILNAM,ACCESS='SEQUENTIAL',status='old',ERR=901)
      GO TO 3

C No file with this name. Checks if it is of type NA-0, NA-1, NA-2,..etc.
 901  CLOSE(INF)
      CALL LENGDE(FILNAM,LIN)
      DO i=1,512
        FILNAMX=FILNAM(1:LIN)//APP(i)
        OPEN(INF,FILE=FILNAMX,ACCESS='SEQUENTIAL',status='old',ERR=902)
        ITYP=2        ! The spectra are of type NA-0, NA-1, NA-2,..
        GO TO 3       ! out of loop and reads spectra of type 2
 902    CONTINUE
      ENDDO

      WRITE(6,4)FILNAM(1:LIN),FILNAM(1:LIN)
 4    FORMAT('File: ',A,' or ',A,'xx (xx=number) do not exist')
      CLOSE(INF)
      ITYPE=ITYPEold
      IDEST=IDESTold
      RETURN

 3    CONTINUE                       !OK, file exist, reads the header

      READ(INF,5,ERR=999)text
 5    FORMAT(A110)
      READ(text(1:1),6,ERR=903)
 6    FORMAT(A)

      IF(text(1:1).EQ.'!')THEN       ! It is a mama file
        REWIND(INF)
        DO i=1,10 
          READ(INF,5,ERR=903)text
          IF(text(1:10).EQ.'!DIMENSION')THEN
            READ(text(12:12),7)I1
 7          FORMAT(I1)
            IF(I1.EQ.1.AND.ITYP.EQ.0)THEN
              ITYPE=1 
            ENDIF
            IF(I1.EQ.1.AND.ITYP.EQ.2)THEN
              ITYPE=2 
            ENDIF
            IF(I1.EQ.2.AND.ITYP.EQ.0)THEN
              ITYPE=3 
            ENDIF
          ENDIF
        ENDDO
      
 903    REWIND(INF)

        IF(ITYPE.EQ.1)THEN             !singles spectrum
          DO i=0,8191
            Spec(i)=0
          ENDDO
          CALL norr1dim(INF, comm(2,IDEST), dim, Spec, Calib)
          DO i=1,3            !Adopting the calibration from file
            IF(Calib(1).NE.0.OR.Calib(2).NE.1)cal(2,IDEST,1,i)=Calib(i)
          ENDDO
          DO i=0,8191
            rSPEC(IDEST,i)=Spec(i)
          ENDDO
          MAXCH=dim-1
          CALL SetMarker(1,2,0)
        ENDIF

        IF(ITYPE.EQ.2)THEN             ! spectra NA-0, NA-1,...
          CLOSE(INF)
          DO j=0,511
            DO i=0,4095
              Spec(i)=0
            ENDDO
            FILNAMX=FILNAM(1:LIN)//APP(j+1)
            OPEN(INF,FILE=FILNAMX,ACCESS='SEQUENTIAL',status='old',ERR=904)
            CALL norr1dim(INF, comm(1,IDEST), dim, Spec, Calib)
            CLOSE(INF)
            YDIM=j+1     !The last successful spectrum determine Y-dimension
904         CONTINUE
            DO i=0,4095
              rMAT(IDEST,i,j)=Spec(i)
            ENDDO
          ENDDO
          XDIM=dim
          DO i=1,3
            IF(Calib(1).NE.0.OR.Calib(2).NE.1)cal(1,IDEST,1,i)=Calib(i)
          ENDDO
          cal(1,IDEST,2,1)=0.
          cal(1,IDEST,2,2)=1.
          cal(1,IDEST,2,3)=0.
          CALL SetMarker(1,1,1)
        ENDIF

        IF(ITYPE.EQ.3)THEN                 !matrix
          CALL norr2dim(INF)
          CALL SetMarker(1,1,1)
        ENDIF

905     CONTINUE
        CLOSE(INF)
        GO TO 3333
      ENDIF

C Checks if it is a PAW file - just one array of numbers 
C or many coloumns of arrayes of numbers (table)
C No of coloumns is ydim and rows is xdim
C Checks if it is a table, e.g. Is no of coloumns > 1?
      READ(INF,*,ERR=906)xdumr     !ERR=It was no number here, not a PAW-file
      REWIND(INF)
      icolo = 0
      READ(INF,24,ERR=29)tableline
 24   FORMAT(A1000)
      DO n=1,511
         READ(tableline(1:5000),*,ERR=20)(Spec(j),j=0,n-1)
      ENDDO
 20   IF(n.LT.3)GO TO 29
      ITYPE = 3
      YDIM = n-1
      REWIND(INF)
      DO i=0,4095
         READ(INF,*,END=21,ERR=21) (rMAT(IDEST,i,j),j=0,YDIM-1)
      ENDDO
 21   XDIM=i
      WRITE(6,22)XDIM,YDIM
 22   FORMAT('Paw matrix (table) has dimension ',I4,' x ',I3)
      CALL SetMarker(1,1,1)
      comm(1,IDEST)='paw '
      CLOSE(INF)
      GO TO 3333

C We have one coloumn, but it may still be a paw-matrix
 29   kch=0
      DO k=0,(4096*512)-1
        READ(INF,*,END=10,ERR=906)xdumr
        kch=kch+1
      ENDDO
 10   IF(kch.LE.1)GO TO 906
      IF(k.LE.8192)THEN
        ans='y'
        ITYPE=1
        WRITE(6,11)kch+1
 11     FORMAT(/'PAW file with ',I8,' channels')
        WRITE(6,12)ans
 12     FORMAT('Is it a singles spectrum (y/n)? <',A1,'>:',$)
        CALL READA1(5,ans)
        IF(Istatus.NE.0)RETURN
        IF(ans.NE.'y')ITYPE=3
      ELSE
        ans='y'
        ITYPE=3
        WRITE(6,11)kch+1
        WRITE(6,13)ans
 13     FORMAT('Is it a 2-dimensional matrix (y/n)? <',A1,'>:',$) 
        CALL READA1(5,ans)
        IF(Istatus.NE.0)RETURN
        IF(ans.NE.'y')ITYPE=1
      ENDIF
      IF(ITYPE.EQ.1)THEN            !PAW singles
        REWIND(INF)
        DO i=0,8191
          READ(INF,*,END=14,ERR=906) rSPEC(IDEST,i)
        ENDDO
14      MAXCH=i-1
        CALL SetMarker(1,2,0)
        comm(2,IDEST)='paw '
        CLOSE(INF)
        GO TO 3333
      ENDIF
      IF(ITYPE.EQ.3)THEN           !PAW matrix
        REWIND(INF)
        XDIM=MIN0(4096,kch+1)
        WRITE(6,15)XDIM
15      FORMAT('Give dimension on x-axis <',I4,'>:',$)
        CALL READI(5,XDIM)
        IF(Istatus.NE.0)GO TO 906
        DO j=0,511
          DO i=0,XDIM-1
            READ(INF,*,END=16,ERR=906) rMAT(IDEST,i,j)
          ENDDO
        ENDDO
16      YDIM=j
        WRITE(6,17)XDIM,YDIM
17      FORMAT('Paw matrix has dimension ',I4,' x ',I3)
        CALL SetMarker(1,1,1)
        comm(1,IDEST)='paw '
        CLOSE(INF)
        GO TO 3333
      ENDIF
         
906   CONTINUE
 
C It could be an MCA-spectrum (ORTEC multichannel analyzer)
C Uncertain to me if we should have RECL=8 or RECL=32 here, depends on -xl:
      CLOSE(INF)
      OPEN(INF,FILE=FILNAM,STATUS='OLD',ACCESS='DIRECT',RECL=32,ERR=907)     
      READ(INF,REC=1,ERR=907)mctype,mca,seg,srtsec,rltime,lvetme,srtdte,srttme,strtch,lngtdt

C Transform from Intel to Sparc representation of INTEGER number
      Iold2=mctype
      CALL TransI2(Iold2,mctype)
      IF(mctype.NE.-1)GO TO 907    !Not an ORTEC MCA-spectrum
      Iold2=mca
      CALL TransI2(Iold2,mca)
      Iold2=seg
      CALL TransI2(Iold2,seg)
      Iold4=rltime
      CALL TransI4(Iold4,rltime)
      Iold4=lvetme
      CALL TransI4(Iold4,lvetme)
      Iold2=strtch
      CALL TransI2(Iold2,strtch)
      Iold2=lngtdt
      CALL TransI2(Iold2,lngtdt)
      WRITE(6,40)
 40   FORMAT(/'ORTEC MCA singles spectrum:')
      WRITE(6,41)mctype,mca,seg,rltime/50,
     1 lvetme/50,srttme,srtsec,srtdte,strtch,lngtdt
 41   FORMAT('Type=',I4,' mca #',I2,' Segment # ',
     1 I3,/,'Realtime= ',I10,' seconds, Livetime= ',
     2 I10,' seconds',/,'Data collected at ',2A1,':',2A1,
     3 ':',2A1,' on ',2A1,'-',3A1,'-',3A1,/,
     4 'Starting channel=',I6,' Number of channels=' ,
     5 I6,//)


C Reading spectrum
      ii=0
      DO ich=strtch+1,lngtdt,8
        chanel=ich-1
        endrec=chanel/8.
        begrec=chanel/8.
        DO n=begrec+2,endrec+2
          READ(INF,rec=n,ERR=42)(spcin(l),l=1,8)
          DO l=1,8
            ii=ii+1
            Iold4=spcin(l)
            CALL TransI4(Iold4,xdum)
            IF(ABS(xdum).GT.1677215)xdum=0
            rSPEC(IDEST,ii-1)=xdum
            IF(xdum.GT.0)itop=ii
          ENDDO
        ENDDO
      ENDDO
 42   IF(ii.LT.3)GO TO 907           !Not a real MCA-spectrum
      IF(itop.LT.(lngtdt/2)) THEN
         WRITE(6,*)'Warning: Less than half spectrum filled with data!'
         WRITE(6,*)'You probably forgot to use binary transfer (FTP binary).'
      ENDIF
      MAXCH=ii-1
      ITYPE=1
      CALL SetMarker(1,2,0)
      comm(2,IDEST)='mca '
      CLOSE(INF)

C Stripping away path-name from spectrum name
3333  CALL LENGDE(FILNAM,LIN)
      ii=0
      DO i=1,LIN
        IF(FILNAM(i:i).EQ.'/')ii=i  ! ii marks the position of last '/'
      ENDDO
      I1=1                !matrix
      IF(ITYPE.EQ.1)I1=2  !singles
      DO i=1,MIN0(LIN,8)
        j=i+ii
        IF(j.LE.80)fname(I1,IDEST)(i:i)=FILNAM(j:j)
      ENDDO
      DO i=MIN0(LIN,8)+1,8          !blanks out the rest
        fname(I1,IDEST)(i:i)=' '
      ENDDO
      xcomm='|RE:'//fname(I1,IDEST)(1:MIN0(LIN,8))
      CALL AddComment(xcomm,12)
      RETURN 

907   IF(ITYPE.EQ.0)THEN
        WRITE(6,*)'Sorry, not a spectrum/matrix file'
        WRITE(6,*)'The spectrum is of unknown type (mama (1,2,3), MCA or PAW)'
        CLOSE(INF)
        ITYPE=ITYPEold
        IDEST=IDESTold
        RETURN
      ENDIF
999   WRITE(6,*)'Tullball with the header file, could not retrieve info, go home!'
      ITYPE=ITYPEold
      IDEST=IDESTold
      RETURN
      END


      SUBROUTINE norr1dim(device, comment, dim, Spec, Calib)
C Reads a one-dimensional spectrum from disk.
C Dimension and calibration returned in dim and Calib. IF dim=-1 at
C startup, then no headers are shown at reading
      INTEGER device, dim
      CHARACTER text*110,dum*1,comment*60
      REAL Calib(6), Spec(0:8191)
      NoOutput=0
      IF(dim.EQ.-1)NoOutput=1
      dim=10
      linemax=12
C Read file header
      DO i=1,12
        READ(device,100,ERR=110)text
100     FORMAT(A110)
        IF(text(1:1).NE.'!')THEN
          linemax=i-1
          GO TO 91
        ENDIF
        DO ii=1,110                       ! Finding length of textstring
          iii=111-ii
          IF(text(iii:iii).NE.' ')GO TO 90
        ENDDO
 90     IF(NoOutput.NE.1)WRITE(6,*)text(2:iii)
        IF(text(1:12).EQ.'!CALIBRATION')THEN
          READ(text(20:61),105,ERR=106)dum,Calib(1),dum,Calib(2),dum,Calib(3)
105       FORMAT(3(A1,E13.6))
        ENDIF
106     CONTINUE
        IF(text(1:10).EQ.'!DIMENSION')THEN
          READ(text(16:19),107,ERR=108)dim
107       FORMAT(I4)
        ENDIF
108     CONTINUE
        IF(text(1:9).EQ.'!COMMENT=')THEN
          DO k=10,69
            comment(k-9:k-9)=text(k:k)
          ENDDO
        ENDIF
      ENDDO
 91   dim=dim+1
C Read spectrum
      REWIND(device)
      DO i=1,linemax
        READ(device,100,ERR=110)text
      ENDDO
      READ(device,*,ERR=110)(Spec(i),i=0,dim-1)
      IF(NoOutput.NE.1)WRITE(6,*)' '
      RETURN
110   WRITE(6,*)'Reading problems. Wrong dimension of spectrum?'
      RETURN
      END


      SUBROUTINE norr2dim(device)
C Read a two-dimensional spectrum matrix from disk 
      CHARACTER text*110,APP*4,dum*1
      INTEGER device,XDIM,YDIM
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

C Read file header
      DO i=1,10
        READ(device,100,ERR=800)text
100     FORMAT(A110)
        DO ii=1,110                          !Finding length of textstring
          iii=111-ii
          IF(text(iii:iii).NE.' ')GO TO 90
        ENDDO
 90     WRITE(6,*)text(2:iii)
        IF(text(1:12).EQ.'!CALIBRATION')THEN
          READ(text(20:103),105,ERR=106)
     +    dum,ax0,dum,ax1,dum,ax2,
     +    dum,ay0,dum,ay1,dum,ay2
105       FORMAT(6(A1,E13.6))
          IF(ax0.NE.0.OR.ax1.NE.1.OR.ay0.NE.0.OR.ay1.NE.1)THEN
             cal(1,IDEST,1,1)=ax0
             cal(1,IDEST,1,2)=ax1
             cal(1,IDEST,1,3)=ax2
             cal(1,IDEST,2,1)=ay0
             cal(1,IDEST,2,2)=ay1
             cal(1,IDEST,2,3)=ay2
          ENDIF
        ENDIF
106     CONTINUE
        IF(text(1:10).EQ.'!DIMENSION')THEN
          j1=0
          DO j=1,110-3
            IF(text(j:j+2).EQ.',0:')THEN  !Finding dimensions
              IF(j1.EQ.0)THEN
                j1=j+3
              ELSE
                j2=j-1
                j3=j+3
                j4=j3+3
              ENDIF
            ENDIF
          ENDDO
          READ(text(j1:j2),107,ERR=108)NX
          READ(text(j3:j4),107,ERR=108)NY
          XDIM=NX+1
          YDIM=NY+1
 107      FORMAT(I4)
        ENDIF
 108    CONTINUE
        IF(text(1:9).EQ.'!COMMENT=')THEN
          DO k=10,69
            comm(1,IDEST)(k-9:k-9)=text(k:k)
          ENDDO
        ENDIF
      ENDDO
 
C Read matrix
      DO j=0,NY
        jt=((j+1)/50)*50
        IF(jt.EQ.j+1)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF
        READ(device,*,ERR=800)(rMAT(IDEST,i,j),i=0,NX)
      ENDDO
      WRITE(6,*)' '
      RETURN
  800 WRITE(6,*)'Reading problems. Dimension of matrix wrong?'
      RETURN
      END

 
      SUBROUTINE norw1dim(device, comment, dim, Spec, Calib)
C Writes a singles spectrum array to disk
      character comment*60, id*24
      real Calib(6), Spec(0:8191)
      integer device, dim
      iCal=3
      CALL CLOCK(id)

C --  Write file header
      WRITE (device,100)
      WRITE (device,101)
      WRITE (device,102) comment
      WRITE (device,103) id
      WRITE (device,104) iCal,(Calib(i),i=1,iCal)
      WRITE (device,105) dim-1, dim-1
 100  FORMAT ('!FILE=Disk')
 101  FORMAT ('!KIND=Spectrum',/,
     +        '!LABORATORY=Oslo Cyclotron Laboratory (OCL)',/,
     +        '!EXPERIMENT=mama')
 102  FORMAT ('!COMMENT=',A60)
 103  FORMAT ('!TIME=DATE:',A24)
 104  FORMAT ('!CALIBRATION EkeV=',I1,3(',',E13.6))
 105  FORMAT ('!PRECISION=16',/,'!DIMENSION=1,0:',I4,/,'!CHANNEL=(0:',I4,')')

C --  Write spectrum
      WRITE (device,*)(Spec(i),i=0,dim-1)
      WRITE (device,106)
 106  FORMAT ('!IDEND='/)
      RETURN
      END

 
      SUBROUTINE norw2dim(device,comment)
C Write a two-dimensional spectrum matrix to disk 
      CHARACTER comment*60,APP*4,id*24
      REAL Calib(6)
      INTEGER device,XDIM,YDIM
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      NX=XDIM-1
      NY=YDIM-1
      iCal=6
      m=0
      DO i=1,2
        DO j=1,3
          m=m+1
          Calib(m)=cal(1,IDEST,i,j)
        ENDDO
      ENDDO

      CALL CLOCK(id)
   
C --  Write file header
      WRITE(device,100)
      WRITE(device,101)
      WRITE(device,102) comment
      WRITE(device,103) id
      WRITE(device,104) iCal,(Calib(i),i=1,iCal)
      WRITE(device,105) NX,NY,NX,NY
 100  FORMAT('!FILE=Disk')
 101  FORMAT('!KIND=Spectrum',/,
     +'!LABORATORY=Oslo Cyclotron Laboratory (OCL)',/,
     +'!EXPERIMENT=mama')
 102  FORMAT('!COMMENT=',A60)
 103  FORMAT('!TIME=DATE:',A24)
 104  FORMAT('!CALIBRATION EkeV=',I1,6(',',E13.6))
 105  FORMAT('!PRECISION=16',/,'!DIMENSION=2,0:',I4,',0:',I3,/,
     +'!CHANNEL=(0:',I4,',0:',I3,')')

C Write matrix
      DO j=0,NY
        WRITE(device,*)(rMAT(IDEST,i,j),i=0,NX)
      ENDDO
      WRITE(device,106)
 106  FORMAT('!IDEND='/)
      RETURN
      END


      SUBROUTINE WRITEPAW
C Write spectra or matrix to file that can be accessed by PAW 
C The spectra is simply a free-format write of integers (no header, calibr., etc.)
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      INTEGER XDIM,YDIM
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER UTFIL1*80,UTFIL3*80,FILNAM*80,APP*4

      WRITE(6,1)IDEST
1     FORMAT(/'Spectrum to write            <',I1,'>:',$)
      CALL READI(5,IDEST)
      IF(IDEST.GT.2)Istatus=1
      IF(Istatus.NE.0)RETURN

      UTFIL1='SPEC'
      UTFIL3='TEST'
      IUTF  = 21

 888  CONTINUE
      WRITE(6,2)
   2  FORMAT('Singles spectrum                1',/,
     1       '2-dimensional spectrum (matrix) 3')
      WRITE(6,3)ITYPE
   3  FORMAT('Please, choose your type     <',I1,'>:',$)

      CALL READI(5,ITYPE)
      IF(Istatus.NE.0)RETURN
      IF(ITYPE.NE.1.AND.ITYPE.NE.3)GO TO 888
 
      IF(ITYPE.EQ.1)THEN
        LEN=MAXCH+1
        WRITE(6,4)LEN
    4   FORMAT('Length of output-spectrum <',I4,'>:',$)
        CALL READI(5,LEN)
        IF(Istatus.NE.0)RETURN
        WRITE(6,5)UTFIL1(1:4)
    5   FORMAT('Filename                  <',A,'>:',$)
        CALL READA(5,UTFIL1)
        IF(Istatus.NE.0)RETURN
        CALL LENGDE(UTFIL1,LIN)
        FILNAM=UTFIL1(1:LIN)         
        OPEN(IUTF,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
        DO i=0,LEN-1
          WRITE(IUTF,*,ERR=9999)rSPEC(IDEST,i)
        ENDDO
      ENDIF

      IF(ITYPE.EQ.3)THEN
        IF(Istatus.NE.0)RETURN
        WRITE(6,30)XDIM
  30    FORMAT(/'Dimension on x-axis (max=4096) <',I4,'>:',$)
        CALL READI(5,XDIM)
        IF(Istatus.NE.0)RETURN
        IF(XDIM.GT.4096)XDIM=4096
        WRITE(6,31)YDIM
  31    FORMAT( 'Dimension on y-axis (max=512)  <',I4,'>:',$)
        CALL READI(5,YDIM)
        IF(Istatus.NE.0)RETURN
        IF(YDIM.GT.512)YDIM=512
        IF(Istatus.NE.0)RETURN
        WRITE(6,32)UTFIL3(1:4)
  32    FORMAT( 'Filename                       <',A,'>:',$)
        CALL READA(5,UTFIL3)
        IF(Istatus.NE.0)RETURN
        FILNAM=UTFIL3
        OPEN(IUTF,FILE=FILNAM,ACCESS='SEQUENTIAL',ERR=9999)
        NX=XDIM-1
        NY=YDIM-1
C  Write matrix
        DO j=0,NY
          DO i=0,NX
            WRITE(IUTF,*)rMAT(IDEST,i,j)
          ENDDO
        ENDDO
      ENDIF

      CALL SetMarker(1,1,1)

      GO TO 99
9999  WRITE(6,*)'No file access or writing problems'
  99  CONTINUE
      CLOSE(IUTF)
      END


      SUBROUTINE CLOCK(string)
      CHARACTER*24 ctime, string
      INTEGER n, time
      n=time()
      string=ctime(n)
      RETURN
      END


      SUBROUTINE READI(IDEV,INTEG)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER X*80
      READ(IDEV,1,ERR=99)X
    1 FORMAT(80A)
      IF(X.EQ.'')RETURN
      READ(X,*,ERR=99)INTEG
      RETURN
 99   Istatus=1
      RETURN
      END


      SUBROUTINE READF(IDEV,REELL)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER X*80
      READ(IDEV,1,ERR=99)X
    1 FORMAT(80A)
      IF(X.EQ.'')RETURN
      READ(X,*,ERR=99)REELL
      RETURN
99    Istatus=1
      RETURN
      END


      SUBROUTINE READA(IDEV,KAR)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER X*80
      CHARACTER KAR*80
      READ(IDEV,1,ERR=99)X
    1 FORMAT(80A)   
      IF(X.EQ.'')RETURN
      READ(X,1,ERR=99)KAR
      RETURN
99    Istatus=1
      RETURN
      END


      SUBROUTINE READA1(IDEV,KAR)
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      CHARACTER X*1
      CHARACTER KAR*1
      READ(IDEV,1,ERR=99)X
    1 FORMAT(A1)
      IF(X.EQ.''.OR.X.EQ.' ')RETURN
      READ(X,*,ERR=99)KAR
      RETURN
99    Istatus=1
      RETURN
      END


       SUBROUTINE LENGDE(TEXT,LEN)
C Calculating the length of a string of characters             
       CHARACTER TEXT*80
       CHARACTER CH*1
       DO K=1,80
         CH=TEXT(K:K)
         IF(CH.EQ.' ')THEN
           LEN=K-1
           GO TO 20
         ENDIF
       ENDDO
   20  RETURN
       END


      SUBROUTINE TransI2(I1,I2)
C Routine that transform a I*2 integer of Intel (or VMS) processor to
C an I*2 integer of Sparc (or MC680xx) prosessor
C See p.426 in SPARCompiler FORTRAN 2.0.1, Reference Manual
C These operations are wonderful. Personally, I get a cick for each shift...
      INTEGER*2 mask1,mask2,I1,I2,J1,J2,I,ISHFT

      mask1=B'0000000011111111'
      mask2=B'1111111100000000'

      I2=0
      J1=0
      J2=0
   
      I =0
      I =AND(I1,mask1)
      J1=ISHFT(I,8)          !shifts I-bits 8 places to the left 

      I =0
      I =AND(I1,mask2)
      J2=ISHFT(I,-8)          !shifts I-bits 8 places to the right

C Putting together again the 16 bit word 
      I2=OR(J1,I2)     
      I2=OR(J2,I2)

      END


      SUBROUTINE TransI4(I1,I2)
C Routine that transform a I*4 integer of Intel (or VMS) processor to
C an I*4 integer of Sparc (or MC680xx) prosessor
C See p.426 in SPARCompiler FORTRAN 2.0.1, Reference Manual
      INTEGER*4 mask1,mask2,mask3,mask4,I1,I2,I,J1,J2,J3,J4,ISHFT
      
      mask1=B'00000000000000000000000011111111'
      mask2=B'00000000000000001111111100000000'
      mask3=B'00000000111111110000000000000000'
      mask4=B'11111111000000000000000000000000'
      
      I2=0
      J1=0
      J2=0
      J3=0
      J4=0
      
      I =0
      I =AND(I1,mask1)
      J1=ISHFT(I,24)        !Shift 24 to left

      I =0
      I =AND(I1,mask2)
      J2=ISHFT(I,8)         !Shift 8 to left

      I =0
      I =AND(I1,mask3)
      J3=ISHFT(I,-8)        !Shift 8 to right

      I =0
      I =AND(I1,mask4)
      J4=ISHFT(I,-24)       !Shift 24 to right

      I2=OR(J1,I2)
      I2=OR(J2,I2)
      I2=OR(J3,I2)
      I2=OR(J4,I2)
      
      END

      SUBROUTINE SETCTS
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60
      CHARACTER*80 ANS
      COMMON /LUS/ IR,IW,IP,IG
      IF(ITYPE.GT.1)THEN
        WRITE(6,*)'The command do not work on matrices (use instead PC)'
        WRITE(6,*)'If you want to set counts in a singles spectrum, you'
        WRITE(6,*)'should first select the spectrum with the IC or CR command'
        RETURN
      ENDIF
      iT=0
      Istatus=-7     !to flag that green button is active
      CALL CLEANUP
      CALL INITG(nx,ny)             !Pixel size of window
      is=18
      mx1=2
      mx2=mx1+2*is
      mx3=mx2+4
      mx4=mx3+2*is
      mx5=mx4+4
      mx6=mx5+3*is
      mx7=mx6+4
      mx8=mx7+3*is
      mx10=nx-1
      mx9=mx10-13
      my1=ny+42
      my2=my1-0.7*is
      my3=my2-0.3*is
      my33=my3-4    !An extra -4 because we never get iy > spec. area

      itest=0
      itry=0
10    IF (.NOT.DISP) GO TO 20
      WRITE(6,1)
1     FORMAT('Click on green button (or type X) to exit'
     +     /,'Click in spectrum to define counts (or type T)')
      CALL RETIC(X,Y,ANS)
      IF (ANS(1:1).EQ.'T' .OR. ANS(1:1).EQ.'t') GO TO 20
      IF (ANS(1:1).EQ.'X' .OR. ANS(1:1).EQ.'x') RETURN
      CALL CVXY(X,Y,ix,iy,1)
      IF(ix.GE.mx9.AND.ix.LE.mx10.AND.iy.GE.my33) RETURN

C            hit t for type, x to exit....
      ILO=X
      Y1=Y

30    CALL RETIC(X,Y,ANS)
      IF (ANS(1:1).EQ.'T' .OR. ANS(1:1).EQ.'t') GO TO 20
      IF (ANS(1:1).EQ.'X' .OR. ANS(1:1).EQ.'x') RETURN
      CALL CVXY(X,Y,ix,iy,1)
      IF(ix.GE.mx9.AND.ix.LE.mx10.AND.iy.GE.my33) RETURN

      IHI=X
      Y2=Y
      GO TO 80

C          ask for typed limits....
c20    CALL ASK(17HType limits (chs),17,ANS,K)
20    CALL CASK('Type limits (chs): ',ANS,K)

      IF (K.EQ.0) RETURN
      CALL ININ(ANS,K,ILO,IHI,J2,*20)
      IF (ILO.GT.0.AND.IHI.EQ.0) IHI=ILO
      IF (ILO.GT.MAXCH.OR.IHI.GT.MAXCH.OR.ILO.LT.0.OR.IHI.LT.0) THEN
         WRITE(IW,*) 'Marker ch. outside spectrum - try again'
                  itry=itry+1
                  IF(itry.GE.3)THEN
                    WRITE(6,*)'Sorry, not your day today'
                    RETURN
                  ENDIF

         GO TO 20
      ENDIF
c      CALL ASK(19HType counts per ch.,19,ANS,K)
      CALL CASK('Type counts per channel: ',ANS,K)
      CALL FFIN(ANS,K,Y,RJ1,RJ2,*20)
      Y1=Y
      Y2=Y
      iT=1

80    IF (ILO.GT.IHI) THEN
         ISAVE=IHI
         IHI=ILO
         ILO=ISAVE
         Y2=Y1
         Y1=Y
      ENDIF
C Updating comment in the heading of spectrum file
      itest=itest+1
      IF(itest.EQ.1)THEN
        xcomm='CT:'
        write(xcomm(4:7),991,ERR=997)ILO
991     FORMAT(I4)
        xcomm(8:8)='-'
        write(xcomm(9:12),991,ERR=997)IHI
997     CALL AddComment(xcomm,12)
      ENDIF
C        modify contents of spectrum....
      rSPEC(IDEST,ILO)=(Y1+Y2)/2.0
      IF (ILO.EQ.IHI) GO TO 10
      FNC=IHI-ILO
      DO 110 I=ILO,IHI
         rSPEC(IDEST,I)=Y1+(Y2-Y1)*FLOAT(I-ILO)/FNC
110   CONTINUE

C        display modified segment....
      CALL INITG(NX,NY)
      X=FLOAT(ILO)+0.5
      CALL PSPOT(X,Y1)
      X=FLOAT(IHI)+0.5
      CALL VECT(X,Y2)
      CALL FINIG
      IF(iT.EQ.1)RETURN

      ILO=IHI
      Y1=Y2
      GO TO 30

      END

C======================================================================

      SUBROUTINE SETEXT(FILNAM,CEXT,IEXT)

C           set default extension of filename FILNAM to CEXT...
C           leading spaces are first removed from FILNAM....
C           if extension is present, it is left unchanged....
C           if no extension is present, CEXT is used....
C           IEXT is a returned pointer to the dot of the .EXT....
C           CEXT should include the dot plus a three-letter extension....

      CHARACTER*40 FILNAM,FN
      CHARACTER*4  CEXT
      INTEGER      IEXT

C       remove leading spaces from FILNAM....

      FN=FILNAM
      DO 10 I=1,40
         IF (FN(1:1).NE.' ') GO TO 20
         FN(1:39)=FILNAM(2:40)
         FN(40:40)=' '
         FILNAM=FN
10    CONTINUE

C       look for file extension in FILNAM....
C            ....if there is none, put it to CEXT....

20    DO 30 ISP=1,36
         IF (FILNAM(ISP:ISP).EQ.' ') GO TO 40
30    CONTINUE
      ISP=37
40    DO 50 I=ISP-1,1,-1
         IF (FILNAM(I:I).EQ.']' .OR. FILNAM(I:I).EQ.':') GO TO 60
         IF (FILNAM(I:I).EQ.'.') GO TO 70
50    CONTINUE
60    I=ISP
      FILNAM(I:I+3)=CEXT
70    IEXT=I

      RETURN
      END
      SUBROUTINE SetMarker(ix,iy,iz)
C Routine to set display markers:
C        ix=-1    Take markers from spec.,  test that x-markers are valid
C        ix=0     USE LDX (or HDX) OR new LDX given by the DX-command
C        ix=1     set full scale for x-marker according to dimension
C        ix=2     autoscale according to counts in matrix or spectrum
C        iy,iz    as above as for x-axis. iz active only for matrices

C     ldx,hdx=    markers on x-axis for 2-dim plot
C     ldy,hdy=    markers on y-axis for 2-dim plot
C     ldz,hdz=    markers on z-axis for 2-dim plot
C     loch,hich=  markers on x-axis for 1-dim spectrum
C     locnt,hicnt=markers on y-axis for 1-dim spectrum

      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      INTEGER XDIM,YDIM
      CHARACTER APP*4
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      REAL dex(14)
      COMMON/mem1/iLDX(2),iHDX(2),iLDY(2),iHDY(2),iLDZ(2),iHDZ(2)
      COMMON/mem2/iLOCH(2),iHICH(2),iLOCNT(2),iHICNT(2)
      REAL iLDZ,iHDZ,iLOCNT,iHICNT

      IF(IDEST.LT.1.OR.IDEST.GT.2)THEN
        WRITE(6,*)'Warning, IDEST has wrong value= ',IDEST,', Reset to 1' 
        IDEST=1
        RETURN
      ENDIF
      IF(ITYPE.LT.1.OR.ITYPE.GT.3)THEN
        WRITE(6,*)'Warning, ITYPE has wrong value= ',ITYPE,', Reset to 3' 
        ITYPE=3
        RETURN
      ENDIF

      IF(ITYPE.GT.1)THEN          !As default is taken the last value
        IF(ix.EQ.-1)LDX =iLDX(IDEST)
        IF(iy.EQ.-1)LDY =iLDY(IDEST)
        IF(iz.EQ.-1)LDZ =iLDZ(IDEST)
        IF(ix.EQ.-1)HDX =iHDX(IDEST)
        IF(iy.EQ.-1)HDY =iHDY(IDEST)
        IF(iz.EQ.-1)HDZ =iHDZ(IDEST)
      ELSE
        IF(ix.EQ.-1)LOCH =iLOCH(IDEST)
        IF(ix.EQ.-1)HICH =iHICH(IDEST)
        IF(iy.EQ.-1)LOCNT=iLOCNT(IDEST)
        IF(iy.EQ.-1)HICNT=iHICNT(IDEST)
      ENDIF

      IF(ITYPE.GT.1)THEN          !matrix
        IF(XDIM.GT.4096)XDIM=4096
        IF(YDIM.GT. 512)YDIM=512
        IF(ix.EQ.1)THEN           !Reset full scale
          LDX=0
          HDX=XDIM-1
        ENDIF
        IF(iy.EQ.1)THEN
          LDY=0
          HDY=YDIM-1
        ENDIF
        IF(iz.EQ.1)THEN
          LDZ=0.1
          HDZ=10000
        ENDIF
        
        IF(ix.EQ.2)THEN             !Autoscale
          DO i=XDIM-1,10,-2         !Finding LDX,HDX
            iT=(i/1000)*1000
            IF(iT.EQ.i)THEN
              write(6,FMT='(A1,$)')'.'
              call flush(6)
            ENDIF
            DO j=0,YDIM-1,1
              IF(rMAT(IDEST,i,j).NE.0)GO TO 1
            ENDDO
          ENDDO
 1        a=0
          b=i
          b=b*1.01
          CALL GRAX(a,b,dex,nv,1)
          LDX=a
          HDX=dex(nv)*(nv+1)/nv
          IF(HDX.GT.XDIM-1)HDX=XDIM-1
        ENDIF
        IF(iy.EQ.2)THEN
          DO j=YDIM-1,10,-1         !Finding LDY,HDY
            JT=(j/100)*100
            IF(JT.EQ.J)THEN
              write(6,FMT='(A1,$)')'.'
              call flush(6)
            ENDIF
            DO i=0,XDIM-1,2
              IF(rMAT(IDEST,i,j).NE.0)GO TO 2
            ENDDO
          ENDDO
 2        a=0
          b=j
          b=j*1.01
          CALL GRAX(a,b,dex,nv,1)
          LDY=a
          HDY=dex(nv)*(nv+1)/nv
          IF(HDY.GT.YDIM-1)HDY=YDIM-1
        ENDIF
        IF(iz.EQ.2)THEN
          LDZ=4.                   !Finding LDZ,HDZ
          HDZ=0.00001
          do j=LDY,HDY,1           !Testing each y-channel
          jt=(j/100)*100
            IF(jt.EQ.j+1)THEN
              write(6,FMT='(A1,$)')'.'
              call flush(6)
            ENDIF
            do i=LDX,HDX,2         !Testing only every second x-channel
              rr=ABS(rMAT(IDEST,i,j))
              IF(rr.GT.HDZ)HDZ=rr*1.1 !Use 1.1 to get color
              IF(rr.LT.LDZ.AND.rr.GT.0)THEN
                LDZ=ABS(rr)
              ENDIF
            enddo
          enddo
          LDZ=AMIN1(0.1,(HDZ)/1000.)
c          IF(HDZ.GT.50 )LDZ=2
c          IF(HDZ.GT.500)LDZ=4
        WRITE(6,*)' '
        ENDIF

      ELSE                        !singles
        DO i=0,8191
          IF(ABS(rSPEC(IDEST,i)).GT. 1.0E+36)rSPEC(IDEST,i)=0.
          IF(ABS(rSPEC(IDEST,i)).LT. 1.0E-36)rSPEC(IDEST,i)=0.
        ENDDO
        IF(MAXCH.GT.8191)MAXCH=8191
        IF(ix.EQ.1)THEN           !Reset full scale
          LOCH=0
          HICH=MAXCH
        ENDIF 
        ia=LOCH
        ib=HICH                  
        IF(ix.EQ.2)THEN           !Autoscale
          DO i=8191,10,-1         !Finding LOCH,HICH
            IF(rSPEC(IDEST,i).NE.0)GO TO 3
          ENDDO
 3        a=0
          b=i
          b=b*1.01
          IF(b.GT.MAXCH)b=MAXCH
          ia=a
          ib=b
          CALL GRAX(a,b,dex,nv,1)
          LOCH=a
          HICH=dex(nv)*(nv+1)/nv
          IF(HICH.LE.   10)HICH=10
          IF(HICH.GT.MAXCH)HICH=MAXCH
        ENDIF

        IF(iy.EQ.1.OR.iy.EQ.2)THEN
          LOCNT=0                 !Finding LOCNT,HICNT
          HICNT=0.00001
          CALL INITG(NX,NY)
          NCC =(HICH-LOCH)/NX+1
          NCHS=HICH-LOCH+1
          ii1=MAX0(ia+2,INT(ia+0.01*NCHS))
          ii2=MIN0(ib,  INT(ib-0.01*NCHS))
          IF(ii2-ii1.LT.10)THEN
            ii1=LOCH+1
            ii2=HICH
          ENDIF
          IF(NCC.EQ.1)THEN                         !pixels > channels 
            DO I=ii1,ii2
              IF(HICNT.LT.rSPEC(IDEST,I))HICNT=rSPEC(IDEST,I)
              IF(LOCNT.GT.rSPEC(IDEST,I))LOCNT=rSPEC(IDEST,I)
            ENDDO
          ELSE                                     !pixels < channels
            DO ICH=LOCH,LOCH+(NCHS/NCC-1)*NCC,NCC
              Yc=0.
              DO I=1,NCC
                Yc=Yc+rSPEC(IDEST,ICH+I-1)
              ENDDO
              Yc=Yc/(FLOAT(NCC))
              IF((HICNT.LT.Yc).AND.(ICH.GT.ii1).AND.(ICH.LT.ii2))HICNT=Yc
              IF((LOCNT.GT.Yc).AND.(ICH.GT.ii1).AND.(ICH.LT.ii2))LOCNT=Yc
            ENDDO
          ENDIF
c          LOCNT=0                 !Brutal force
        ENDIF
      ENDIF


C Last test that everything is OK (option ix,iy,iz=0)
      IF(ITYPE.GT.1)THEN
        LDX  =max0(0,LDX)
        HDX  =min0(4095,HDX)
        IF(LDX.GE.HDX)THEN
          WRITE(6,*)'Warning, x-display markers reset'
          LDX=0
          HDX=4095
        ENDIF
        LDY  =max0(0,LDY)
        HDY  =min0(511,HDY)
        IF(LDY.GE.HDY)THEN
          WRITE(6,*)'Warning, y-display markers reset'
          LDY=0
          HDY=511
        ENDIF
        IF(LDZ.EQ.0)LDZ=0.1
        LDZ  =max(0.0000001,LDZ)
        HDZ  =max(0.000001,HDZ)
        IF(LDZ.GE.HDZ)THEN
          WRITE(6,*)'Warning, z-display limits reset'
          LDZ=0.1
          HDZ=10000
        ENDIF
      ELSE
        LOCH =max0(0,   LOCH)
        HICH =min0(8191,HICH)
        IF(LOCH.GE.HICH)THEN
          WRITE(6,*)'Warning, display markers reset'
          LOCH=0
          HICH=8191
        ENDIF
      ENDIF

      IF(ITYPE.GT.1)THEN          !Remember last displaymarkers
        iLDX(IDEST)  =LDX
        iLDY(IDEST)  =LDY
        iLDZ(IDEST)  =LDZ
        iHDX(IDEST)  =HDX
        iHDY(IDEST)  =HDY
        iHDZ(IDEST)  =HDZ
      ELSE
        iLOCH(IDEST) =LOCH
        iHICH(IDEST) =HICH
        iLOCNT(IDEST)=LOCNT
        iHICNT(IDEST)=HICNT
      ENDIF

c        write(6,*)'IYAXIS',IYAXIS
c        write(6,*)'IDEST,ITYPE,XDIM,YDIM,MAXCH',IDEST,ITYPE,XDIM,YDIM,MAXCH
c        write(6,*)'LDX,HDX,LDY,HDY,LDZ,HDZ',LDX,HDX,LDY,HDY,LDZ,HDZ
c        write(6,*)'LOCH,HICH,LOCNT,HICNT',LOCH,HICH,LOCNT,HICNT

      RETURN
      END

      SUBROUTINE SUMCTS(K,ILO,IHI)

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS
      LOGICAL DISP
      INTEGER            IYAXIS,LDX,HDX,LDY,HDY,LOCH,HICH
      COMMON/DISPLA/DISP,IYAXIS,LDX,HDX,LDY,HDY,LDZ,HDZ,LOCH,HICH,LOCNT,HICNT
      REAL LDZ,HDZ,LOCNT,HICNT
      COMMON/Sp1Dim/rSPEC(2,0:8191),MAXCH
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      INTEGER         IWMODE
      CHARACTER*8     NWTSP
      REAL            WTSP(8192)
      COMMON /WTMODE/ IWMODE,NWTSP,WTSP

      CHARACTER*80 ANS
      COMMON /LUS/ IR,IW,IP,IG

C  K=0: sum without background subtraction
C  K=1: sum with    background subtraction     K=1 always, Magne

      IF(ILO.GE.0.AND.IHI.GT.0.AND.ILO.LE.MAXCH.AND.IHI.LE.MAXCH)THEN
        Y1=rSPEC(IDEST,ILO)
        Y2=rSPEC(IDEST,IHI)
      ELSE
        IF(.NOT.DISP) THEN
c10        CALL ASK(25HLimits for integration = ,25,ANS,NC)
10    CALL CASK('Limits for integration = ',ANS,NC)

          IF (NC.EQ.0) RETURN
          CALL ININ(ANS,NC,ILO,IHI,J2,*10)
          IF(ILO.GE.0.AND.IHI.GT.0
     +    .AND. ILO.LE.MAXCH.AND.IHI.LE.MAXCH)THEN
            Y1=rSPEC(IDEST,ILO)
            Y2=rSPEC(IDEST,IHI)
          ELSE
            GO TO 10
          ENDIF
        ELSE
          WRITE(IW,*) 'Use cursor to define limits, T to type limits'
          CALL RETIC(X,Y,ANS)
          IF (ANS(1:1).EQ.'T'.OR.ANS(1:1).EQ.'t') GO TO 10
          ILO=X
          Y1=Y
          CALL RETIC(X,Y,ANS)
          IF (ANS(1:1).EQ.'T'.OR.ANS(1:1).EQ.'t') GO TO 10
          IHI=X
          Y2=Y
        ENDIF
      ENDIF

C Checking that everything OK
      IF (ILO.GT.IHI)THEN
         ISAV=IHI
         IHI=ILO
         ILO=ISAV
         YSAVE=Y2
         Y2=Y1
         Y1=YSAVE
      ENDIF
      Dch=IHI-ILO
      IF (Dch.LT.0.5)Dch=1.0

C Display limits
      IF(DISP)THEN
         ISAVE=MCH(1)
         MCH(1)=ILO
         CALL DSPMKR(1)
         MCH(1)=IHI
         CALL DSPMKR(1)
         MCH(1)=ISAVE
      ENDIF

C Initializing
      a0=cal(2,IDEST,1,1)  !calibration coeff.
      a1=cal(2,IDEST,1,2)
      a3=cal(2,IDEST,1,3)
      Atot=0.              !areas
      Abac=0.
      Anet=0.
      xtot=0.
      xbac=0.
      xnet=0.
      Ctot=0.              !centroides
      Cbac=0.
      Cnet=0.
      ECtot=9999.99
      ECbac=9999.99
      ECnet=9999.99
      Stot=0.              !standard variations (sigma's)
      Sbac=0.
      Snet=0.
      EStot=9999.99
      ESbac=9999.99
      ESnet=9999.99

C Displaying background
      CALL INITG(NX,NY)
      X=FLOAT(ILO)+0.5
      CALL PSPOT(X,Y1)
      X=FLOAT(IHI)+0.5
      CALL VECT(X,Y2)
      CALL FINIG

      DO I=ILO,IHI
        c=rSPEC(IDEST,I)
        xtot=xtot+c
        IF(c.LT.0)c=0.
        Atot=Atot+c
        Ctot=Ctot+c*FLOAT(I)
        Stot=Stot+c*(FLOAT(I)*FLOAT(I))

        c=Y1+(Y2-Y1)*FLOAT(I-ILO)/Dch
        xbac=xbac+c
        IF(c.LT.0)c=0.
        Abac=Abac+c
        Cbac=Cbac+c*FLOAT(I)
        Sbac=Sbac+c*(FLOAT(I)*FLOAT(I))

        c=rSPEC(IDEST,I)-(Y1+(Y2-Y1)*FLOAT(I-ILO)/Dch)
        xnet=xnet+c
        IF(c.LT.0)c=0.
        Anet=Anet+c
        Cnet=Cnet+c*FLOAT(I)
        Snet=Snet+c*(FLOAT(I)*FLOAT(I))
      ENDDO
 
      IF(Atot.GT.0)THEN
        Ctot=(Ctot/Atot)
        ECtot=a0+a1*Ctot+a2*Ctot*Ctot
        Stot=(Stot/Atot)
        Stot=Stot-Ctot*Ctot
        IF(Stot.GT.0)THEN
          Stot=SQRT(Stot)
          EStot=(a1+2.0*a2*Ctot)*Stot
        ELSE
          Stot= 9999.99
          EStot=9999.99
        ENDIF
      ELSE
        Ctot= 9999.99
        ECtot=9999.99
        Stot= 9999.99
        EStot=9999.99
      ENDIF

      IF(Abac.GT.0)THEN
        Cbac=(Cbac/Abac)
        ECbac=a0+a1*Cbac+a2*Cbac*Cbac
        Sbac=(Sbac/Abac)
        Sbac=Sbac-Cbac*Cbac
        IF(Sbac.GT.0)THEN
          Sbac=SQRT(Sbac)
          ESbac=(a1+2.0*a2*Cbac)*Sbac
        ELSE
          Sbac= 9999.99
          ESbac=9999.99
        ENDIF
      ELSE
        Cbac= 9999.99
        ECbac=9999.99
        Sbac= 9999.99
        ESbac=9999.99
      ENDIF


       IF(Anet.GT.0)THEN
        Cnet=(Cnet/Anet)
        ECnet=a0+a1*Cnet+a2*Cnet*Cnet
        Snet=(Snet/Anet)
        Snet=Snet-Cnet*Cnet
        IF(Snet.GT.0)THEN
          Snet=SQRT(Snet)
          ESnet=(a1+2.0*a2*Cnet)*Snet
        ELSE
          Snet= 9999.99
          ESnet=9999.99
        ENDIF
      ELSE
        Cnet= 9999.99
        ECnet=9999.99
        Snet= 9999.99
        ESnet=9999.99
      ENDIF

      
C Write results
 13   WRITE(6,140)ILO,IHI
      WRITE(6,138)
      WRITE(6,141)
      WRITE(6,139)
      WRITE(6,142)Atot,Ctot,ECtot,Stot,ABS(EStot)
      WRITE(6,143)Abac,Cbac,ECbac,Sbac,ABS(ESbac)
      WRITE(6,144)Anet,Cnet,ECnet,Snet,ABS(ESnet)
      WRITE(6,139)
140   FORMAT(/'           Region ',I5,' -',I5,' channels')
138   FORMAT( '           Assuming only channels with positive counts')
141   FORMAT( '             Counts    Centr.(ch)  Centr.(keV)  St.dev(ch) St.dev(keV)')
139   FORMAT( '______________________________________________________________________')
142   FORMAT( 'Total   ',E13.6,F10.2,F13.2,F10.2,F13.2)
143   FORMAT( 'Backgr. ',E13.6,F10.2,F13.2,F10.2,F13.2)
144   FORMAT( 'Netto   ',E13.6,F10.2,F13.2,F10.2,F13.2)
      WRITE(6,145)xtot,xbac,xnet
145   FORMAT( '(Assuming +/- counts: Total=',E13.6,' Backgr.=',E13.6,' Netto=',E13.6,' )')
180   RETURN
      END
      SUBROUTINE TRAX(TX,XI,TY,YI,K)

C      draw axes in graphics window....
C           x-axis from xi to xi+tx....
C           y-axis from yi to yi+ty....
C           k = 1/2/3 for lin/sqrt/log y-axis on left hand side....
C           k = -1/-2/-3 for lin/sqrt/log y-axis on right hand side....
C           k = 0 for linear y-axis, no axes drawn....

      REAL        TX,XI,TY,YI
      INTEGER     K

      REAL               FDX,FX0,FDY,FY0
      INTEGER            IDX,IX0,IDY,IY0,IYFLAG,ITERM
      COMMON /MINIG_DAT/ FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG,ITERM
      
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60
      COMMON/AXIS/iCE,itext,UNITx,UNITy,UNITx0,UNITy0
      CHARACTER UNITx*3,UNITy*3,UNITx0*3,UNITy0*3
      COMMON/DisType/Idistype,OLlow,OLhigh,OLlocnt,OLhicnt
      INTEGER                 OLlow,OLhigh

      REAL DEX(14)
      CHARACTER*10 BC
      
      UNITx=' ch'
      UNITy=' ch'
      xMeV=1.
      yMeV=1.
            
      FDX = TX
      FX0 = XI
      FY0 = YI
      IYFLAG = IABS(K)
      IF (K.EQ.0) IYFLAG=1

      IF (IYFLAG.EQ.1) THEN
         FDY = TY
      ELSEIF (IYFLAG.EQ.2) THEN
         FDY = SQRT(FY0+TY)-SQRT(FY0)
      ELSE
         FY0 = AMAX1(FY0,0.001)
         FDY = ALOG(FY0+TY)-ALOG(FY0)
      ENDIF
          
C Gives graphic window parameters to global parameters of minig_x
      CALL PUTGLOBALS(FDX,FX0,FDY,FY0,IDX,IX0,IDY,IY0,IYFLAG)
          
      IF (K.EQ.0) RETURN    

      X1 = FX0              !channel-region
      X2 = FX0+FDX
      Y0 = 0
      Y1 = FY0
      Y2 = FY0+TY

      EX1= X1               !energy region
      EX2= X2
      EY1= Y1
      EY2= Y2
      CALL CVXY(X2,Y2,IXmax,IYmax,1)  !max pixelvalue for x- and y-axis
      IF(iCE.EQ.1)THEN
        UNITx=UNITx0
        UNITy=UNITy0
        IF(ITYPE.GT.1)THEN
          ax0=cal(1,IDEST,1,1)
          ax1=cal(1,IDEST,1,2)
          ax2=cal(1,IDEST,1,3)
          ay0=cal(1,IDEST,2,1)
          ay1=cal(1,IDEST,2,2)
          ay2=cal(1,IDEST,2,3)
        ELSE
          ax0=cal(2,IDEST,1,1)
          ax1=cal(2,IDEST,1,2)
          ax2=cal(2,IDEST,1,3)
          ay0=0
          ay1=1.
          ay2=0
        ENDIF

C For outlay
        IF(Idistype.EQ.2)THEN
          ay0=0.
          ay1=1.
          ay2=0.
        ENDIF

        EX1=ax0+ax1*(X1)+ax2*(X1)*(X1)
        EX2=ax0+ax1*(X2)+ax2*(X2)*(X2)
        IF(IYFLAG.EQ.1)THEN
          EY1=ay0+ay1*(Y1)+ay2*(Y1)*(Y1)
          EY2=ay0+ay1*(Y2)+ay2*(Y2)*(Y2)
        ENDIF

        IF(ABS(EX1-EX2).GT.2000.AND.UNITx.EQ.'keV')THEN
          EX1=EX1/1000.
          EX2=EX2/1000.
          UNITx='MeV'
          xMeV=1000.
        ENDIF
        IF(ITYPE.GT.1.AND.IYFLAG.EQ.1)THEN
          IF(ABS(EY1-EY2).GT.2000.AND.UNITx.EQ.'keV')THEN
            EY1=EY1/1000.
            EY2=EY2/1000.
            UNITy='MeV'
            yMeV=1000.
          ENDIF
        ENDIF
C Puts ch-unit if a0=0 and a1=1 (calibr. not defined)
        IF(ax0.EQ.0.AND.ax1.EQ.1)THEN
          UNITx=' ch'
          xMeV=1.
          EX1=X1
          EX2=X2
        ENDIF
        IF(ay0.EQ.0.AND.ay1.EQ.1)THEN
          UNITy=' ch'
          yMeV=1.
          EY1=Y1
          EY2=Y2
        ENDIF
      ENDIF

C For outlay
      IF(Idistype.EQ.2)THEN
        EY1=Y1
        EY2=Y2
      ENDIF


      ETX=ABS(EX2-EX1)
      ETY=ABS(EY2-EY1)

C Draw line for y = 0
      CALL PSPOT(X1,Y0)
      CALL VECT(X2,Y0)
c         write(6,*)x1,y0,x2,y0
C       draw x-axis....
      CALL PSPOT(X1,Y1)
      CALL VECT(X2,Y1)
      CALL GRAX(EX1,EX2,DEX,NV,1)
      
      IXold=10000    
      DO 20 N=1,NV
         V=DEX(N)
         ch=V
         IF(iCE.EQ.1)ch=CHAN(V*xMeV,ax0,ax1,ax2)+0.5
         IF (ch.EQ.X1) GO TO 20
         CALL CVXY(ch,Y1,IX,IY,1)
         CALL MSPOT(IX,IY+3)
         CALL IVECT(IX,IY-0)
         CALL MSPOT(IX,IY-1)
         IF((2*(N/2).EQ.N).AND.(IABS(IXold-IX).GT.20).AND.IX.LT.(IXmax-30))THEN
C              write value in graphtext....
            IF (ETX.LE.15.0) THEN
               WRITE(BC,5,ERR=8) V
5              FORMAT(F7.2,' ')
            ELSE
               WRITE(BC,6,ERR=8) V
6              FORMAT(F10.0)
            ENDIF
8           DO 10 I=1,9
               IF (BC(I:I).NE.' ') GO TO 15
10          CONTINUE
15          NC=10-I
            CALL PUTG(BC(I:10),-NC,6,1)
            IXold=IX
         ENDIF
20    CONTINUE

C     draw y-axis....
      X=X1
      IF (K.LT.0) X=X2
      CALL PSPOT(X,Y1)
      CALL VECT(X,Y2)
      CALL GRAX(EY1,EY2,DEX,NV,IYFLAG)
      DO 40 N=1,NV
         V=DEX(N)
         ch=V
C        Require energy-display and 3-dimensional spectra
         IF(iCE.EQ.1.AND.ITYPE.GT.1)THEN
           IF(IYFLAG.EQ.1) ch=CHAN(V*yMeV,ay0,ay1,ay2)+0.5
         ENDIF
         IF (ch.LE.Y1.OR.ch.GE.Y2) GO TO 40
         CALL CVXY(X,ch,IX,IY,1)
         IF(K.GE.0)THEN             !Y-axis on left side
           CALL MSPOT(IX+3,IY)
           CALL IVECT(IX-0,IY)
         ELSE                       !Y-axis on right side
           CALL MSPOT(IX-0,IY)
           CALL IVECT(IX-3,IY)
         ENDIF
         IF(itext.EQ.0)GO TO 40     ! no numbers on y-axis

C Enough to write 3 numbers om y-axis
         Jump  = (FLOAT(NV)/3.)+0.5
         Ntest = (N+1)/Jump*Jump
         IF ((IYFLAG.EQ.3.OR.Ntest.EQ.N+1).AND.IY.LT.IYmax-15) THEN
C              write value in graphtext....
            IF(ETY.LE.0.001)THEN
               WRITE(BC,50,ERR=25)V
            ELSEIF(ETY.LE.1.0)THEN
               WRITE(BC,51,ERR=25)V
            ELSEIF(ETY.LE.15.0) THEN
               WRITE(BC,52,ERR=25) V
            ELSE
               WRITE(BC,53,ERR=25) V
            ENDIF
50          FORMAT(F9.7,' ')
51          FORMAT(F7.4,' ')
52          FORMAT(F5.1,' ')
53          FORMAT(F10.0,' ')

25          DO 30 I=1,9
               IF (BC(I:I).NE.' ') GO TO 35
30          CONTINUE
35          NC=10-I
            IF (K.LT.0) THEN
               CALL MSPOT(IX-7,IY-7)
               CALL PUTG(BC(I:10),-NC,8,1)
            ELSE
               CALL MSPOT(IX+6,IY-7)
               CALL PUTG(BC(I:8),-NC,2,1)
            ENDIF
         ENDIF
40    CONTINUE
C Gives graphic window parameters to global parameters of minig_x

      RETURN
      END


      
      FUNCTION CHAN(E,a0,a1,a2)
C Finds the most probable solution of the 2. degree polynom:
C E=a0+a1*ch+a2*ch*ch. We assume ch to be positive (channels),
C and that a2 only makes a small change in E

C Without a1 and/or a2 term
      chan=0
      IF(a1.EQ.0.AND.a2.EQ.0)RETURN
      IF(a1.NE.0)chan=(E-a0)/a1      
      IF(a2.EQ.0)THEN
        IF(chan.LT.0)chan=0
        RETURN
      ENDIF

      tch=chan                          !to test against

C Assuming full equation with a0,a1 and a2
      chan=0
      root=a1*a1-4.*a2*(a0-E)
      IF(root.LT.0)RETURN
      ch1=(-a1+sqrt(root))/(2.*a2)
      ch2=(-a1-sqrt(root))/(2.*a2)
      t1=ABS(ch1-tch)
      t2=ABS(ch2-tch)
      IF(t1.LE.t2.AND.ch1.GE.0)chan=ch1
      IF(t2.LE.t1.AND.ch2.GE.0)chan=ch2
    
      RETURN

      END
      SUBROUTINE TYPEIT(IMODE)

      INTEGER       MCH(2)
      REAL          PPOS(15)
      COMMON /MKRS/ MCH,PPOS

      REAL          PARS(51), ERRS(51)
      INTEGER       IFIXED(51), NPARS, NFP, NPKS, IRELW, IRELPOS
      COMMON /PARA/ IRELW,PARS,IFIXED,NPARS,NFP,ERRS,NPKS,IRELPOS

      REAL          AREAS(15),DAREAS(15),CENTS(15)
      COMMON /AREA/ AREAS,DAREAS,CENTS

      REAL*8         GAIN(6)
      INTEGER        ICAL, NTERMS
      COMMON /CALIB/ GAIN, ICAL, NTERMS

      CHARACTER*40 ANS
      COMMON /LUS/ IR,IW,IP,IG
      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60

      CHARACTER*12 DATTIM

      IF (IMODE.GE.3) GO TO 55

      IF (IMODE.LE.1) THEN
         WRITE(IW,10,ERR=25)(MCH(I),I=1,2),(PPOS(I),I=1,NPKS)
10       FORMAT(' Mkr chs: limits ',2I5/12X,'Peaks ',8F8.2/18X,7F8.2)
         IPAGE = 4 - (NPKS)/8
      ELSE
         IPAGE = 6
      ENDIF

25    WRITE(IW,30,ERR=31)(PARS(I),ERRS(I),I=1,6)
30    FORMAT('Background and shape parameters:',/,
     +'A=',F10.2,'+-',F8.2,' B=',F9.4,'+-',F8.4,
     +' C=',F9.4,'+-',F8.4,/,
     +'R=',F9.2,'+-',F8.2,' Beta=',F9.3,'+-',F8.3,
     +' Step=',F6.2,'+-',F6.2)

31    IF (ICAL.EQ.0) WRITE(IW,35)
      IF (ICAL.NE.0) WRITE(IW,36)
35    FORMAT('Peak     Width           Area     Centroid')
36    FORMAT('Peak     Width           Area     Centroid',
     +'   Energy(keV)  Fwhm(keV)')
      DO 50 I=1,NPKS
         K=3*I+3
         CALL ENERGY(CENTS(I),ERRS(K+1),EG,DEG,*47)
         EFW=PARS(2+K)*(GAIN(2)+2.0*GAIN(3)*CENTS(I))
         WRITE(IW,45,ERR=49) I,(PARS(J+K),ERRS(J+K),J=2,2),
     +   IFIX(AREAS(I)),IFIX(DAREAS(I)),CENTS(I),EG,ABS(DEG),ABS(EFW)
45       FORMAT(I2,F7.2,'(',F6.2,')',
     +   I9,'(',I5,')',F8.2,F9.2,'(',F6.2,')',F7.1)
         GO TO 49
47       WRITE(IW,45,ERR=49) I,(PARS(J+K),ERRS(J+K),J=2,2),
     +              IFIX(AREAS(I)),IFIX(DAREAS(I)),CENTS(I)
49       IF (I.EQ.IPAGE.AND.I.LT.NPKS) THEN
c            CALL ASK2(28HPress any key to continue...,28,ANS,K,1)
            IPAGE = IPAGE + 9
         ENDIF
50    CONTINUE
      RETURN
C Open file to write results of peak fits     
55    OPEN(IP,FILE='peakfit.out',ACCESS='APPEND',IOSTAT=IOS)
      IF (IOS.NE.0) THEN
         WRITE(IW,*) 'Cannot open new file ',ANS
         CLOSE(IP,IOSTAT=IOS)
         RETURN       
      ENDIF
      CALL DATETIME(DATTIM)
      WRITE(IP,56)
56    FORMAT(' ')
      WRITE(IP,33,ERR=57),fname(2,IDEST),DATTIM(1:12),(PARS(I),ERRS(I),I=1,6)
33    FORMAT('Background and shape parameters for ',A,' at ',A,/,
     +'A=',F10.2,'+-',F8.2,' B=',F9.4,'+-',F8.4,
     +' C=',F9.4,'+-',F8.4,/,
     +'R=',F9.2,'+-',F8.2,' Beta=',F9.3,'+-',F8.3,
     +' Step=',F6.2,'+-',F6.2)

57    IF (ICAL.EQ.0) WRITE(IP,35)
      IF (ICAL.NE.0) WRITE(IP,36)
      DO 60 I=1,NPKS
         K=3*I+3
         EFW=PARS(2+K)*(GAIN(2)+2.0*GAIN(3)*CENTS(I))
         CALL ENERGY(CENTS(I),ERRS(K+1),EG,DEG,*59)
         WRITE(IP,45,ERR=60) I,(PARS(J+K),ERRS(J+K),J=2,2),
     +           IFIX(AREAS(I)),IFIX(DAREAS(I)),CENTS(I),EG,DEG,EFW
         GO TO 60
59       WRITE(IP,45,ERR=60) I,(PARS(J+K),ERRS(J+K),J=2,2),
     +           IFIX(AREAS(I)),IFIX(DAREAS(I)),CENTS(I)
60    CONTINUE
      CLOSE(IP)
      RETURN
      END

      SUBROUTINE Uncorrelation
      INTEGER XDIM,YDIM,RDIM,Sij,Si,Sj
      CHARACTER APP*4, ans*1
      COMMON/Sp2Dim/rMAT(2,0:4095,0:511),APP(512),XDIM,YDIM
      COMMON/RESPONE/R(0:511,0:511),RDIM,A0,A1,FWHM

      COMMON/State/Istatus,ITYPE,IDEST,cal(2,2,2,3),Idim(2,2,2),fname(2,2),comm(2,2)
      CHARACTER fname*8,comm*60,xcomm*60

      ans='y'
      IDUM=1
      IF(IDEST.EQ.1)IDUM=2
      WRITE(6,1)IDUM
   1  FORMAT(/'Destination matrix <',I1,'>:',$)
      CALL READI(5,IDUM)
      ISP=1
      IF(IDUM.EQ.1)ISP=2 
      WRITE(6,2)ISP
   2  FORMAT( 'Source matrix      <',I1,'>:',$)
      CALL READI(5,ISP)
      IF(ISP.EQ.IDUM)THEN
        WRITE(6,*)'Destination must be another spectrum'
        Istatus=1
        RETURN
      ENDIF
       
      IF(Istatus.NE.0)RETURN
      IDEST=IDUM
      ITYPE=3
      XDIM=Idim(1,ISP,1)
      YDIM=Idim(1,ISP,2)
      cal(1,IDEST,1,1)=cal(1,ISP,1,1)
      cal(1,IDEST,1,2)=cal(1,ISP,1,2)
      cal(1,IDEST,1,3)=cal(1,ISP,1,3)
      cal(1,IDEST,2,1)=cal(1,ISP,2,1)
      cal(1,IDEST,2,2)=cal(1,ISP,2,2)
      cal(1,IDEST,2,3)=cal(1,ISP,2,3)
      RDIM=MAX0(XDIM,YDIM)    
      IF(RDIM.LT.0.OR.RDIM.GT.511)RDIM=512

C The subtraction of uncorrelated background starts
      Sij=0
      DO j=0,RDIM-1
        DO i=0,RDIM-1
          R(i,j)=rMAT(ISP,i,j)
          Sij=Sij+R(i,j)
        ENDDO
      ENDDO 
      WRITE(6,3)Sij
   3  FORMAT( 'Counts in matrix before correction   ',I12)
      IF(Sij.LE.0)GO TO 999

  99  n=0   
      DO j=0,RDIM-1
        jt=((j)/30)*30
        IF(jt.EQ.j)THEN
          write(6,FMT='(A1,$)')'.'
          call flush(6)
        ENDIF

        DO i=0,RDIM-1
          Sj=0
          DO ii=0,RDIM-1
            Sj=Sj+R(ii,j)
          ENDDO 
          Si=0
          DO jj=0,RDIM-1
            Si=Si+R(i,jj)
          ENDDO
          IF(Sij.EQ.0)GO TO 999
          Bij=(Si*Sj)/Sij
          rMAT(IDEST,I,J)=rMAT(ISP,I,J)-0.9*Bij
          R(i,j)=rMAT(IDEST,i,j)
          n=n+R(i,j)
        ENDDO
      ENDDO
      Sij=n
      
      WRITE(6,*)' '
      WRITE(6,4)Sij
   4  FORMAT( 'Counts in backgroundcorrected matrix ',I12)

      WRITE(6,5)ans
   5  FORMAT( 'Do you want a new iteration (y/n) <',A1,'>:',$)
      CALL READA1(5,ans)

      IF(Istatus.NE.0)RETURN

      IF(ans.EQ.'y'.OR.ans.EQ.'Y')GO TO 99

      XDIM=RDIM
      YDIM=RDIM

C Updating comment in the heading of spectrum file
      xcomm(1:4)='UN:'
      CALL AddComment(xcomm,3)
      CALL SetMarker(1,1,1)

999   RDIM=0              !Meaning no respons function present

      RETURN
      END
                       

